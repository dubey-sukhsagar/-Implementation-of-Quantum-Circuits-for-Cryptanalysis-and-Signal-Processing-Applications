/*****************************************************
*       _________        __________               
*      /   _____/        \______   \ _______  ___ 
*      \_____  \   ______ |    |  _//  _ \  \/  / 
*      /        \ /_____/ |    |   (  <_> >    <  
*     /_______  /         |______  /\____/__/\_ \ 
*             \/                 \/            \/ 
*
*****************************************************/

`include "aes_sbox_modules.v"

/*****************************************************
*
* Auto-Generated using gen_GF_2_2_2_SBox_RTL_PolyNormMixBases
*
* Author: Utsav Banerjee
*
* in -> map -> inverse -> inv_map + affine -> out
*
*****************************************************/

/*****************************************************
* Affine Matrix:
*
*	1 1 1 1 1 0 0 0 
*	0 1 1 1 1 1 0 0 
*	0 0 1 1 1 1 1 0 
*	0 0 0 1 1 1 1 1 
*	1 0 0 0 1 1 1 1 
*	1 1 0 0 0 1 1 1 
*	1 1 1 0 0 0 1 1 
*	1 1 1 1 0 0 0 1 
*****************************************************/


/*****************************************************
*
* GF(2^8) in Normal Basis
*
*****************************************************/



/*****************************************************
* S-Box # 1
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 1 0 0 1 1 	1 0 1 1 1 1 0 1 
*	1 1 1 1 0 1 0 1 	0 1 0 0 0 0 0 1 
*	0 1 1 1 0 1 1 1 	0 1 0 0 0 0 1 0 
*	0 1 1 0 0 1 0 1 	1 1 1 0 1 1 0 1 
*	0 0 1 0 1 1 1 1 	1 0 0 0 0 1 0 0 
*	1 1 1 1 1 0 1 1 	0 0 0 1 1 1 0 1 
*	1 1 0 1 0 1 0 1 	1 1 0 1 1 1 0 1 
*	1 0 1 1 0 1 0 1 	0 0 0 0 1 1 1 0 
*
* S = D6 21 9F 97 86 90 72 9A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_1 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[4] = in[6] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[3] = in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 1 1 1 
	*	0 1 1 1 0 1 1 1 
	*	1 1 1 0 1 0 1 1 
	*	1 0 1 0 0 1 1 1 
	*	1 1 1 1 0 1 1 1 
	*	0 0 1 1 0 0 1 0 
	*	0 1 1 0 1 1 0 1 
	*	0 1 0 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 2
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 0 1 1 0 	0 1 1 0 1 0 1 1 
*	1 1 1 1 0 0 1 1 	1 1 0 0 0 0 1 1 
*	0 0 0 1 0 0 1 0 	1 1 0 0 0 0 0 1 
*	0 1 1 1 0 1 1 1 	1 0 0 1 1 0 1 1 
*	1 1 0 1 0 1 0 0 	0 1 0 0 1 1 0 0 
*	0 0 1 0 1 1 1 1 	0 0 1 1 1 0 1 1 
*	0 1 1 0 0 0 0 0 	1 0 1 1 1 0 1 1 
*	1 1 0 1 0 1 0 1 	0 0 0 0 1 0 0 1 
*
* S = F7 D6 08 9F 16 86 E8 72
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_2 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[5] = in[4] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 1 1 0 
	*	1 1 1 0 1 1 1 0 
	*	1 0 0 1 0 1 1 0 
	*	0 1 0 1 1 1 1 0 
	*	1 0 1 0 1 1 1 0 
	*	0 0 1 0 0 0 0 1 
	*	1 1 0 1 1 0 1 1 
	*	1 1 1 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 3
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 0 1 1 0 	1 1 1 0 1 0 0 1 
*	1 1 1 1 0 1 0 1 	0 1 0 0 0 0 0 1 
*	0 0 0 1 0 0 1 0 	0 1 0 0 0 0 1 1 
*	0 1 1 0 0 1 0 1 	1 0 1 1 1 0 0 1 
*	1 1 0 1 0 1 0 0 	1 1 0 0 0 1 0 0 
*	1 1 1 1 1 0 1 1 	0 0 0 1 1 0 0 1 
*	0 1 1 0 0 0 0 0 	1 0 0 1 1 0 0 1 
*	1 0 1 1 0 1 0 1 	0 0 0 0 1 0 1 1 
*
* S = F7 21 08 97 16 90 E8 9A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_3 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[5] = in[4] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 1 1 0 
	*	0 1 1 0 0 1 1 0 
	*	1 0 1 1 1 1 1 0 
	*	1 1 1 1 0 1 1 0 
	*	1 0 1 0 0 1 1 0 
	*	0 0 1 0 0 0 1 1 
	*	0 1 1 1 1 0 0 1 
	*	0 1 0 1 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 4
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 0 0 1 1 1 	0 0 0 1 0 0 1 0 
*	0 1 1 1 0 0 0 1 	1 1 1 0 1 0 1 1 
*	0 1 1 0 0 0 1 1 	1 1 1 0 1 1 0 1 
*	1 1 1 0 0 0 0 1 	0 1 0 0 0 0 1 0 
*	1 0 0 1 1 0 1 1 	0 1 1 1 1 1 1 0 
*	0 0 0 0 0 0 0 1 	1 0 1 1 0 0 1 0 
*	0 1 1 0 0 0 0 1 	0 0 1 0 0 0 1 0 
*	0 1 0 0 1 1 1 1 	0 0 0 0 0 1 0 0 
*
* S = 60 DE 29 68 8C 6E 78 64
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_4 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[5] = in[6] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[0];
	assign g_in[3] = in[7] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[2] = in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[0];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw2_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 0 0 0 
	*	1 0 0 0 1 0 0 0 
	*	0 1 0 0 0 0 0 1 
	*	1 0 1 0 1 0 0 0 
	*	1 1 1 1 1 0 0 0 
	*	0 1 1 0 1 1 0 1 
	*	0 0 1 1 0 0 1 0 
	*	0 1 0 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[3] );
	assign out[5] = ~( g_out[6] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 5
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 1 0 1 1 0 	0 0 1 1 0 0 0 1 
*	1 1 1 0 0 1 1 1 	1 0 0 1 0 1 1 0 
*	1 0 0 0 0 0 1 0 	1 0 0 1 1 0 1 1 
*	0 1 1 0 0 0 1 1 	1 1 0 0 0 0 0 1 
*	1 0 0 1 1 0 1 0 	1 1 1 0 1 0 0 1 
*	1 0 0 1 1 0 1 1 	0 1 1 0 0 0 0 1 
*	0 0 1 0 1 1 1 0 	0 0 0 1 0 0 0 1 
*	0 1 1 0 0 0 0 1 	0 0 0 0 1 1 0 0 
*
* S = BE 60 41 29 E2 8C 1C 78
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_5 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[5] = in[7] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 0 1 0 0 
	*	0 1 0 0 0 1 0 0 
	*	1 1 0 0 0 0 1 1 
	*	0 1 0 1 0 1 0 0 
	*	1 0 1 0 0 1 0 0 
	*	1 1 0 1 1 0 1 1 
	*	0 0 1 0 0 0 0 1 
	*	1 1 1 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[2] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 6
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 1 0 1 1 0 	0 0 0 1 0 0 1 1 
*	0 1 1 1 0 0 0 1 	1 0 1 1 1 1 1 0 
*	1 0 0 0 0 0 1 0 	1 0 1 1 1 0 0 1 
*	1 1 1 0 0 0 0 1 	0 1 0 0 0 0 1 1 
*	1 0 0 1 1 0 1 0 	0 1 1 0 1 0 1 1 
*	0 0 0 0 0 0 0 1 	1 1 1 0 0 0 1 1 
*	0 0 1 0 1 1 1 0 	0 0 1 1 0 0 1 1 
*	0 1 0 0 1 1 1 1 	0 0 0 0 0 1 0 0 
*
* S = BE DE 41 68 E2 6E 1C 64
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_6 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[5] = in[7] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[0];
	assign g_in[3] = in[7] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[0];
	assign g_in[1] = in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 1 0 0 
	*	1 1 0 0 1 1 0 0 
	*	0 1 0 0 0 0 0 1 
	*	1 1 1 1 1 1 0 0 
	*	1 0 1 0 1 1 0 0 
	*	0 1 1 1 1 0 0 1 
	*	0 0 1 0 0 0 1 1 
	*	0 1 0 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[5] = ~( g_out[6] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 7
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 0 0 1 0 0 	1 1 0 1 0 1 1 0 
*	1 0 0 1 0 0 0 0 	0 0 0 1 0 1 0 1 
*	1 1 1 1 0 0 1 1 	0 0 0 1 1 0 1 0 
*	1 1 1 1 0 1 0 1 	1 0 0 1 0 1 1 0 
*	1 1 1 1 1 0 1 0 	0 0 1 0 0 0 0 1 
*	0 1 0 0 1 1 1 0 	0 1 0 1 0 1 1 0 
*	0 0 1 0 1 1 1 1 	0 1 1 0 0 1 1 0 
*	1 1 1 1 1 0 1 1 	0 0 0 0 1 0 0 1 
*
* S = 49 B6 D6 21 F4 0A 86 90
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_7 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[2];
	assign g_in[6] = in[7] ^ in[4];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 1 1 0 
	*	1 1 1 0 1 1 1 0 
	*	1 0 0 1 1 1 0 1 
	*	1 0 0 0 1 1 1 0 
	*	1 1 0 0 1 1 1 0 
	*	1 1 1 1 1 0 1 0 
	*	1 0 1 1 0 1 1 0 
	*	0 1 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 8
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 0 0 	1 0 1 1 1 1 0 1 
*	1 0 0 0 0 1 0 0 	0 0 1 1 1 1 1 1 
*	0 0 0 0 0 1 1 0 	0 0 1 1 0 1 0 1 
*	1 1 1 1 0 0 1 1 	0 1 1 1 1 1 0 1 
*	1 0 1 1 0 1 0 0 	0 0 0 1 0 0 1 1 
*	1 1 1 1 1 0 1 0 	1 1 1 1 1 1 0 1 
*	1 1 0 1 0 1 0 0 	1 1 0 1 1 1 0 1 
*	0 0 1 0 1 1 1 1 	0 0 0 0 0 1 1 1 
*
* S = FF 49 F7 D6 FE F4 16 86
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_8 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2];
	assign g_in[6] = in[7] ^ in[2];
	assign g_in[5] = in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2];
	assign g_in[0] = in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 0 0 1 
	*	1 0 0 1 1 0 0 1 
	*	0 1 1 1 1 0 1 1 
	*	0 1 0 0 1 0 0 1 
	*	1 0 0 0 1 0 0 1 
	*	1 0 1 0 0 1 0 1 
	*	0 1 1 0 1 1 0 1 
	*	1 1 0 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 9
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 0 0 	1 0 0 1 0 1 1 1 
*	1 0 0 1 0 0 0 0 	0 0 0 1 0 1 0 1 
*	0 0 0 0 0 1 1 0 	0 0 0 1 1 1 1 1 
*	1 1 1 1 0 1 0 1 	1 1 0 1 0 1 1 1 
*	1 0 1 1 0 1 0 0 	0 0 1 1 0 0 0 1 
*	0 1 0 0 1 1 1 0 	0 1 0 1 0 1 1 1 
*	1 1 0 1 0 1 0 0 	0 1 1 1 0 1 1 1 
*	1 1 1 1 1 0 1 1 	0 0 0 0 1 1 0 1 
*
* S = FF B6 F7 21 FE 0A 16 90
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_9 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2];
	assign g_in[6] = in[7] ^ in[4];
	assign g_in[5] = in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 0 1 1 
	*	1 0 1 1 1 0 1 1 
	*	1 1 0 1 1 0 0 1 
	*	1 1 0 0 1 0 1 1 
	*	1 0 0 0 1 0 1 1 
	*	1 0 1 0 1 1 1 1 
	*	1 1 1 0 0 1 1 1 
	*	0 1 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 10
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 0 0 1 0 0 	1 0 0 1 1 1 1 0 
*	1 0 0 1 0 0 0 0 	0 1 0 1 0 0 0 1 
*	0 1 1 1 0 1 1 1 	0 1 0 1 0 0 1 0 
*	0 1 1 0 0 1 0 1 	1 1 0 1 1 1 1 0 
*	1 1 1 1 1 0 1 0 	1 0 1 0 0 1 0 1 
*	0 1 0 0 1 1 1 0 	0 0 0 1 1 1 1 0 
*	1 1 0 1 0 1 0 1 	1 1 1 0 1 1 1 0 
*	1 0 1 1 0 1 0 1 	0 0 0 0 1 1 0 1 
*
* S = 49 B6 9F 97 F4 0A 72 9A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_10 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[2];
	assign g_in[6] = in[7] ^ in[4];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[4] = in[6] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 1 1 0 
	*	0 1 1 0 0 1 1 0 
	*	1 1 0 1 1 0 0 1 
	*	1 0 0 0 0 1 1 0 
	*	1 1 0 0 0 1 1 0 
	*	0 0 1 1 0 0 1 0 
	*	0 1 1 1 1 1 1 0 
	*	0 1 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 11
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 0 0 	0 1 1 1 1 0 0 1 
*	1 0 0 0 0 1 0 0 	1 1 1 1 0 0 1 1 
*	0 0 0 1 0 0 1 0 	1 1 1 1 0 0 0 1 
*	0 1 1 1 0 1 1 1 	1 0 1 1 1 0 0 1 
*	1 0 1 1 0 1 0 0 	0 1 0 1 1 1 1 1 
*	1 1 1 1 1 0 1 0 	0 0 1 1 1 0 0 1 
*	0 1 1 0 0 0 0 0 	1 0 0 1 1 0 0 1 
*	1 1 0 1 0 1 0 1 	0 0 0 0 1 0 1 1 
*
* S = FF 49 08 9F FE F4 E8 72
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_11 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2];
	assign g_in[6] = in[7] ^ in[2];
	assign g_in[5] = in[4] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[6] ^ in[5];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 1 0 1 
	*	1 1 0 1 1 1 0 1 
	*	1 0 1 1 0 1 1 1 
	*	0 1 0 0 1 1 0 1 
	*	1 0 0 0 1 1 0 1 
	*	0 0 1 0 0 0 0 1 
	*	1 1 1 0 1 0 0 1 
	*	1 1 0 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 12
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 0 0 	1 1 0 1 1 0 1 1 
*	1 0 0 1 0 0 0 0 	0 1 0 1 0 0 0 1 
*	0 0 0 1 0 0 1 0 	0 1 0 1 0 0 1 1 
*	0 1 1 0 0 1 0 1 	1 0 0 1 1 0 1 1 
*	1 0 1 1 0 1 0 0 	1 1 1 1 0 1 0 1 
*	0 1 0 0 1 1 1 0 	0 0 0 1 1 0 1 1 
*	0 1 1 0 0 0 0 0 	1 0 1 1 1 0 1 1 
*	1 0 1 1 0 1 0 1 	0 0 0 0 1 0 0 1 
*
* S = FF B6 08 97 FE 0A E8 9A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_12 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2];
	assign g_in[6] = in[7] ^ in[4];
	assign g_in[5] = in[4] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 1 1 1 
	*	0 1 1 1 0 1 1 1 
	*	1 0 0 1 1 1 0 1 
	*	1 1 0 0 0 1 1 1 
	*	1 0 0 0 0 1 1 1 
	*	0 0 1 0 0 0 1 1 
	*	0 1 1 0 1 0 1 1 
	*	0 1 0 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 13
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 0 0 1 0 0 	0 1 0 1 1 0 1 0 
*	1 0 0 1 0 0 0 0 	1 0 0 1 1 1 0 1 
*	1 1 1 0 0 1 1 1 	1 0 0 1 0 1 1 0 
*	0 1 1 1 0 0 0 1 	0 0 0 1 1 0 1 0 
*	1 1 1 1 1 0 1 0 	1 1 1 0 1 0 0 1 
*	0 1 0 0 1 1 1 0 	1 1 0 1 1 0 1 0 
*	1 0 0 1 1 0 1 1 	1 0 1 0 1 0 1 0 
*	0 0 0 0 0 0 0 1 	0 0 0 0 0 0 0 1 
*
* S = 49 B6 60 DE F4 0A 8C 6E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_13 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[2];
	assign g_in[6] = in[7] ^ in[4];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 0 1 0 
	*	0 0 1 0 0 0 1 0 
	*	0 0 0 1 0 1 0 1 
	*	1 0 0 0 0 0 1 0 
	*	1 1 0 0 0 0 1 0 
	*	1 0 1 1 0 1 1 0 
	*	1 1 1 1 1 0 1 0 
	*	0 1 0 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[1];
	assign out[6] = ~( g_out[5] ^ g_out[1] );
	assign out[5] = ~( g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 14
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 0 0 	1 1 1 1 0 1 0 1 
*	1 0 0 0 0 1 0 0 	0 1 1 1 1 0 1 1 
*	1 0 0 1 0 1 1 0 	0 1 1 1 1 1 0 1 
*	1 1 1 0 0 1 1 1 	0 0 1 1 0 1 0 1 
*	1 0 1 1 0 1 0 0 	1 0 0 1 0 1 1 1 
*	1 1 1 1 1 0 1 0 	1 0 1 1 0 1 0 1 
*	1 0 0 1 1 0 1 0 	0 1 0 1 0 1 0 1 
*	1 0 0 1 1 0 1 1 	0 0 0 0 0 0 1 1 
*
* S = FF 49 BE 60 FE F4 E2 8C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_14 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2];
	assign g_in[6] = in[7] ^ in[2];
	assign g_in[5] = in[7] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 0 0 0 1 
	*	0 0 0 1 0 0 0 1 
	*	0 0 1 1 1 1 1 1 
	*	0 1 0 0 0 0 0 1 
	*	1 0 0 0 0 0 0 1 
	*	0 1 1 0 1 1 0 1 
	*	1 0 1 0 0 1 0 1 
	*	1 1 0 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[6] = ~( g_out[4] ^ g_out[0] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 15
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 0 0 	0 1 0 1 1 1 1 1 
*	1 0 0 1 0 0 0 0 	1 1 0 1 1 0 0 1 
*	1 0 0 1 0 1 1 0 	1 1 0 1 0 1 1 1 
*	0 1 1 1 0 0 0 1 	0 0 0 1 1 1 1 1 
*	1 0 1 1 0 1 0 0 	1 0 1 1 1 1 0 1 
*	0 1 0 0 1 1 1 0 	1 0 0 1 1 1 1 1 
*	1 0 0 1 1 0 1 0 	1 1 1 1 1 1 1 1 
*	0 0 0 0 0 0 0 1 	0 0 0 0 0 0 0 1 
*
* S = FF B6 BE DE FE 0A E2 6E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_15 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2];
	assign g_in[6] = in[7] ^ in[4];
	assign g_in[5] = in[7] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 0 1 1 
	*	0 0 1 1 0 0 1 1 
	*	0 0 0 1 0 1 0 1 
	*	1 1 0 0 0 0 1 1 
	*	1 0 0 0 0 0 1 1 
	*	1 1 1 0 0 1 1 1 
	*	1 0 1 0 1 1 1 1 
	*	0 1 0 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 16
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 0 0 1 0 0 	0 0 0 1 0 0 1 0 
*	1 0 0 1 0 0 0 0 	1 1 0 1 1 0 0 1 
*	0 1 1 0 0 0 1 1 	1 1 0 1 1 1 1 0 
*	1 1 1 0 0 0 0 1 	0 1 0 1 0 0 1 0 
*	1 1 1 1 1 0 1 0 	0 1 1 0 1 1 0 1 
*	0 1 0 0 1 1 1 0 	1 0 0 1 0 0 1 0 
*	0 1 1 0 0 0 0 1 	0 0 1 0 0 0 1 0 
*	0 1 0 0 1 1 1 1 	0 0 0 0 0 1 0 1 
*
* S = 49 B6 29 68 F4 0A 78 64
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_16 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[2];
	assign g_in[6] = in[7] ^ in[4];
	assign g_in[5] = in[6] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[0];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 0 1 0 
	*	1 0 1 0 1 0 1 0 
	*	0 1 0 1 0 0 0 1 
	*	1 0 0 0 1 0 1 0 
	*	1 1 0 0 1 0 1 0 
	*	0 1 1 1 1 1 1 0 
	*	0 0 1 1 0 0 1 0 
	*	0 1 0 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 17
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 0 0 	0 0 1 1 0 0 0 1 
*	1 0 0 0 0 1 0 0 	1 0 1 1 0 1 1 1 
*	1 0 0 0 0 0 1 0 	1 0 1 1 1 0 0 1 
*	0 1 1 0 0 0 1 1 	1 1 1 1 0 0 0 1 
*	1 0 1 1 0 1 0 0 	1 1 0 1 1 0 1 1 
*	1 1 1 1 1 0 1 0 	0 1 1 1 0 0 0 1 
*	0 0 1 0 1 1 1 0 	0 0 0 1 0 0 0 1 
*	0 1 1 0 0 0 0 1 	0 0 0 0 1 1 1 1 
*
* S = FF 49 41 29 FE F4 1C 78
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_17 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2];
	assign g_in[6] = in[7] ^ in[2];
	assign g_in[5] = in[7] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 0 1 0 1 
	*	0 1 0 1 0 1 0 1 
	*	1 1 1 1 0 0 1 1 
	*	0 1 0 0 0 1 0 1 
	*	1 0 0 0 0 1 0 1 
	*	1 1 1 0 1 0 0 1 
	*	0 0 1 0 0 0 0 1 
	*	1 1 0 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 18
*
* GF(2^8) Norm Basis: [d^16, d^1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 0 0 	0 0 0 1 0 0 1 1 
*	1 0 0 1 0 0 0 0 	1 0 0 1 1 1 0 1 
*	1 0 0 0 0 0 1 0 	1 0 0 1 1 0 1 1 
*	1 1 1 0 0 0 0 1 	0 1 0 1 0 0 1 1 
*	1 0 1 1 0 1 0 0 	0 1 1 1 1 0 0 1 
*	0 1 0 0 1 1 1 0 	1 1 0 1 0 0 1 1 
*	0 0 1 0 1 1 1 0 	0 0 1 1 0 0 1 1 
*	0 1 0 0 1 1 1 1 	0 0 0 0 0 1 0 1 
*
* S = FF B6 41 68 FE 0A 1C 64
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_18 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2];
	assign g_in[6] = in[7] ^ in[4];
	assign g_in[5] = in[7] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 1 1 1 
	*	1 1 1 1 1 1 1 1 
	*	0 1 0 1 0 0 0 1 
	*	1 1 0 0 1 1 1 1 
	*	1 0 0 0 1 1 1 1 
	*	0 1 1 0 1 0 1 1 
	*	0 0 1 0 0 0 1 1 
	*	0 1 0 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 19
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 0 0 1 1 	1 1 1 1 1 0 0 1 
*	1 0 0 0 0 1 1 1 	1 0 0 1 1 1 0 0 
*	0 0 0 0 1 0 1 1 	0 0 0 0 0 1 1 0 
*	0 0 0 1 0 1 0 1 	0 1 1 1 0 1 0 0 
*	1 1 1 1 1 1 1 1 	1 0 1 0 0 1 1 0 
*	1 0 0 0 1 0 0 1 	0 0 1 1 1 1 1 1 
*	1 0 1 0 1 0 0 1 	1 1 0 1 1 1 0 1 
*	1 1 0 0 0 1 0 1 	0 1 0 1 1 0 1 1 
*
* S = 87 2D 7E C7 D7 9C 93 CA
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_19 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[1] ^ in[0];
	assign g_in[6] = in[7] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[5] = in[3] ^ in[1] ^ in[0];
	assign g_in[4] = in[4] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[7] ^ in[3] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 0 0 1 
	*	0 1 1 1 0 1 1 1 
	*	0 0 1 1 0 1 1 0 
	*	0 1 1 0 1 0 1 1 
	*	1 1 1 0 0 1 1 0 
	*	1 1 0 1 1 1 0 0 
	*	1 1 1 0 0 1 0 1 
	*	0 1 0 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 20
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 1 0 0 	1 0 1 0 0 1 1 1 
*	0 0 1 0 0 0 1 1 	0 1 1 1 1 0 0 0 
*	0 0 0 1 1 1 1 0 	0 0 0 0 1 1 0 1 
*	0 0 0 0 1 0 1 1 	1 1 1 0 1 1 0 0 
*	0 1 1 1 0 1 1 0 	0 1 0 1 1 1 0 1 
*	1 1 1 1 1 1 1 1 	0 0 1 0 1 0 1 0 
*	0 1 1 0 1 1 0 0 	1 0 1 1 1 0 1 1 
*	1 0 1 0 1 0 0 1 	1 1 1 1 0 1 1 0 
*
* S = AA 87 B9 7E 4B D7 59 93
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_20 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5] ^ in[2];
	assign g_in[6] = in[5] ^ in[1] ^ in[0];
	assign g_in[5] = in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 0 0 1 1 
	*	1 1 1 0 1 1 1 0 
	*	0 0 1 0 1 1 0 1 
	*	1 1 0 1 0 1 1 0 
	*	1 0 0 1 1 1 0 1 
	*	1 0 1 1 1 0 0 0 
	*	1 0 0 1 1 1 1 1 
	*	1 1 0 0 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 21
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 1 0 0 	1 0 1 0 1 1 0 1 
*	1 0 0 0 0 1 1 1 	1 1 0 1 1 0 0 0 
*	0 0 0 1 1 1 1 0 	0 0 0 0 0 1 1 1 
*	0 0 0 1 0 1 0 1 	0 1 1 0 0 1 0 0 
*	0 1 1 1 0 1 1 0 	1 1 1 1 0 1 1 1 
*	1 0 0 0 1 0 0 1 	0 0 1 0 1 0 1 0 
*	0 1 1 0 1 1 0 0 	1 0 0 1 1 0 0 1 
*	1 1 0 0 0 1 0 1 	0 1 0 1 1 1 1 0 
*
* S = AA 2D B9 C7 4B 9C 59 CA
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_21 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5] ^ in[2];
	assign g_in[6] = in[7] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[5] = in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[4] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[3] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 0 0 1 
	*	0 1 1 0 0 1 1 0 
	*	0 0 1 0 0 1 1 1 
	*	0 1 1 1 1 1 1 0 
	*	1 0 1 1 0 1 1 1 
	*	1 0 0 1 1 0 0 0 
	*	1 0 1 1 0 1 0 1 
	*	0 1 0 0 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 22
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 1 1 0 0 1 	1 1 1 1 1 1 0 0 
*	1 0 1 0 1 1 1 1 	1 1 0 0 1 0 0 1 
*	1 0 1 1 0 0 0 1 	0 0 0 0 0 0 1 1 
*	0 0 1 1 1 1 0 1 	1 0 0 0 1 1 1 0 
*	1 1 1 0 0 1 0 1 	1 0 1 0 0 0 1 1 
*	1 1 0 1 1 1 1 1 	0 1 1 0 1 1 1 1 
*	1 0 1 1 0 0 1 1 	0 0 1 0 0 0 1 0 
*	1 0 0 1 0 0 1 1 	0 1 0 1 0 0 0 1 
*
* S = 6D 3E 94 D4 81 8E C5 D8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_22 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[6] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[4] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 0 1 1 
	*	1 0 0 0 1 0 0 0 
	*	0 1 1 0 0 0 1 1 
	*	0 0 1 1 0 0 0 1 
	*	0 1 0 0 0 0 1 1 
	*	0 0 1 0 1 0 0 1 
	*	0 1 0 0 0 1 0 1 
	*	1 1 1 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[3] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 23
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 1 0 1 1 0 	1 0 1 0 1 0 0 0 
*	1 0 0 1 1 0 0 1 	1 0 0 0 0 1 1 1 
*	1 0 0 0 1 1 0 0 	0 0 0 0 0 0 1 0 
*	1 0 1 1 0 0 0 1 	0 1 0 0 1 0 0 1 
*	0 0 1 1 1 0 1 0 	0 1 0 1 0 0 1 0 
*	1 1 1 0 0 1 0 1 	1 1 0 1 1 0 1 0 
*	0 0 1 0 0 0 0 0 	0 0 0 1 0 0 0 1 
*	1 0 1 1 0 0 1 1 	1 1 1 1 0 0 1 1 
*
* S = 53 6D 40 94 0F 81 1D C5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_23 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[5] = in[7] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[3] = in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[1] = in[5];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 0 1 1 0 
	*	0 1 0 0 0 1 0 0 
	*	1 1 0 1 0 0 1 0 
	*	0 0 1 0 0 0 1 1 
	*	1 1 0 0 0 0 1 0 
	*	0 0 0 1 0 1 1 1 
	*	1 1 0 0 1 1 1 1 
	*	1 0 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[2] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] );
	assign out[4] = g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[1];
	assign out[2] = g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 24
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 1 0 1 1 0 	1 0 1 0 1 0 0 0 
*	1 0 1 0 1 1 1 1 	1 0 0 0 1 1 0 1 
*	1 0 0 0 1 1 0 0 	0 0 0 0 0 0 1 0 
*	0 0 1 1 1 1 0 1 	1 1 0 0 1 0 1 1 
*	0 0 1 1 1 0 1 0 	1 1 1 1 0 0 1 0 
*	1 1 0 1 1 1 1 1 	0 1 1 1 1 0 1 0 
*	0 0 1 0 0 0 0 0 	0 0 1 1 0 0 1 1 
*	1 0 0 1 0 0 1 1 	0 1 0 1 0 0 0 1 
*
* S = 53 3E 40 D4 0F 8E 1D D8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_24 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[5] = in[7] ^ in[3] ^ in[2];
	assign g_in[4] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[5];
	assign g_in[0] = in[7] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 1 1 0 
	*	1 1 0 0 1 1 0 0 
	*	0 1 1 1 0 0 1 0 
	*	0 0 1 0 0 0 0 1 
	*	0 1 0 0 0 0 1 0 
	*	0 0 1 1 1 1 0 1 
	*	0 1 0 0 0 1 0 1 
	*	1 0 1 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] );
	assign out[4] = g_out[5] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 25
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 1 0 0 0 	1 1 0 0 0 1 1 1 
*	1 0 0 1 0 0 1 0 	0 1 1 1 0 0 1 1 
*	0 0 1 0 0 0 1 1 	0 0 0 0 1 0 1 1 
*	1 0 0 0 0 1 1 1 	1 1 1 0 0 0 0 1 
*	0 1 0 1 0 1 1 0 	1 0 0 0 1 0 1 1 
*	0 1 0 0 1 1 0 0 	1 1 1 1 1 1 0 0 
*	1 1 1 1 1 1 1 1 	0 1 1 0 0 1 1 0 
*	1 0 0 0 1 0 0 1 	0 1 0 0 1 1 0 1 
*
* S = F9 EA 87 2D 44 56 D7 9C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_25 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[3];
	assign g_in[6] = in[7] ^ in[4] ^ in[1];
	assign g_in[5] = in[5] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 1 0 1 
	*	1 1 1 0 1 1 1 0 
	*	1 1 1 1 1 0 1 1 
	*	1 0 1 1 1 1 0 1 
	*	1 0 0 1 1 0 1 1 
	*	0 1 1 0 0 0 1 1 
	*	1 0 0 1 0 1 0 0 
	*	0 0 0 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[2] );
	assign out[0] = ~( g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 26
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 1 1 0 1 0 	1 0 0 0 1 1 1 0 
*	0 0 1 0 1 0 0 0 	1 1 1 0 0 0 1 0 
*	1 0 1 0 0 1 0 0 	0 0 0 0 0 1 1 0 
*	0 0 1 0 0 0 1 1 	1 0 0 1 0 0 1 1 
*	0 0 0 1 1 0 1 0 	0 1 0 0 0 1 1 0 
*	0 1 0 1 0 1 1 0 	1 0 1 0 1 0 0 0 
*	0 1 1 1 0 1 1 0 	1 1 0 1 1 1 0 1 
*	1 1 1 1 1 1 1 1 	1 1 0 0 1 0 1 1 
*
* S = 13 F9 AA 87 12 44 4B D7
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_26 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[3];
	assign g_in[5] = in[7] ^ in[5] ^ in[2];
	assign g_in[4] = in[5] ^ in[1] ^ in[0];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 1 1 1 
	*	1 0 0 1 1 0 0 1 
	*	1 0 1 0 0 1 1 0 
	*	0 1 1 0 1 0 1 1 
	*	0 1 1 1 0 1 1 0 
	*	1 1 0 1 0 0 1 0 
	*	0 1 1 1 1 1 0 0 
	*	0 0 1 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 27
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 1 1 0 1 0 	1 0 0 0 0 1 1 0 
*	1 0 0 1 0 0 1 0 	0 1 1 0 0 0 1 0 
*	1 0 1 0 0 1 0 0 	0 0 0 0 1 1 1 0 
*	1 0 0 0 0 1 1 1 	1 0 1 1 0 0 0 1 
*	0 0 0 1 1 0 1 0 	1 1 0 0 1 1 1 0 
*	0 1 0 0 1 1 0 0 	1 0 1 0 1 0 0 0 
*	0 1 1 1 0 1 1 0 	0 1 1 1 0 1 1 1 
*	1 0 0 0 1 0 0 1 	0 1 0 0 1 0 0 1 
*
* S = 13 EA AA 2D 12 56 4B 9C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_27 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[4] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[2];
	assign g_in[4] = in[7] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 1 0 1 
	*	1 0 1 1 1 0 1 1 
	*	1 0 1 0 1 1 1 0 
	*	1 1 1 0 1 0 0 1 
	*	1 1 0 1 1 1 1 0 
	*	0 1 1 1 0 0 1 0 
	*	1 1 0 1 0 1 0 0 
	*	0 0 0 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[0] = ~( g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 28
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 1 0 0 0 	1 1 0 0 1 0 1 1 
*	1 0 0 1 0 0 1 0 	1 0 1 1 1 1 1 1 
*	0 0 0 0 1 0 1 1 	0 0 0 0 0 1 1 1 
*	0 0 0 1 0 1 0 1 	0 1 1 0 0 1 0 1 
*	0 1 0 1 0 1 1 0 	1 0 0 0 0 1 1 1 
*	0 1 0 0 1 1 0 0 	0 0 1 1 1 1 0 0 
*	1 0 1 0 1 0 0 1 	1 1 1 0 1 1 1 0 
*	1 1 0 0 0 1 0 1 	0 1 0 0 1 0 0 1 
*
* S = F9 EA 7E C7 44 56 93 CA
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_28 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[3];
	assign g_in[6] = in[7] ^ in[4] ^ in[1];
	assign g_in[5] = in[3] ^ in[1] ^ in[0];
	assign g_in[4] = in[4] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 0 0 1 
	*	0 1 1 0 0 1 1 0 
	*	0 0 1 1 0 1 1 1 
	*	0 1 1 1 1 0 0 1 
	*	1 1 0 1 0 1 1 1 
	*	1 1 1 0 1 1 1 1 
	*	1 1 0 1 0 1 0 0 
	*	0 1 0 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 29
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 1 1 0 1 0 	1 0 0 0 0 1 1 0 
*	0 0 1 0 1 0 0 0 	0 1 1 0 1 0 1 0 
*	0 0 0 1 1 1 1 0 	0 0 0 0 1 1 1 0 
*	0 0 0 0 1 0 1 1 	1 1 0 1 1 1 1 1 
*	0 0 0 1 1 0 1 0 	0 1 0 0 1 1 1 0 
*	0 1 0 1 0 1 1 0 	0 0 1 0 1 0 0 0 
*	0 1 1 0 1 1 0 0 	1 0 0 1 1 0 0 1 
*	1 0 1 0 1 0 0 1 	1 1 0 0 0 1 1 1 
*
* S = 13 F9 B9 7E 12 44 59 93
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_29 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[3];
	assign g_in[5] = in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 0 0 1 1 
	*	1 1 0 1 1 1 0 1 
	*	0 0 1 0 1 1 1 0 
	*	1 1 1 0 0 1 1 1 
	*	1 0 1 1 1 1 1 0 
	*	1 0 0 1 1 0 1 0 
	*	1 0 1 1 1 1 0 0 
	*	1 1 1 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 30
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 1 1 0 1 0 	1 0 0 0 1 1 1 0 
*	1 0 0 1 0 0 1 0 	1 1 1 0 1 0 1 0 
*	0 0 0 1 1 1 1 0 	0 0 0 0 0 1 1 0 
*	0 0 0 1 0 1 0 1 	0 1 1 1 0 1 0 1 
*	0 0 0 1 1 0 1 0 	1 1 0 0 0 1 1 0 
*	0 1 0 0 1 1 0 0 	0 0 1 0 1 0 0 0 
*	0 1 1 0 1 1 0 0 	1 0 1 1 1 0 1 1 
*	1 1 0 0 0 1 0 1 	0 1 0 0 1 1 0 1 
*
* S = 13 EA B9 C7 12 56 59 CA
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_30 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[4] ^ in[1];
	assign g_in[5] = in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[4] ^ in[2] ^ in[0];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 0 0 1 
	*	0 1 1 1 0 1 1 1 
	*	0 0 1 0 0 1 1 0 
	*	0 1 1 0 1 1 0 1 
	*	1 0 0 1 0 1 1 0 
	*	1 0 1 1 1 0 1 0 
	*	1 0 0 1 0 1 0 0 
	*	0 1 0 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[2] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 31
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 1 0 0 0 	1 1 0 0 0 0 1 1 
*	1 0 0 1 0 0 1 0 	0 0 1 1 0 1 1 1 
*	1 0 0 1 1 0 0 1 	0 0 0 0 1 1 1 1 
*	1 0 1 0 1 1 1 1 	0 0 1 0 1 0 0 1 
*	0 1 0 1 0 1 1 0 	1 0 0 0 1 1 1 1 
*	0 1 0 0 1 1 0 0 	1 0 1 1 1 1 0 0 
*	1 1 1 0 0 1 0 1 	1 0 1 0 1 0 1 0 
*	1 1 0 1 1 1 1 1 	0 1 0 0 0 1 0 1 
*
* S = F9 EA 6D 3E 44 56 81 8E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_31 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[3];
	assign g_in[6] = in[7] ^ in[4] ^ in[1];
	assign g_in[5] = in[7] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 1 0 1 
	*	0 0 1 0 0 0 1 0 
	*	1 0 1 1 1 1 1 1 
	*	1 1 1 1 0 1 0 1 
	*	0 0 0 1 1 1 1 1 
	*	1 0 1 0 0 1 1 1 
	*	0 0 0 1 0 1 0 0 
	*	1 0 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[5] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[2] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 32
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 1 1 0 1 0 	1 0 0 0 0 0 1 0 
*	0 0 1 0 1 0 0 0 	0 0 1 0 1 1 1 0 
*	0 0 1 1 0 1 1 0 	0 0 0 0 1 0 1 0 
*	1 0 0 1 1 0 0 1 	0 0 0 1 0 1 1 1 
*	0 0 0 1 1 0 1 0 	0 1 0 0 1 0 1 0 
*	0 1 0 1 0 1 1 0 	0 1 1 0 1 0 0 0 
*	0 0 1 1 1 0 1 0 	0 1 0 1 0 1 0 1 
*	1 1 1 0 0 1 0 1 	1 1 0 0 1 1 1 1 
*
* S = 13 F9 53 6D 12 44 0F 81
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_32 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[3];
	assign g_in[5] = in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 0 1 1 
	*	0 0 0 1 0 0 0 1 
	*	0 1 1 0 1 0 1 0 
	*	1 0 1 0 1 1 1 1 
	*	0 0 1 1 1 0 1 0 
	*	0 1 0 1 1 1 1 0 
	*	0 0 1 1 1 1 0 0 
	*	0 1 1 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[4] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 33
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 1 1 0 1 0 	1 0 0 0 0 0 1 0 
*	1 0 0 1 0 0 1 0 	0 0 1 0 0 1 1 0 
*	0 0 1 1 0 1 1 0 	0 0 0 0 1 0 1 0 
*	1 0 1 0 1 1 1 1 	0 0 1 1 1 1 0 1 
*	0 0 0 1 1 0 1 0 	1 1 0 0 1 0 1 0 
*	0 1 0 0 1 1 0 0 	1 1 1 0 1 0 0 0 
*	0 0 1 1 1 0 1 0 	1 1 1 1 1 1 1 1 
*	1 1 0 1 1 1 1 1 	0 1 0 0 0 1 0 1 
*
* S = 13 EA 53 3E 12 56 0F 8E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_33 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[4] ^ in[1];
	assign g_in[5] = in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 0 0 1 
	*	0 0 1 1 0 0 1 1 
	*	1 1 1 0 1 0 1 0 
	*	1 0 1 0 0 1 0 1 
	*	0 0 0 1 1 0 1 0 
	*	1 1 1 1 0 1 1 0 
	*	0 0 0 1 0 1 0 0 
	*	1 1 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[6] = ~( g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[4] ^ g_out[2] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 34
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 1 0 0 0 	1 1 0 0 1 1 1 1 
*	1 0 0 1 0 0 1 0 	1 1 1 1 1 0 1 1 
*	1 0 1 1 0 0 0 1 	0 0 0 0 0 0 1 1 
*	0 0 1 1 1 1 0 1 	1 0 1 0 1 1 0 1 
*	0 1 0 1 0 1 1 0 	1 0 0 0 0 0 1 1 
*	0 1 0 0 1 1 0 0 	0 1 1 1 1 1 0 0 
*	1 0 1 1 0 0 1 1 	0 0 1 0 0 0 1 0 
*	1 0 0 1 0 0 1 1 	0 1 0 0 0 0 0 1 
*
* S = F9 EA 94 D4 44 56 C5 D8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_34 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[3];
	assign g_in[6] = in[7] ^ in[4] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[4] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 0 0 1 
	*	1 0 1 0 1 0 1 0 
	*	0 1 1 1 0 0 1 1 
	*	0 0 1 1 0 0 0 1 
	*	0 1 0 1 0 0 1 1 
	*	0 0 1 0 1 0 1 1 
	*	0 1 0 1 0 1 0 0 
	*	1 1 0 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 35
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 1 1 0 1 0 	1 0 0 0 1 0 1 0 
*	0 0 1 0 1 0 0 0 	1 0 1 0 0 1 1 0 
*	1 0 0 0 1 1 0 0 	0 0 0 0 0 0 1 0 
*	1 0 1 1 0 0 0 1 	0 1 0 1 1 0 1 1 
*	0 0 0 1 1 0 1 0 	0 1 0 0 0 0 1 0 
*	0 1 0 1 0 1 1 0 	1 1 1 0 1 0 0 0 
*	0 0 1 0 0 0 0 0 	0 0 0 1 0 0 0 1 
*	1 0 1 1 0 0 1 1 	1 1 0 0 0 0 1 1 
*
* S = 13 F9 40 94 12 44 1D C5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_35 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[3];
	assign g_in[5] = in[7] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[5];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 0 1 1 1 
	*	0 1 0 1 0 1 0 1 
	*	1 1 1 0 0 0 1 0 
	*	0 0 1 0 0 0 1 1 
	*	1 1 1 1 0 0 1 0 
	*	0 0 0 1 0 1 1 0 
	*	1 1 1 1 1 1 0 0 
	*	1 0 1 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] );
	assign out[4] = g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 36
*
* GF(2^8) Norm Basis: [d^32, d^2]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 1 1 0 1 0 	1 0 0 0 1 0 1 0 
*	1 0 0 1 0 0 1 0 	1 0 1 0 1 1 1 0 
*	1 0 0 0 1 1 0 0 	0 0 0 0 0 0 1 0 
*	0 0 1 1 1 1 0 1 	1 1 1 1 1 0 0 1 
*	0 0 0 1 1 0 1 0 	1 1 0 0 0 0 1 0 
*	0 1 0 0 1 1 0 0 	0 1 1 0 1 0 0 0 
*	0 0 1 0 0 0 0 0 	0 0 1 1 0 0 1 1 
*	1 0 0 1 0 0 1 1 	0 1 0 0 0 0 0 1 
*
* S = 13 EA 40 D4 12 56 1D D8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_36 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[4] ^ in[1];
	assign g_in[5] = in[7] ^ in[3] ^ in[2];
	assign g_in[4] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[5];
	assign g_in[0] = in[7] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 1 0 1 
	*	1 1 1 1 1 1 1 1 
	*	0 1 1 0 0 0 1 0 
	*	0 0 1 0 0 0 0 1 
	*	0 1 0 1 0 0 1 0 
	*	0 0 1 1 1 1 1 0 
	*	0 1 0 1 0 1 0 0 
	*	1 0 0 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[1] );
	assign out[4] = g_out[5] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 37
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 0 1 0 0 1 1 	1 1 0 0 1 0 1 0 
*	1 0 0 0 1 0 1 1 	0 1 0 1 0 0 0 0 
*	0 1 1 1 0 1 0 1 	0 0 1 1 0 1 0 1 
*	1 1 0 0 1 0 1 1 	1 0 0 0 1 0 1 1 
*	1 0 0 0 1 1 1 1 	1 1 0 1 0 0 0 1 
*	1 0 0 0 0 1 0 1 	0 1 0 0 1 0 0 0 
*	1 1 0 1 0 1 1 1 	1 1 0 1 1 1 0 1 
*	0 0 0 1 1 0 1 1 	1 0 0 0 0 1 1 0 
*
* S = 3A 91 23 96 6A 20 CE 9B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_37 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[6] = in[7] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[7] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 1 0 1 
	*	0 1 1 1 0 1 1 1 
	*	1 1 1 1 1 0 1 0 
	*	0 1 0 0 1 0 0 1 
	*	0 0 0 0 1 0 0 0 
	*	1 0 0 0 1 0 0 1 
	*	1 1 1 1 0 1 0 0 
	*	1 0 1 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[3];
	assign out[2] = g_out[7] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 38
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 0 0 0 	1 0 0 0 0 1 0 1 
*	0 1 0 1 0 0 1 1 	1 1 1 1 0 0 0 0 
*	1 0 1 1 1 1 1 0 	0 0 1 0 1 1 1 1 
*	0 1 1 1 0 1 0 1 	0 1 0 0 0 1 1 0 
*	0 0 0 0 1 0 1 0 	1 0 1 1 0 0 1 1 
*	1 0 0 0 1 1 1 1 	1 1 0 0 0 1 0 0 
*	1 1 0 0 1 1 0 0 	1 0 1 1 1 0 1 1 
*	1 1 0 1 0 1 1 1 	0 1 0 0 1 1 0 1 
*
* S = AB 3A B5 23 4A 6A 55 CE
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_38 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3];
	assign g_in[6] = in[6] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[3] = in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 1 1 1 
	*	1 1 1 0 1 1 1 0 
	*	1 0 1 0 0 1 0 1 
	*	1 1 0 0 0 1 1 1 
	*	0 0 0 0 0 1 0 0 
	*	0 1 0 0 0 1 1 1 
	*	1 0 1 0 1 1 0 0 
	*	0 1 0 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[2];
	assign out[2] = g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 39
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 0 0 0 	1 0 0 0 1 1 1 1 
*	1 0 0 0 1 0 1 1 	0 1 0 1 0 0 0 0 
*	1 0 1 1 1 1 1 0 	0 0 1 0 0 1 0 1 
*	1 1 0 0 1 0 1 1 	1 1 0 0 1 1 1 0 
*	0 0 0 0 1 0 1 0 	1 0 0 1 0 0 0 1 
*	1 0 0 0 0 1 0 1 	0 1 0 0 1 1 0 0 
*	1 1 0 0 1 1 0 0 	1 0 0 1 1 0 0 1 
*	0 0 0 1 1 0 1 1 	1 1 0 0 0 1 1 1 
*
* S = AB 91 B5 96 4A 20 55 9B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_39 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2];
	assign g_in[0] = in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 1 0 1 
	*	0 1 1 0 0 1 1 0 
	*	1 0 1 0 1 1 1 1 
	*	0 1 0 0 1 1 0 1 
	*	0 0 0 0 1 1 0 0 
	*	1 1 0 0 1 1 0 1 
	*	1 0 1 0 0 1 0 0 
	*	1 1 1 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[2] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 40
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 1 0 1 0 1 	1 0 0 1 1 0 1 0 
*	1 0 1 0 1 1 0 1 	0 1 0 1 0 0 0 0 
*	0 0 0 1 0 0 1 1 	0 1 1 0 0 1 0 1 
*	1 1 1 0 1 1 0 1 	0 1 1 1 0 0 0 1 
*	0 1 0 0 1 0 0 1 	0 0 1 0 1 0 1 1 
*	1 1 0 1 1 1 0 1 	1 1 1 0 0 1 1 1 
*	0 0 0 1 0 0 0 1 	0 0 1 0 0 0 1 0 
*	0 1 0 0 0 0 1 1 	0 1 1 1 0 0 1 1 
*
* S = 3D 8F 24 88 D1 3F 75 84
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_40 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[6] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[5] = in[4] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[3] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[4] ^ in[0];
	assign g_in[0] = in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 1 0 1 
	*	1 0 0 0 1 0 0 0 
	*	1 1 1 1 1 0 1 0 
	*	1 1 1 0 1 1 0 0 
	*	0 0 0 0 0 1 1 1 
	*	0 1 1 1 1 1 0 0 
	*	1 1 1 1 1 1 1 0 
	*	1 0 1 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[3] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[3] = g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 41
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 1 1 0 0 0 	0 1 1 1 0 1 0 1 
*	0 0 1 1 0 1 0 1 	1 1 1 1 0 0 0 0 
*	1 1 1 1 1 1 1 0 	1 1 0 1 1 1 1 1 
*	0 0 0 1 0 0 1 1 	1 1 1 0 0 0 1 1 
*	1 0 0 1 0 1 0 0 	0 0 0 1 0 1 1 0 
*	0 1 0 0 1 0 0 1 	1 0 0 1 1 1 1 0 
*	0 1 0 1 0 0 1 0 	0 0 0 1 0 0 0 1 
*	0 0 0 1 0 0 0 1 	1 1 1 0 0 0 1 0 
*
* S = B2 3D AC 24 EE D1 F1 75
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_41 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[4] ^ in[3];
	assign g_in[6] = in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[4] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[4] ^ in[2];
	assign g_in[2] = in[6] ^ in[3] ^ in[0];
	assign g_in[1] = in[6] ^ in[4] ^ in[1];
	assign g_in[0] = in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 1 1 1 
	*	0 1 0 0 0 1 0 0 
	*	1 0 1 0 0 1 0 1 
	*	1 0 0 1 1 0 0 0 
	*	0 0 0 0 1 1 1 0 
	*	1 1 1 0 1 0 0 0 
	*	1 0 1 0 1 0 0 1 
	*	0 1 0 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[2] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3];
	assign out[3] = g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 42
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 1 1 0 0 0 	1 1 0 1 1 1 1 1 
*	1 0 1 0 1 1 0 1 	0 1 0 1 0 0 0 0 
*	1 1 1 1 1 1 1 0 	0 1 1 1 0 1 0 1 
*	1 1 1 0 1 1 0 1 	0 1 1 0 0 0 0 1 
*	1 0 0 1 0 1 0 0 	0 0 1 1 1 1 1 0 
*	1 1 0 1 1 1 0 1 	1 0 1 1 0 1 1 0 
*	0 1 0 1 0 0 1 0 	0 0 1 1 0 0 1 1 
*	0 1 0 0 0 0 1 1 	0 1 1 0 0 0 1 0 
*
* S = B2 8F AC 88 EE 3F F1 84
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_42 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[6] ^ in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 1 0 1 
	*	1 1 0 0 1 1 0 0 
	*	1 0 1 0 1 1 1 1 
	*	1 0 1 1 1 0 0 0 
	*	0 0 0 0 0 1 1 0 
	*	0 1 1 0 1 0 0 0 
	*	1 0 1 0 1 0 1 1 
	*	1 1 1 1 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[3] = g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 43
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 0 1 1 0 	0 0 1 1 1 0 0 0 
*	0 1 0 0 0 0 0 0 	0 1 0 0 0 0 0 0 
*	0 1 0 1 0 0 1 1 	1 1 1 1 0 1 0 0 
*	1 0 0 0 1 0 1 1 	0 0 1 0 1 1 0 1 
*	0 1 0 1 1 0 0 0 	0 1 1 0 0 1 0 1 
*	1 0 0 1 1 1 1 0 	0 0 0 1 0 0 1 0 
*	1 0 0 0 1 1 1 1 	0 1 1 0 0 1 1 0 
*	1 0 0 0 0 1 0 1 	0 0 1 0 1 0 1 1 
*
* S = 19 07 3A 91 A4 BB 6A 20
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_43 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[6];
	assign g_in[5] = in[6] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 1 0 0 
	*	1 1 1 0 1 1 1 0 
	*	1 1 0 0 1 0 0 0 
	*	0 0 0 1 0 1 1 1 
	*	0 0 0 0 0 0 1 0 
	*	0 0 1 0 0 1 1 1 
	*	1 1 0 0 0 0 0 1 
	*	1 0 0 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] );
	assign out[4] = g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[1];
	assign out[2] = g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 44
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 0 0 1 1 0 	0 0 1 0 0 1 0 0 
*	0 0 1 0 0 1 1 0 	1 1 0 0 0 0 0 0 
*	1 1 0 1 1 0 0 0 	1 0 1 0 1 1 0 0 
*	0 1 0 1 0 0 1 1 	0 0 0 1 1 0 1 1 
*	1 1 0 0 0 1 1 0 	1 1 0 1 1 1 1 1 
*	0 1 0 1 1 0 0 0 	0 0 1 1 0 0 0 1 
*	0 0 0 0 1 0 1 0 	1 1 0 1 1 1 0 1 
*	1 0 0 0 1 1 1 1 	0 0 0 1 0 1 1 0 
*
* S = 1E 19 AB 3A 1F A4 4A 6A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_44 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3];
	assign g_in[4] = in[6] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3];
	assign g_in[1] = in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 1 0 0 
	*	1 0 0 1 1 0 0 1 
	*	1 0 0 0 0 1 0 0 
	*	0 0 1 1 1 1 1 0 
	*	0 0 0 0 0 0 0 1 
	*	0 0 0 1 1 1 1 0 
	*	1 0 0 0 0 0 1 1 
	*	0 1 0 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[0];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 45
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 0 0 1 1 0 	0 0 1 0 1 1 0 0 
*	0 1 0 0 0 0 0 0 	0 1 0 0 0 0 0 0 
*	1 1 0 1 1 0 0 0 	1 0 1 0 0 1 0 0 
*	1 0 0 0 1 0 1 1 	0 0 1 1 1 0 0 1 
*	1 1 0 0 0 1 1 0 	0 1 1 1 0 1 0 1 
*	1 0 0 1 1 1 1 0 	0 0 0 1 0 0 1 1 
*	0 0 0 0 1 0 1 0 	0 1 1 1 0 1 1 1 
*	1 0 0 0 0 1 0 1 	0 0 1 1 1 1 1 0 
*
* S = 1E 07 AB 91 1F BB 4A 20
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_45 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[6];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3];
	assign g_in[4] = in[7] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 1 0 0 
	*	1 0 1 1 1 0 1 1 
	*	1 0 0 0 1 1 0 0 
	*	0 0 0 1 0 1 1 0 
	*	0 0 0 0 0 0 1 1 
	*	0 0 1 1 0 1 1 0 
	*	1 0 0 0 0 0 0 1 
	*	1 1 0 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 46
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 0 1 1 0 	1 1 1 1 1 0 0 0 
*	0 1 0 0 0 0 0 0 	0 1 0 0 0 0 0 0 
*	0 1 1 1 0 1 0 1 	0 0 1 1 0 1 0 0 
*	1 1 0 0 1 0 1 1 	1 0 1 0 1 0 0 1 
*	0 1 0 1 1 0 0 0 	1 1 1 0 0 0 0 1 
*	1 0 0 1 1 1 1 0 	0 1 0 1 1 0 1 0 
*	1 1 0 1 0 1 1 1 	1 1 1 0 1 1 1 0 
*	0 0 0 1 1 0 1 1 	1 0 1 0 0 1 1 1 
*
* S = 19 07 23 96 A4 BB CE 9B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_46 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[6];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 1 0 0 
	*	0 1 1 0 0 1 1 0 
	*	1 1 0 0 1 0 0 0 
	*	0 1 0 1 1 0 1 1 
	*	0 0 0 0 1 0 1 0 
	*	1 0 1 0 1 0 1 1 
	*	1 1 0 0 0 1 0 1 
	*	1 0 0 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 47
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 0 0 1 1 0 	1 0 1 0 0 1 0 0 
*	0 0 1 0 0 1 1 0 	1 1 0 0 0 0 0 0 
*	1 0 1 1 1 1 1 0 	0 0 1 0 1 1 0 0 
*	0 1 1 1 0 1 0 1 	0 1 0 1 0 1 1 1 
*	1 1 0 0 0 1 1 0 	1 0 0 1 0 0 1 1 
*	0 1 0 1 1 0 0 0 	1 1 1 1 0 1 0 1 
*	1 1 0 0 1 1 0 0 	1 0 0 1 1 0 0 1 
*	1 1 0 1 0 1 1 1 	0 1 0 1 1 1 1 0 
*
* S = 1E 19 B5 23 1F A4 55 CE
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_47 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 1 0 0 
	*	1 1 0 1 1 1 0 1 
	*	1 0 0 0 0 1 0 0 
	*	1 1 1 1 0 1 1 0 
	*	0 0 0 0 0 1 0 1 
	*	0 1 0 1 0 1 1 0 
	*	1 0 0 0 1 1 1 1 
	*	0 1 0 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 48
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 0 0 1 1 0 	1 0 1 0 1 1 0 0 
*	0 1 0 0 0 0 0 0 	0 1 0 0 0 0 0 0 
*	1 0 1 1 1 1 1 0 	0 0 1 0 0 1 0 0 
*	1 1 0 0 1 0 1 1 	1 1 1 1 1 1 0 1 
*	1 1 0 0 0 1 1 0 	1 0 1 1 0 0 0 1 
*	1 0 0 1 1 1 1 0 	0 1 0 1 1 1 1 1 
*	1 1 0 0 1 1 0 0 	1 0 1 1 1 0 1 1 
*	0 0 0 1 1 0 1 1 	1 1 1 1 0 1 1 0 
*
* S = 1E 07 B5 96 1F BB 55 9B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_48 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[6];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2];
	assign g_in[0] = in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 1 0 0 
	*	0 1 1 1 0 1 1 1 
	*	1 0 0 0 1 1 0 0 
	*	0 1 0 1 1 1 1 0 
	*	0 0 0 0 1 1 1 1 
	*	1 1 1 1 1 1 1 0 
	*	1 0 0 0 0 1 0 1 
	*	1 1 0 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 49
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 0 1 1 0 	0 1 1 1 1 0 0 0 
*	0 1 0 0 0 0 0 0 	0 1 0 0 0 0 0 0 
*	0 0 1 1 0 1 0 1 	1 0 1 1 0 1 0 0 
*	1 0 1 0 1 1 0 1 	1 1 1 0 0 1 0 1 
*	0 1 0 1 1 0 0 0 	1 0 1 0 1 1 0 1 
*	1 0 0 1 1 1 1 0 	1 0 0 1 1 1 1 0 
*	0 1 0 0 1 0 0 1 	1 0 1 0 1 0 1 0 
*	1 1 0 1 1 1 0 1 	1 1 1 0 1 1 1 1 
*
* S = 19 07 3D 8F A4 BB D1 3F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_49 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[6];
	assign g_in[5] = in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 1 0 0 
	*	0 0 1 0 0 0 1 0 
	*	1 1 0 0 1 0 0 0 
	*	1 0 0 1 0 0 1 1 
	*	0 0 0 0 1 1 1 0 
	*	1 1 1 0 0 0 1 1 
	*	1 1 0 0 1 0 0 1 
	*	1 0 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 50
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 0 0 1 1 0 	1 1 1 0 0 1 0 0 
*	0 0 1 0 0 1 1 0 	1 1 0 0 0 0 0 0 
*	1 0 0 1 1 0 0 0 	0 1 1 0 1 1 0 0 
*	0 0 1 1 0 1 0 1 	1 0 0 1 1 1 1 1 
*	1 1 0 0 0 1 1 0 	0 1 0 1 1 0 1 1 
*	0 1 0 1 1 0 0 0 	0 1 1 1 1 0 0 1 
*	1 0 0 1 0 1 0 0 	0 1 0 1 0 1 0 1 
*	0 1 0 0 1 0 0 1 	1 0 0 1 1 0 1 0 
*
* S = 1E 19 B2 3D 1F A4 EE D1
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_50 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[4] ^ in[3];
	assign g_in[4] = in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3];
	assign g_in[1] = in[7] ^ in[4] ^ in[2];
	assign g_in[0] = in[6] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 1 0 0 
	*	0 0 0 1 0 0 0 1 
	*	1 0 0 0 0 1 0 0 
	*	0 1 1 1 0 0 1 0 
	*	0 0 0 0 1 0 0 1 
	*	1 0 0 1 0 0 1 0 
	*	1 0 0 0 0 1 1 1 
	*	0 1 0 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[4] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[3] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 51
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 0 0 1 1 0 	0 1 1 0 1 1 0 0 
*	0 1 0 0 0 0 0 0 	0 1 0 0 0 0 0 0 
*	1 0 0 1 1 0 0 0 	1 1 1 0 0 1 0 0 
*	1 0 1 0 1 1 0 1 	1 0 1 1 0 1 0 1 
*	1 1 0 0 0 1 1 0 	1 1 1 1 1 0 0 1 
*	1 0 0 1 1 1 1 0 	1 1 0 1 1 0 1 1 
*	1 0 0 1 0 1 0 0 	1 1 1 1 1 1 1 1 
*	1 1 0 1 1 1 0 1 	1 0 1 1 1 0 1 0 
*
* S = 1E 07 B2 8F 1F BB EE 3F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_51 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[6];
	assign g_in[5] = in[7] ^ in[4] ^ in[3];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[4] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 1 0 0 
	*	0 0 1 1 0 0 1 1 
	*	1 0 0 0 1 1 0 0 
	*	1 1 0 1 0 0 1 0 
	*	0 0 0 0 1 0 1 1 
	*	1 0 1 1 0 0 1 0 
	*	1 0 0 0 1 1 0 1 
	*	1 1 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 52
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 0 1 1 0 	1 0 1 1 1 0 0 0 
*	0 1 0 0 0 0 0 0 	0 1 0 0 0 0 0 0 
*	0 0 0 1 0 0 1 1 	0 1 1 1 0 1 0 0 
*	1 1 1 0 1 1 0 1 	0 1 1 0 0 0 0 1 
*	0 1 0 1 1 0 0 0 	0 0 1 0 1 0 0 1 
*	1 0 0 1 1 1 1 0 	1 1 0 1 0 1 1 0 
*	0 0 0 1 0 0 0 1 	0 0 1 0 0 0 1 0 
*	0 1 0 0 0 0 1 1 	0 1 1 0 0 0 1 1 
*
* S = 19 07 24 88 A4 BB 75 84
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_52 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[6];
	assign g_in[5] = in[4] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[4] ^ in[0];
	assign g_in[0] = in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 1 0 0 
	*	1 0 1 0 1 0 1 0 
	*	1 1 0 0 1 0 0 0 
	*	1 1 0 1 1 1 1 1 
	*	0 0 0 0 0 1 1 0 
	*	0 1 1 0 1 1 1 1 
	*	1 1 0 0 1 1 0 1 
	*	1 0 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 53
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 0 0 1 1 0 	0 1 1 0 0 1 0 0 
*	0 0 1 0 0 1 1 0 	1 1 0 0 0 0 0 0 
*	1 1 1 1 1 1 1 0 	1 1 1 0 1 1 0 0 
*	0 0 0 1 0 0 1 1 	1 1 0 1 0 0 1 1 
*	1 1 0 0 0 1 1 0 	0 0 0 1 0 1 1 1 
*	0 1 0 1 1 0 0 0 	1 0 1 1 1 1 0 1 
*	0 1 0 1 0 0 1 0 	0 0 0 1 0 0 0 1 
*	0 0 0 1 0 0 0 1 	1 1 0 1 0 0 1 0 
*
* S = 1E 19 AC 24 1F A4 F1 75
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_53 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[4] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3];
	assign g_in[1] = in[6] ^ in[4] ^ in[1];
	assign g_in[0] = in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 1 0 0 
	*	0 1 0 1 0 1 0 1 
	*	1 0 0 0 0 1 0 0 
	*	1 0 1 1 1 0 1 0 
	*	0 0 0 0 1 1 0 1 
	*	1 1 0 1 1 0 1 0 
	*	1 0 0 0 1 0 1 1 
	*	0 1 0 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 54
*
* GF(2^8) Norm Basis: [d^64, d^4]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 0 0 1 1 0 	1 1 1 0 1 1 0 0 
*	0 1 0 0 0 0 0 0 	0 1 0 0 0 0 0 0 
*	1 1 1 1 1 1 1 0 	0 1 1 0 0 1 0 0 
*	1 1 1 0 1 1 0 1 	0 1 1 1 0 0 0 1 
*	1 1 0 0 0 1 1 0 	0 0 1 1 1 1 0 1 
*	1 0 0 1 1 1 1 0 	1 0 0 1 0 1 1 1 
*	0 1 0 1 0 0 1 0 	0 0 1 1 0 0 1 1 
*	0 1 0 0 0 0 1 1 	0 1 1 1 0 0 1 0 
*
* S = 1E 07 AC 88 1F BB F1 84
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_54 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[6];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 1 0 0 
	*	1 1 1 1 1 1 1 1 
	*	1 0 0 0 1 1 0 0 
	*	1 0 0 1 1 0 1 0 
	*	0 0 0 0 0 1 1 1 
	*	0 1 1 1 1 0 1 0 
	*	1 0 0 0 1 0 0 1 
	*	1 1 0 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 55
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 0 1 0 0 0 1 	0 0 1 1 0 1 0 1 
*	0 0 1 0 0 1 0 1 	0 0 1 0 0 1 1 1 
*	0 1 1 1 1 0 1 1 	1 1 0 0 1 0 1 0 
*	0 0 0 1 1 0 0 1 	0 0 0 0 0 0 1 1 
*	1 0 0 0 1 1 0 1 	1 0 1 1 0 1 1 1 
*	0 0 1 0 1 0 1 1 	0 0 1 0 1 1 1 0 
*	1 1 0 1 1 0 0 1 	1 1 0 1 1 1 0 1 
*	1 1 0 0 1 0 0 1 	1 0 1 0 0 1 0 0 
*
* S = DA 7C CF 26 8A CD 22 2B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_55 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[4] ^ in[0];
	assign g_in[6] = in[5] ^ in[2] ^ in[0];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[4] = in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[7] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[2] = in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 1 0 0 
	*	0 1 1 1 0 1 1 1 
	*	1 0 0 0 1 1 0 1 
	*	1 1 1 0 0 0 1 1 
	*	1 1 0 1 0 1 0 1 
	*	0 1 0 0 0 1 0 1 
	*	1 0 1 0 0 0 0 1 
	*	0 1 1 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 56
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 0 1 0 0 	0 0 1 0 1 1 1 1 
*	0 1 0 1 0 0 0 1 	0 0 0 1 1 1 1 0 
*	0 1 1 0 0 0 1 0 	1 0 0 0 0 1 0 1 
*	0 1 1 1 1 0 1 1 	0 0 0 0 0 0 1 0 
*	1 0 1 0 0 1 1 0 	0 1 1 0 1 1 1 0 
*	1 0 0 0 1 1 0 1 	0 0 0 1 1 0 0 1 
*	0 0 0 1 0 0 0 0 	1 0 1 1 1 0 1 1 
*	1 1 0 1 1 0 0 1 	0 1 0 1 1 1 0 0 
*
* S = A6 DA E9 CF 47 8A 09 22
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_56 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[6] = in[6] ^ in[4] ^ in[0];
	assign g_in[5] = in[6] ^ in[5] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 0 0 0 
	*	1 1 1 0 1 1 1 0 
	*	0 1 0 0 1 0 1 1 
	*	1 0 0 1 0 0 1 0 
	*	1 0 1 1 1 1 1 1 
	*	1 1 0 0 1 1 1 1 
	*	0 1 0 1 0 0 1 1 
	*	1 1 1 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 57
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 0 1 0 0 	0 0 1 0 0 1 0 1 
*	0 0 1 0 0 1 0 1 	0 0 1 1 0 1 1 0 
*	0 1 1 0 0 0 1 0 	1 0 0 0 1 1 1 1 
*	0 0 0 1 1 0 0 1 	0 0 0 0 0 0 1 0 
*	1 0 1 0 0 1 1 0 	1 1 1 0 0 1 1 0 
*	0 0 1 0 1 0 1 1 	0 0 1 1 1 0 1 1 
*	0 0 0 1 0 0 0 0 	1 0 0 1 1 0 0 1 
*	1 1 0 0 1 0 0 1 	1 1 1 1 0 1 0 0 
*
* S = A6 7C E9 26 47 CD 09 2B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_57 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[6] = in[5] ^ in[2] ^ in[0];
	assign g_in[5] = in[6] ^ in[5] ^ in[1];
	assign g_in[4] = in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 0 0 0 
	*	0 1 1 0 0 1 1 0 
	*	1 1 0 0 1 0 0 1 
	*	1 0 1 1 0 0 1 0 
	*	1 0 0 1 0 1 0 1 
	*	0 1 0 0 0 1 0 1 
	*	1 1 1 1 0 0 0 1 
	*	0 1 1 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 58
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 0 0 0 1 1 1 	0 1 1 0 0 1 0 1 
*	0 0 0 0 1 1 1 1 	1 1 0 1 1 0 0 0 
*	0 1 1 0 1 1 0 1 	1 0 0 1 1 0 1 0 
*	0 0 1 1 0 0 1 1 	0 0 0 0 0 1 1 0 
*	0 0 1 1 1 0 1 1 	0 0 0 1 1 0 0 0 
*	0 1 1 1 1 1 1 1 	1 1 0 1 0 1 0 0 
*	0 1 1 0 1 1 1 1 	0 0 1 0 0 0 1 0 
*	1 0 0 1 1 1 0 1 	1 0 1 0 1 1 1 0 
*
* S = 80 33 95 69 6C 83 C4 65
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_58 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[6] = in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[5] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[4] = in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[3] = in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw2_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 0 0 1 
	*	1 0 0 0 1 0 0 0 
	*	0 1 1 1 0 0 1 0 
	*	0 1 0 0 0 1 1 0 
	*	0 0 1 0 0 1 0 1 
	*	1 1 1 0 0 1 0 1 
	*	1 0 1 0 1 0 1 1 
	*	1 0 0 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[3] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 59
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 0 0 1 0 0 0 	1 1 0 1 1 1 1 1 
*	0 1 0 0 0 1 1 1 	1 0 1 1 0 1 0 0 
*	0 1 0 1 1 1 1 0 	0 1 1 1 0 1 0 1 
*	0 1 1 0 1 1 0 1 	0 0 0 0 1 1 0 1 
*	0 1 0 0 0 1 0 0 	0 0 1 1 0 1 0 0 
*	0 0 1 1 1 0 1 1 	1 0 1 1 1 1 0 0 
*	1 1 1 1 0 0 1 0 	0 0 0 1 0 0 0 1 
*	0 1 1 0 1 1 1 1 	0 1 0 1 1 0 0 1 
*
* S = B3 80 FC 95 EF 6C A1 C4
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_59 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[3];
	assign g_in[6] = in[6] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[5] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[2];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 0 1 1 1 
	*	0 1 0 0 0 1 0 0 
	*	1 1 1 0 0 0 0 1 
	*	1 1 0 0 1 1 0 1 
	*	0 0 0 1 1 1 1 1 
	*	1 0 0 1 1 1 1 1 
	*	0 1 0 1 0 1 1 0 
	*	0 1 0 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[2] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 60
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 0 0 1 0 0 0 	0 1 1 1 0 1 0 1 
*	0 0 0 0 1 1 1 1 	1 0 0 1 1 1 0 0 
*	0 1 0 1 1 1 1 0 	1 1 0 1 1 1 1 1 
*	0 0 1 1 0 0 1 1 	0 0 0 0 0 1 1 1 
*	0 1 0 0 0 1 0 0 	0 0 0 1 1 1 0 0 
*	0 1 1 1 1 1 1 1 	1 0 0 1 0 1 0 0 
*	1 1 1 1 0 0 1 0 	0 0 1 1 0 0 1 1 
*	1 0 0 1 1 1 0 1 	1 1 1 1 1 0 1 1 
*
* S = B3 33 FC 69 EF 83 A1 65
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_60 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[3];
	assign g_in[6] = in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[5] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[2];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 1 0 1 
	*	1 1 0 0 1 1 0 0 
	*	0 1 1 0 0 0 1 1 
	*	0 1 0 0 0 1 1 1 
	*	0 0 1 1 0 1 0 1 
	*	1 0 1 1 0 1 0 1 
	*	1 1 1 1 1 1 1 0 
	*	1 1 0 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 61
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 1 0 1 0 	1 1 1 1 0 1 0 0 
*	0 0 1 1 1 1 0 0 	1 0 1 0 1 1 1 0 
*	0 1 0 1 0 0 0 1 	0 0 1 1 1 0 0 0 
*	0 0 1 0 0 1 0 1 	0 0 0 0 1 1 1 1 
*	0 1 0 1 0 1 0 0 	1 1 0 1 1 1 1 0 
*	1 1 1 0 0 0 1 0 	1 0 1 0 1 0 0 1 
*	1 0 0 0 1 1 0 1 	0 1 1 0 0 1 1 0 
*	0 0 1 0 1 0 1 1 	1 0 0 0 0 0 0 1 
*
* S = 15 5A DA 7C A8 E6 8A CD
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_61 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[4] ^ in[0];
	assign g_in[4] = in[5] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[7] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 0 1 1 
	*	1 1 1 0 1 1 1 0 
	*	0 0 1 0 0 1 1 0 
	*	1 0 0 1 1 1 1 1 
	*	0 1 1 0 0 1 0 0 
	*	0 0 0 1 0 1 0 0 
	*	1 0 0 0 0 1 0 1 
	*	1 1 1 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[2] = g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 62
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 1 0 	1 0 1 0 1 1 0 0 
*	0 0 1 0 1 0 1 0 	0 1 0 1 1 0 0 1 
*	0 1 1 1 0 1 0 0 	0 0 1 0 0 1 0 0 
*	0 1 0 1 0 0 0 1 	0 0 0 0 1 0 1 0 
*	1 0 1 1 0 1 1 0 	1 0 1 1 1 0 0 1 
*	0 1 0 1 0 1 0 0 	0 1 0 1 0 1 1 1 
*	1 0 1 0 0 1 1 0 	1 1 0 1 1 1 0 1 
*	1 0 0 0 1 1 0 1 	0 1 0 0 0 0 1 1 
*
* S = 4F 15 A6 DA 4E A8 47 8A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_62 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[3] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[4] = in[6] ^ in[4] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 0 0 1 0 
	*	1 0 0 1 1 0 0 1 
	*	0 0 0 1 1 1 0 1 
	*	0 1 1 1 1 0 1 0 
	*	1 1 0 1 1 1 0 0 
	*	0 0 1 1 1 1 0 0 
	*	0 1 0 0 1 1 1 1 
	*	1 0 0 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[5] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 63
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 1 0 	1 0 1 0 0 1 0 0 
*	0 0 1 1 1 1 0 0 	1 1 1 1 1 0 1 1 
*	0 1 1 1 0 1 0 0 	0 0 1 0 1 1 0 0 
*	0 0 1 0 0 1 0 1 	0 0 0 0 1 0 1 0 
*	1 0 1 1 0 1 1 0 	1 0 0 1 1 0 1 1 
*	1 1 1 0 0 0 1 0 	1 1 1 1 1 1 0 1 
*	1 0 1 0 0 1 1 0 	0 1 1 1 0 1 1 1 
*	0 0 1 0 1 0 1 1 	1 1 0 0 0 0 0 1 
*
* S = 4F 5A A6 7C 4E E6 47 CD
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_63 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[4] = in[5] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[0] = in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 0 1 0 
	*	1 0 1 1 1 0 1 1 
	*	0 0 1 1 0 1 1 1 
	*	1 1 0 1 1 0 1 0 
	*	0 1 1 1 0 1 0 0 
	*	0 0 0 1 0 1 0 0 
	*	1 1 0 0 0 1 0 1 
	*	1 0 1 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[2] = g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 64
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 1 0 1 0 	0 0 1 1 0 1 0 0 
*	0 0 1 1 1 1 0 0 	0 0 1 0 0 1 1 0 
*	0 1 1 1 1 0 1 1 	1 1 1 1 1 0 0 0 
*	0 0 0 1 1 0 0 1 	0 0 0 0 0 0 1 1 
*	0 1 0 1 0 1 0 0 	1 0 0 1 0 1 1 0 
*	1 1 1 0 0 0 1 0 	0 0 1 0 1 1 0 1 
*	1 1 0 1 1 0 0 1 	1 1 1 0 1 1 1 0 
*	1 1 0 0 1 0 0 1 	1 0 0 0 0 1 0 1 
*
* S = 15 5A CF 26 A8 E6 22 2B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_64 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[4] = in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 1 1 1 
	*	0 1 1 0 0 1 1 0 
	*	1 0 1 0 1 1 1 0 
	*	1 1 0 1 0 0 1 1 
	*	1 1 1 0 0 1 0 0 
	*	0 1 0 1 0 1 0 0 
	*	1 0 0 0 0 0 0 1 
	*	0 1 1 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 65
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 1 0 	0 0 1 0 1 1 0 0 
*	0 0 1 0 1 0 1 0 	0 0 0 1 1 1 0 1 
*	0 1 1 0 0 0 1 0 	1 0 1 0 0 1 0 0 
*	0 1 1 1 1 0 1 1 	0 0 0 0 0 0 1 0 
*	1 0 1 1 0 1 1 0 	0 1 1 1 1 1 0 1 
*	0 1 0 1 0 1 0 0 	0 0 0 1 1 0 1 1 
*	0 0 0 1 0 0 0 0 	1 0 0 1 1 0 0 1 
*	1 1 0 1 1 0 0 1 	0 1 0 0 1 1 1 1 
*
* S = 4F 15 E9 CF 4E A8 09 22
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_65 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[3] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2];
	assign g_in[1] = in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 0 1 0 
	*	1 1 0 1 1 1 0 1 
	*	0 1 0 1 1 0 0 1 
	*	1 0 1 1 0 0 1 0 
	*	1 0 0 1 1 1 0 0 
	*	1 1 1 1 1 1 0 0 
	*	0 1 0 0 0 0 1 1 
	*	1 1 0 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[6] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 66
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 1 0 	0 0 1 0 0 1 0 0 
*	0 0 1 1 1 1 0 0 	0 0 1 1 0 1 1 1 
*	0 1 1 0 0 0 1 0 	1 0 1 0 1 1 0 0 
*	0 0 0 1 1 0 0 1 	0 0 0 0 0 0 1 0 
*	1 0 1 1 0 1 1 0 	1 1 0 1 0 1 1 1 
*	1 1 1 0 0 0 1 0 	0 0 1 1 1 0 0 1 
*	0 0 0 1 0 0 0 0 	1 0 1 1 1 0 1 1 
*	1 1 0 0 1 0 0 1 	1 1 0 0 0 1 0 1 
*
* S = 4F 5A E9 26 4E E6 09 2B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_66 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[1];
	assign g_in[4] = in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 0 1 0 
	*	0 1 1 1 0 1 1 1 
	*	1 1 1 1 1 0 1 1 
	*	1 0 0 1 0 0 1 0 
	*	1 0 1 1 0 1 0 0 
	*	0 1 0 1 0 1 0 0 
	*	1 1 0 0 0 0 0 1 
	*	0 1 1 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 67
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 1 0 1 0 	1 0 1 1 0 1 0 0 
*	0 0 1 1 1 1 0 0 	0 1 1 0 0 0 1 0 
*	0 1 0 0 0 1 1 1 	0 1 1 1 1 0 0 0 
*	0 0 0 0 1 1 1 1 	0 0 0 0 1 0 1 1 
*	0 1 0 1 0 1 0 0 	0 1 0 1 0 0 1 0 
*	1 1 1 0 0 0 1 0 	0 1 1 0 0 0 0 1 
*	0 0 1 1 1 0 1 1 	1 0 1 0 1 0 1 0 
*	0 1 1 1 1 1 1 1 	1 0 0 0 1 0 0 1 
*
* S = 15 5A 80 33 A8 E6 6C 83
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_67 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[4] = in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 1 1 1 
	*	0 0 1 0 0 0 1 0 
	*	1 1 1 0 1 0 1 0 
	*	0 0 0 1 1 0 1 1 
	*	1 0 1 0 0 1 0 0 
	*	1 0 0 1 0 1 0 0 
	*	1 0 0 0 1 1 0 1 
	*	0 0 1 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[5] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 68
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 1 0 	0 1 1 0 1 1 0 0 
*	0 0 1 0 1 0 1 0 	1 1 0 1 0 0 0 1 
*	0 1 0 0 1 0 0 0 	1 1 1 0 0 1 0 0 
*	0 1 0 0 0 1 1 1 	0 0 0 0 0 1 1 0 
*	1 0 1 1 0 1 1 0 	1 1 1 1 0 0 0 1 
*	0 1 0 1 0 1 0 0 	1 1 0 1 0 0 1 1 
*	0 1 0 0 0 1 0 0 	0 1 0 1 0 1 0 1 
*	0 0 1 1 1 0 1 1 	0 1 0 0 0 1 1 1 
*
* S = 4F 15 B3 80 4E A8 EF 6C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_68 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[3] ^ in[1];
	assign g_in[5] = in[6] ^ in[3];
	assign g_in[4] = in[6] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2];
	assign g_in[1] = in[6] ^ in[2];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 1 1 0 
	*	0 0 0 1 0 0 0 1 
	*	1 0 0 1 0 1 0 1 
	*	0 0 1 1 0 1 1 0 
	*	0 1 0 1 1 1 0 0 
	*	0 1 1 1 1 1 0 0 
	*	0 1 0 0 1 0 1 1 
	*	0 0 0 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[4] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 69
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 1 0 	1 1 1 0 0 1 0 0 
*	0 0 1 1 1 1 0 0 	0 1 1 1 0 0 1 1 
*	0 1 0 0 1 0 0 0 	0 1 1 0 1 1 0 0 
*	0 0 0 0 1 1 1 1 	0 0 0 0 1 1 1 0 
*	1 0 1 1 0 1 1 0 	0 1 0 1 0 0 1 1 
*	1 1 1 0 0 0 1 0 	0 1 1 1 0 0 0 1 
*	0 1 0 0 0 1 0 0 	1 1 1 1 1 1 1 1 
*	0 1 1 1 1 1 1 1 	1 1 0 0 1 1 0 1 
*
* S = 4F 5A B3 33 4E E6 EF 83
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_69 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[3];
	assign g_in[4] = in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[6] ^ in[2];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 1 1 0 
	*	0 0 1 1 0 0 1 1 
	*	1 0 1 1 1 1 1 1 
	*	0 0 0 1 1 1 1 0 
	*	1 1 1 1 0 1 0 0 
	*	1 1 0 1 0 1 0 0 
	*	1 1 0 0 1 0 0 1 
	*	0 0 1 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 70
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 1 0 1 0 	0 1 1 1 0 1 0 0 
*	0 0 1 1 1 1 0 0 	1 1 1 0 1 0 1 0 
*	0 1 1 0 1 1 0 1 	1 0 1 1 1 0 0 0 
*	0 0 1 1 0 0 1 1 	0 0 0 0 0 1 1 1 
*	0 1 0 1 0 1 0 0 	0 0 0 1 1 0 1 0 
*	1 1 1 0 0 0 1 0 	1 1 1 0 0 1 0 1 
*	0 1 1 0 1 1 1 1 	0 0 1 0 0 0 1 0 
*	1 0 0 1 1 1 0 1 	1 0 0 0 1 1 0 1 
*
* S = 15 5A 95 69 A8 E6 C4 65
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_70 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[4] = in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 0 1 1 
	*	1 0 1 0 1 0 1 0 
	*	0 1 1 0 0 0 1 0 
	*	0 1 0 1 0 1 1 1 
	*	0 0 1 0 0 1 0 0 
	*	1 1 0 1 0 1 0 0 
	*	1 0 0 0 1 0 0 1 
	*	1 0 1 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 71
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 1 0 	1 1 1 0 1 1 0 0 
*	0 0 1 0 1 0 1 0 	1 0 0 1 0 1 0 1 
*	0 1 0 1 1 1 1 0 	0 1 1 0 0 1 0 0 
*	0 1 1 0 1 1 0 1 	0 0 0 0 1 1 1 0 
*	1 0 1 1 0 1 1 0 	0 0 1 1 0 1 0 1 
*	0 1 0 1 0 1 0 0 	1 0 0 1 1 1 1 1 
*	1 1 1 1 0 0 1 0 	0 0 0 1 0 0 0 1 
*	0 1 1 0 1 1 1 1 	0 1 0 0 1 0 1 1 
*
* S = 4F 15 FC 95 4E A8 A1 C4
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_71 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[3] ^ in[1];
	assign g_in[5] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 0 1 1 0 
	*	0 1 0 1 0 1 0 1 
	*	1 1 0 1 0 0 0 1 
	*	1 1 1 1 1 1 1 0 
	*	0 0 0 1 1 1 0 0 
	*	1 0 1 1 1 1 0 0 
	*	0 1 0 0 0 1 1 1 
	*	0 1 0 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 72
*
* GF(2^8) Norm Basis: [d^128, d^8]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 0 1 1 0 	0 1 1 0 0 1 0 0 
*	0 0 1 1 1 1 0 0 	1 0 1 1 1 1 1 1 
*	0 1 0 1 1 1 1 0 	1 1 1 0 1 1 0 0 
*	0 0 1 1 0 0 1 1 	0 0 0 0 0 1 1 0 
*	1 0 1 1 0 1 1 0 	0 0 0 1 1 1 1 1 
*	1 1 1 0 0 0 1 0 	1 0 1 1 0 1 0 1 
*	1 1 1 1 0 0 1 0 	0 0 1 1 0 0 1 1 
*	1 0 0 1 1 1 0 1 	1 1 0 0 1 0 0 1 
*
* S = 4F 5A FC 69 4E E6 A1 65
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_72 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 1 1 0 
	*	1 1 1 1 1 1 1 1 
	*	0 1 1 1 0 0 1 1 
	*	0 1 0 1 0 1 1 0 
	*	0 0 1 1 0 1 0 0 
	*	1 0 0 1 0 1 0 0 
	*	1 1 0 0 1 1 0 1 
	*	1 1 1 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 73
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 0 1 1 1 0 1 	0 0 0 1 0 1 1 1 
*	0 1 0 1 1 0 0 1 	1 0 1 0 1 1 1 1 
*	1 0 1 0 0 1 0 1 	1 1 1 0 1 0 0 0 
*	1 0 1 1 1 0 0 1 	1 0 1 0 1 0 0 1 
*	1 0 0 0 0 0 0 1 	0 1 0 1 1 0 0 1 
*	0 1 0 1 0 1 1 1 	1 1 0 0 0 0 0 0 
*	0 0 0 0 0 1 1 1 	1 1 0 1 1 1 0 1 
*	0 1 1 0 1 0 0 1 	0 0 0 1 1 1 1 1 
*
* S = DB C1 C3 7B 8B 70 2E 76
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_73 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[6] = in[6] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[5] = in[7] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[7] ^ in[0];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 0 0 0 
	*	0 1 1 1 0 1 1 1 
	*	0 0 0 0 0 1 0 1 
	*	1 1 1 1 0 0 1 0 
	*	0 1 0 0 1 1 0 0 
	*	1 0 1 1 1 0 1 0 
	*	1 0 0 1 0 0 1 0 
	*	1 1 1 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 74
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 0 1 0 0 	0 0 1 1 1 1 1 0 
*	0 1 0 1 1 1 0 1 	0 1 0 1 1 0 1 0 
*	0 0 0 1 1 1 0 0 	1 0 0 1 0 1 0 0 
*	1 0 1 0 0 1 0 1 	0 1 0 1 0 1 1 1 
*	1 1 0 1 0 1 1 0 	1 1 1 1 0 1 1 1 
*	1 0 0 0 0 0 0 1 	1 0 0 0 0 0 0 0 
*	0 1 1 0 1 1 1 0 	1 0 1 1 1 0 1 1 
*	0 0 0 0 0 1 1 1 	0 0 1 1 1 0 1 0 
*
* S = 1A DB B8 C3 FB 8B 58 2E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_74 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[2];
	assign g_in[6] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[5] = in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 0 0 0 0 
	*	1 1 1 0 1 1 1 0 
	*	0 0 0 0 1 1 1 1 
	*	1 0 1 0 0 0 0 1 
	*	1 1 0 0 1 0 0 0 
	*	0 1 1 0 0 1 0 1 
	*	0 1 1 1 0 0 0 1 
	*	1 0 0 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 75
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 0 1 0 0 	0 0 0 1 0 1 1 0 
*	0 1 0 1 1 0 0 1 	1 1 1 1 1 0 1 0 
*	0 0 0 1 1 1 0 0 	1 0 1 1 1 1 0 0 
*	1 0 1 1 1 0 0 1 	1 1 1 1 1 1 0 1 
*	1 1 0 1 0 1 1 0 	0 1 0 1 1 1 0 1 
*	0 1 0 1 0 1 1 1 	1 0 0 0 0 0 0 0 
*	0 1 1 0 1 1 1 0 	1 0 0 1 1 0 0 1 
*	0 1 1 0 1 0 0 1 	0 0 0 1 1 0 1 0 
*
* S = 1A C1 B8 7B FB 70 58 76
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_75 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[2];
	assign g_in[6] = in[6] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[5] = in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 0 0 0 
	*	0 1 1 0 0 1 1 0 
	*	0 0 0 0 0 1 0 1 
	*	1 0 1 0 0 0 1 1 
	*	0 1 0 0 1 0 0 0 
	*	1 1 1 0 1 1 1 1 
	*	1 1 0 1 0 0 1 1 
	*	1 0 1 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[3];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 76
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 0 0 0 1 0 1 	1 0 1 1 1 0 0 0 
*	1 0 1 0 0 0 0 1 	1 0 1 0 1 1 1 1 
*	1 0 1 1 1 1 0 1 	0 1 0 0 0 1 1 1 
*	0 1 0 0 0 0 0 1 	1 0 1 0 1 1 0 0 
*	0 0 1 1 1 0 0 1 	0 1 0 1 1 1 0 0 
*	1 1 0 1 0 0 0 1 	1 0 0 1 0 0 0 0 
*	1 0 1 1 1 1 1 1 	0 0 1 0 0 0 1 0 
*	1 1 1 0 1 1 1 1 	1 0 1 1 1 1 1 1 
*
* S = 61 63 79 D9 8D D3 28 D5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_76 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[2] ^ in[0];
	assign g_in[6] = in[7] ^ in[5] ^ in[0];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[4] = in[6] ^ in[0];
	assign g_in[3] = in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 0 0 0 
	*	1 0 0 0 1 0 0 0 
	*	0 0 0 0 0 1 0 1 
	*	1 1 1 1 1 1 0 1 
	*	1 1 1 0 1 0 0 1 
	*	0 0 0 1 1 0 1 0 
	*	1 1 0 0 1 1 0 1 
	*	0 1 0 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5];
	assign out[6] = ~( g_out[7] ^ g_out[3] );
	assign out[5] = ~( g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 77
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 0 0 1 0 0 	0 1 1 0 0 1 0 0 
*	0 1 0 0 0 1 0 1 	0 1 0 1 1 0 1 0 
*	1 1 1 1 1 1 0 0 	1 1 0 0 1 1 1 0 
*	1 0 1 1 1 1 0 1 	0 1 0 1 1 0 0 0 
*	1 1 1 0 1 0 0 0 	1 1 1 1 1 0 0 0 
*	0 0 1 1 1 0 0 1 	0 1 1 1 0 0 0 0 
*	0 1 0 1 0 0 0 0 	0 0 0 1 0 0 0 1 
*	1 0 1 1 1 1 1 1 	0 1 1 0 1 0 1 0 
*
* S = 02 61 A0 79 5E 8D FD 28
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_77 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[2];
	assign g_in[6] = in[6] ^ in[2] ^ in[0];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[1] = in[6] ^ in[4];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 0 0 0 0 
	*	0 1 0 0 0 1 0 0 
	*	0 0 0 0 1 1 1 1 
	*	1 0 1 0 1 0 1 1 
	*	1 0 0 1 0 1 1 1 
	*	0 0 1 1 0 1 0 1 
	*	1 0 0 0 1 0 1 1 
	*	1 1 0 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4];
	assign out[6] = ~( g_out[6] ^ g_out[2] );
	assign out[5] = ~( g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 78
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 0 0 1 0 0 	1 1 1 0 1 1 0 0 
*	1 0 1 0 0 0 0 1 	1 1 1 1 1 0 1 0 
*	1 1 1 1 1 1 0 0 	0 1 0 0 0 1 1 0 
*	0 1 0 0 0 0 0 1 	1 1 1 1 1 0 0 0 
*	1 1 1 0 1 0 0 0 	0 1 0 1 1 0 0 0 
*	1 1 0 1 0 0 0 1 	1 1 0 1 0 0 0 0 
*	0 1 0 1 0 0 0 0 	0 0 1 1 0 0 1 1 
*	1 1 1 0 1 1 1 1 	1 1 1 0 1 0 1 0 
*
* S = 02 63 A0 D9 5E D3 FD D5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_78 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[2];
	assign g_in[6] = in[7] ^ in[5] ^ in[0];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[0];
	assign g_in[1] = in[6] ^ in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 0 0 0 
	*	1 1 0 0 1 1 0 0 
	*	0 0 0 0 0 1 0 1 
	*	1 0 1 0 1 0 0 1 
	*	1 0 1 1 1 1 0 1 
	*	0 0 0 1 1 1 1 1 
	*	1 0 0 0 1 0 0 1 
	*	0 1 0 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[5] = ~( g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 79
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 1 1 0 0 0 	0 1 0 1 1 1 1 0 
*	1 1 1 0 0 0 0 0 	1 0 0 0 1 1 0 0 
*	0 1 0 1 1 1 0 1 	1 0 0 1 0 0 1 0 
*	0 1 0 1 1 0 0 1 	1 0 0 0 0 1 1 1 
*	1 0 0 0 0 1 1 0 	0 1 0 0 0 1 1 1 
*	0 0 1 1 1 1 1 0 	0 0 1 1 0 0 0 0 
*	1 0 0 0 0 0 0 1 	0 1 1 0 0 1 1 0 
*	0 1 0 1 0 1 1 1 	0 1 0 1 1 1 0 0 
*
* S = 18 BA DB C1 A5 06 8B 70
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_79 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5];
	assign g_in[5] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[4] = in[6] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[7] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[0];
	assign g_in[0] = in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 0 0 0 
	*	1 1 1 0 1 1 1 0 
	*	0 0 0 0 0 1 0 0 
	*	1 1 0 0 1 0 1 0 
	*	0 0 0 1 0 0 1 1 
	*	1 1 0 1 1 0 0 0 
	*	0 1 1 1 1 0 1 0 
	*	1 0 0 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 80
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 1 0 0 0 	1 1 1 1 1 0 0 1 
*	1 1 1 1 1 0 0 0 	0 1 0 0 1 0 0 0 
*	0 0 0 0 0 1 0 0 	0 1 1 1 0 0 0 1 
*	0 1 0 1 1 1 0 1 	0 1 0 0 1 1 1 0 
*	1 0 1 1 1 0 0 0 	1 1 0 0 1 1 1 0 
*	1 0 0 0 0 1 1 0 	0 0 1 0 0 0 0 0 
*	1 1 0 1 0 1 1 0 	1 1 0 1 1 1 0 1 
*	1 0 0 0 0 0 0 1 	1 1 1 1 1 0 0 0 
*
* S = A2 18 1A DB A3 A5 FB 8B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_80 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[5] = in[2];
	assign g_in[4] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 0 0 0 0 
	*	1 0 0 1 1 0 0 1 
	*	0 0 0 0 1 1 0 0 
	*	1 0 0 0 0 1 0 1 
	*	0 0 1 1 0 0 1 0 
	*	1 0 1 1 0 1 0 0 
	*	1 1 1 0 0 1 0 1 
	*	0 1 1 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6];
	assign out[6] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[5] = ~( g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 81
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 1 0 0 0 	0 1 0 1 1 0 1 1 
*	1 1 1 0 0 0 0 0 	1 1 0 0 1 0 0 0 
*	0 0 0 0 0 1 0 0 	1 1 0 1 0 0 1 1 
*	0 1 0 1 1 0 0 1 	1 1 0 0 0 1 1 0 
*	1 0 1 1 1 0 0 0 	0 1 0 0 0 1 1 0 
*	0 0 1 1 1 1 1 0 	0 0 1 0 0 0 0 0 
*	1 1 0 1 0 1 1 0 	0 1 1 1 0 1 1 1 
*	0 1 0 1 0 1 1 1 	0 1 0 1 1 0 0 0 
*
* S = A2 BA 1A C1 A3 06 FB 70
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_81 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5];
	assign g_in[5] = in[2];
	assign g_in[4] = in[6] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 0 0 0 
	*	1 0 1 1 1 0 1 1 
	*	0 0 0 0 0 1 0 0 
	*	1 0 0 0 1 1 1 1 
	*	0 0 0 1 0 0 1 0 
	*	1 0 0 1 1 1 0 0 
	*	0 1 1 0 1 1 1 1 
	*	1 1 0 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 82
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 1 1 0 0 0 	0 0 0 1 0 1 1 0 
*	1 1 1 0 0 0 0 0 	1 0 0 0 1 1 0 0 
*	1 0 1 0 0 1 0 1 	1 1 0 1 1 0 1 0 
*	1 0 1 1 1 0 0 1 	1 0 0 0 1 0 1 1 
*	1 0 0 0 0 1 1 0 	0 1 0 0 1 0 1 1 
*	0 0 1 1 1 1 1 0 	1 1 1 1 0 0 0 0 
*	0 0 0 0 0 1 1 1 	1 1 1 0 1 1 1 0 
*	0 1 1 0 1 0 0 1 	0 0 0 1 1 1 0 0 
*
* S = 18 BA C3 7B A5 06 2E 76
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_82 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5];
	assign g_in[5] = in[7] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[7] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 0 0 0 
	*	0 1 1 0 0 1 1 0 
	*	0 0 0 0 0 1 0 0 
	*	1 1 0 0 0 0 1 0 
	*	0 1 0 1 1 1 1 1 
	*	1 0 0 1 1 0 0 0 
	*	1 0 1 1 0 0 1 0 
	*	1 1 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 83
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 1 0 0 0 	0 0 1 1 1 1 0 1 
*	1 1 1 1 1 0 0 0 	0 1 0 0 1 0 0 0 
*	0 0 0 1 1 1 0 0 	1 0 1 1 0 1 0 1 
*	1 0 1 0 0 1 0 1 	0 1 0 0 0 1 1 0 
*	1 0 1 1 1 0 0 0 	1 1 0 0 0 1 1 0 
*	1 0 0 0 0 1 1 0 	1 0 1 0 0 0 0 0 
*	0 1 1 0 1 1 1 0 	1 0 0 1 1 0 0 1 
*	0 0 0 0 0 1 1 1 	0 0 1 1 1 0 0 0 
*
* S = A2 18 B8 C3 A3 A5 58 2E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_83 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[5] = in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 0 0 0 0 
	*	1 1 0 1 1 1 0 1 
	*	0 0 0 0 1 1 0 0 
	*	1 0 0 0 0 0 0 1 
	*	1 1 1 1 1 0 1 0 
	*	0 1 1 1 0 1 0 0 
	*	0 1 1 0 0 0 0 1 
	*	1 0 1 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 84
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 1 0 0 0 	0 0 0 1 0 1 1 1 
*	1 1 1 0 0 0 0 0 	1 1 0 0 1 0 0 0 
*	0 0 0 1 1 1 0 0 	1 0 0 1 1 1 1 1 
*	1 0 1 1 1 0 0 1 	1 1 0 0 1 1 1 0 
*	1 0 1 1 1 0 0 0 	0 1 0 0 1 1 1 0 
*	0 0 1 1 1 1 1 0 	1 0 1 0 0 0 0 0 
*	0 1 1 0 1 1 1 0 	1 0 1 1 1 0 1 1 
*	0 1 1 0 1 0 0 1 	0 0 0 1 1 0 0 0 
*
* S = A2 BA B8 7B A3 06 58 76
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_84 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5];
	assign g_in[5] = in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 0 0 0 
	*	0 1 1 1 0 1 1 1 
	*	0 0 0 0 0 1 0 0 
	*	1 0 0 0 0 0 1 1 
	*	0 1 0 1 1 0 1 0 
	*	1 1 0 1 1 1 0 0 
	*	1 1 1 0 0 0 1 1 
	*	1 0 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 85
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 1 1 0 0 0 	1 1 0 1 0 0 1 0 
*	1 1 1 0 0 0 0 0 	1 0 0 0 1 1 0 0 
*	0 1 0 0 0 1 0 1 	0 0 0 1 1 1 1 0 
*	1 0 1 0 0 0 0 1 	1 0 0 0 0 0 1 1 
*	1 0 0 0 0 1 1 0 	0 1 0 0 0 0 1 1 
*	0 0 1 1 1 1 1 0 	0 1 1 1 0 0 0 0 
*	0 0 1 1 1 0 0 1 	1 0 1 0 1 0 1 0 
*	1 1 0 1 0 0 0 1 	1 1 0 1 1 1 0 0 
*
* S = 18 BA 61 63 A5 06 8D D3
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_85 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5];
	assign g_in[5] = in[6] ^ in[2] ^ in[0];
	assign g_in[4] = in[7] ^ in[5] ^ in[0];
	assign g_in[3] = in[7] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 0 0 0 
	*	0 0 1 0 0 0 1 0 
	*	0 0 0 0 0 1 0 0 
	*	1 1 0 0 0 1 1 0 
	*	1 0 0 1 0 1 1 1 
	*	0 1 0 1 1 0 0 0 
	*	0 0 1 1 0 1 1 0 
	*	0 0 0 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7];
	assign out[6] = ~( g_out[5] ^ g_out[1] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 86
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 1 0 0 0 	1 0 1 1 0 0 0 1 
*	1 1 1 1 1 0 0 0 	0 1 0 0 1 0 0 0 
*	1 1 1 0 0 1 0 0 	0 0 1 1 1 0 0 1 
*	0 1 0 0 0 1 0 1 	0 1 0 0 0 0 1 0 
*	1 0 1 1 1 0 0 0 	1 1 0 0 0 0 1 0 
*	1 0 0 0 0 1 1 0 	1 1 1 0 0 0 0 0 
*	1 1 1 0 1 0 0 0 	0 1 0 1 0 1 0 1 
*	0 0 1 1 1 0 0 1 	1 0 1 1 1 0 0 0 
*
* S = A2 18 02 61 A3 A5 5E 8D
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_86 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[2];
	assign g_in[4] = in[6] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[3];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 0 0 0 0 
	*	0 0 0 1 0 0 0 1 
	*	0 0 0 0 1 1 0 0 
	*	1 0 0 0 1 1 0 1 
	*	0 1 1 1 1 1 1 0 
	*	1 1 1 1 0 1 0 0 
	*	0 0 1 0 1 1 0 1 
	*	0 0 1 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6];
	assign out[6] = ~( g_out[4] ^ g_out[0] );
	assign out[5] = ~( g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 87
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 1 0 0 0 	1 0 0 1 0 0 1 1 
*	1 1 1 0 0 0 0 0 	1 1 0 0 1 0 0 0 
*	1 1 1 0 0 1 0 0 	0 0 0 1 1 0 1 1 
*	1 0 1 0 0 0 0 1 	1 1 0 0 0 0 1 0 
*	1 0 1 1 1 0 0 0 	0 1 0 0 0 0 1 0 
*	0 0 1 1 1 1 1 0 	0 1 1 0 0 0 0 0 
*	1 1 1 0 1 0 0 0 	1 1 1 1 1 1 1 1 
*	1 1 0 1 0 0 0 1 	1 0 0 1 1 0 0 0 
*
* S = A2 BA 02 63 A3 06 5E D3
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_87 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[3];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 0 0 0 
	*	0 0 1 1 0 0 1 1 
	*	0 0 0 0 0 1 0 0 
	*	1 0 0 0 0 1 1 1 
	*	1 1 0 1 0 1 1 0 
	*	0 1 0 1 1 1 0 0 
	*	0 0 1 0 0 1 1 1 
	*	0 0 0 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6];
	assign out[6] = ~( g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 88
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 1 1 0 0 0 	1 0 0 1 1 0 1 0 
*	1 1 1 0 0 0 0 0 	1 0 0 0 1 1 0 0 
*	1 0 1 1 1 1 0 1 	0 1 0 1 0 1 1 0 
*	0 1 0 0 0 0 0 1 	1 0 0 0 1 1 1 1 
*	1 0 0 0 0 1 1 0 	0 1 0 0 1 1 1 1 
*	0 0 1 1 1 1 1 0 	1 0 1 1 0 0 0 0 
*	1 0 1 1 1 1 1 1 	0 0 1 0 0 0 1 0 
*	1 1 1 0 1 1 1 1 	1 0 0 1 1 1 0 0 
*
* S = 18 BA 79 D9 A5 06 28 D5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_88 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[4] = in[6] ^ in[0];
	assign g_in[3] = in[7] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 0 0 0 
	*	1 0 1 0 1 0 1 0 
	*	0 0 0 0 0 1 0 0 
	*	1 1 0 0 1 1 1 0 
	*	1 1 0 1 1 0 1 1 
	*	0 0 0 1 1 0 0 0 
	*	1 1 1 1 1 1 1 0 
	*	0 1 0 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 89
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 1 0 0 0 	0 1 1 1 0 1 0 1 
*	1 1 1 1 1 0 0 0 	0 1 0 0 1 0 0 0 
*	1 1 1 1 1 1 0 0 	1 1 1 1 1 1 0 1 
*	1 0 1 1 1 1 0 1 	0 1 0 0 1 0 1 0 
*	1 0 1 1 1 0 0 0 	1 1 0 0 1 0 1 0 
*	1 0 0 0 0 1 1 0 	0 1 1 0 0 0 0 0 
*	0 1 0 1 0 0 0 0 	0 0 0 1 0 0 0 1 
*	1 0 1 1 1 1 1 1 	0 1 1 1 1 0 0 0 
*
* S = A2 18 A0 79 A3 A5 FD 28
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_89 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[4];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 0 0 0 0 
	*	0 1 0 1 0 1 0 1 
	*	0 0 0 0 1 1 0 0 
	*	1 0 0 0 1 0 0 1 
	*	1 0 1 1 0 1 1 0 
	*	0 0 1 1 0 1 0 0 
	*	1 0 1 0 1 0 0 1 
	*	1 1 1 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6];
	assign out[6] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 90
*
* GF(2^8) Norm Basis: [L^16, L^1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 1 1 0 0 0 	1 1 0 1 1 1 1 1 
*	1 1 1 0 0 0 0 0 	1 1 0 0 1 0 0 0 
*	1 1 1 1 1 1 0 0 	0 1 0 1 0 1 1 1 
*	0 1 0 0 0 0 0 1 	1 1 0 0 1 0 1 0 
*	1 0 1 1 1 0 0 0 	0 1 0 0 1 0 1 0 
*	0 0 1 1 1 1 1 0 	1 1 1 0 0 0 0 0 
*	0 1 0 1 0 0 0 0 	0 0 1 1 0 0 1 1 
*	1 1 1 0 1 1 1 1 	1 1 0 1 1 0 0 0 
*
* S = A2 BA A0 D9 A3 06 FD D5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_90 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[4] ^ in[3];
	assign g_in[6] = in[7] ^ in[6] ^ in[5];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 0 0 0 
	*	1 1 1 1 1 1 1 1 
	*	0 0 0 0 0 1 0 0 
	*	1 0 0 0 1 0 1 1 
	*	1 0 0 1 1 1 1 0 
	*	0 0 0 1 1 1 0 0 
	*	1 0 1 0 1 0 1 1 
	*	0 1 0 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 91
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 0 0 0 1 1 	1 0 0 0 1 1 1 0 
*	1 1 1 1 1 0 0 1 	1 0 0 0 1 1 0 1 
*	0 0 0 0 1 0 0 1 	0 1 1 1 0 0 0 1 
*	1 0 1 1 1 0 1 1 	0 0 0 1 0 0 1 0 
*	0 1 0 1 1 1 1 1 	1 1 1 1 0 0 1 1 
*	1 1 1 1 0 1 1 1 	0 1 1 0 1 0 1 0 
*	1 0 1 0 1 0 1 1 	1 1 0 1 1 1 0 1 
*	0 1 1 0 1 0 1 1 	1 1 0 1 0 0 1 1 
*
* S = 6B 9D C2 C6 3B 2C 2F CB
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_91 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[1] ^ in[0];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[5] = in[3] ^ in[0];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 0 1 1 
	*	0 1 1 1 0 1 1 1 
	*	0 0 1 0 0 1 1 1 
	*	1 0 0 0 0 1 0 1 
	*	0 0 0 1 1 0 0 1 
	*	0 1 1 0 0 1 1 1 
	*	0 1 1 1 1 1 0 0 
	*	1 0 1 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 92
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 0 1 0 	0 1 0 0 1 0 0 1 
*	1 0 0 0 0 0 1 1 	0 1 0 0 1 0 1 1 
*	1 0 1 1 0 0 1 0 	1 1 1 0 0 0 1 1 
*	0 0 0 0 1 0 0 1 	0 0 1 1 0 0 0 1 
*	1 0 1 0 1 0 0 0 	1 0 1 0 0 0 1 0 
*	0 1 0 1 1 1 1 1 	1 1 0 1 0 1 0 1 
*	1 1 0 0 0 0 0 0 	1 0 1 1 1 0 1 1 
*	1 0 1 0 1 0 1 1 	1 0 1 1 0 0 1 0 
*
* S = F6 6B 04 C2 17 3B E4 2F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_92 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[1] ^ in[0];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[3];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 0 0 1 0 
	*	1 1 1 0 1 1 1 0 
	*	0 0 0 1 1 1 1 0 
	*	0 1 0 0 1 1 1 1 
	*	0 0 1 1 0 1 1 1 
	*	1 1 0 1 1 1 1 0 
	*	1 1 1 0 1 0 0 0 
	*	0 1 1 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 93
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 0 1 0 	1 1 0 0 1 0 1 1 
*	1 1 1 1 1 0 0 1 	1 1 0 0 1 0 0 1 
*	1 0 1 1 0 0 1 0 	0 1 1 0 0 0 0 1 
*	1 0 1 1 1 0 1 1 	0 0 0 1 0 0 1 1 
*	1 0 1 0 1 0 0 0 	1 0 1 0 0 0 1 0 
*	1 1 1 1 0 1 1 1 	0 1 1 1 1 1 1 1 
*	1 1 0 0 0 0 0 0 	1 0 0 1 1 0 0 1 
*	0 1 1 0 1 0 1 1 	1 0 0 1 0 0 1 0 
*
* S = F6 9D 04 C6 17 2C E4 CB
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_93 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 0 1 0 
	*	0 1 1 0 0 1 1 0 
	*	0 0 1 1 0 1 1 0 
	*	1 1 0 0 0 1 0 1 
	*	0 0 0 1 1 1 0 1 
	*	0 1 1 1 0 1 1 0 
	*	0 1 1 0 1 0 0 0 
	*	1 1 1 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 94
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 0 0 1 0 1 1 	0 1 1 1 0 1 0 0 
*	0 1 1 1 0 0 1 1 	0 1 1 1 0 0 1 0 
*	1 1 0 0 0 0 0 1 	1 0 0 0 1 0 1 1 
*	0 0 1 1 0 0 0 1 	1 0 1 1 1 1 0 1 
*	0 0 1 1 0 1 1 1 	1 1 1 1 0 1 1 0 
*	0 0 0 0 0 0 1 1 	0 0 1 1 1 0 1 0 
*	1 1 0 0 0 0 1 1 	0 0 1 0 0 0 1 0 
*	1 0 0 1 1 1 1 1 	0 0 1 0 0 1 1 0 
*
* S = 30 6F 99 34 DC DF C8 38
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_94 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[5] = in[7] ^ in[6] ^ in[0];
	assign g_in[4] = in[5] ^ in[4] ^ in[0];
	assign g_in[3] = in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw2_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 1 1 0 
	*	1 0 0 0 1 0 0 0 
	*	1 1 0 1 1 0 0 0 
	*	0 1 1 1 0 1 0 1 
	*	1 0 1 1 1 1 0 0 
	*	0 0 1 1 1 0 0 0 
	*	1 0 0 0 1 0 0 1 
	*	0 0 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[3] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 95
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 1 1 0 0 0 	1 1 1 0 1 1 0 0 
*	0 1 0 0 1 0 1 1 	1 1 1 0 0 0 0 1 
*	1 1 1 1 0 0 0 0 	0 1 0 0 0 1 1 0 
*	1 1 0 0 0 0 0 1 	0 1 1 0 1 0 1 1 
*	0 0 1 1 0 1 0 0 	1 0 1 0 1 1 0 1 
*	0 0 1 1 0 1 1 1 	0 0 1 0 0 1 0 1 
*	0 1 0 1 1 1 0 0 	0 0 0 1 0 0 0 1 
*	1 1 0 0 0 0 1 1 	0 0 0 1 1 1 0 1 
*
* S = 5F 30 AD 99 03 DC F0 C8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_95 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[4] ^ in[3];
	assign g_in[6] = in[6] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4];
	assign g_in[4] = in[7] ^ in[6] ^ in[0];
	assign g_in[3] = in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 1 0 1 
	*	0 1 0 0 0 1 0 0 
	*	1 0 1 1 0 1 0 0 
	*	1 1 1 0 1 1 1 1 
	*	0 1 1 0 1 0 0 0 
	*	0 0 1 0 0 1 0 0 
	*	0 1 0 0 0 1 1 1 
	*	0 0 1 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[2] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[2] = g_out[5] ^ g_out[2];
	assign out[1] = ~( g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 96
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 1 1 0 0 0 	0 1 1 0 0 1 0 0 
*	0 1 1 1 0 0 1 1 	0 1 1 0 0 0 1 1 
*	1 1 1 1 0 0 0 0 	1 1 0 0 1 1 1 0 
*	0 0 1 1 0 0 0 1 	1 1 1 0 1 0 0 1 
*	0 0 1 1 0 1 0 0 	1 0 1 0 0 1 1 1 
*	0 0 0 0 0 0 1 1 	0 0 1 0 1 1 1 1 
*	0 1 0 1 1 1 0 0 	0 0 1 1 0 0 1 1 
*	1 0 0 1 1 1 1 1 	0 0 1 1 0 1 1 1 
*
* S = 5F 6F AD 34 03 DF F0 38
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_96 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[4] ^ in[3];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4];
	assign g_in[4] = in[5] ^ in[4] ^ in[0];
	assign g_in[3] = in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 1 1 1 
	*	1 1 0 0 1 1 0 0 
	*	1 0 0 1 1 1 0 0 
	*	0 1 1 0 0 1 0 1 
	*	1 1 1 0 1 0 0 0 
	*	0 0 1 0 1 1 0 0 
	*	1 1 0 0 1 1 0 1 
	*	0 0 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 97
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 0 1 0 1 0 	0 0 1 0 1 0 0 1 
*	0 1 0 0 0 0 1 0 	0 0 1 0 0 1 1 0 
*	1 0 0 0 0 0 1 1 	1 1 1 0 0 1 0 1 
*	1 1 1 1 1 0 0 1 	0 1 0 1 1 0 1 0 
*	1 1 1 1 0 1 0 0 	1 1 0 0 1 1 1 1 
*	1 0 0 1 1 1 0 0 	1 0 1 1 1 0 0 0 
*	0 1 0 1 1 1 1 1 	0 1 1 0 0 1 1 0 
*	1 1 1 1 0 1 1 1 	0 1 1 0 1 1 1 1 
*
* S = A9 5B 6B 9D 14 E7 3B 2C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_97 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[3] ^ in[1];
	assign g_in[6] = in[6] ^ in[1];
	assign g_in[5] = in[7] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 1 1 1 
	*	1 1 1 0 1 1 1 0 
	*	1 0 1 0 1 1 1 0 
	*	0 0 1 0 0 1 0 0 
	*	0 1 0 1 0 1 1 1 
	*	1 0 1 1 1 1 1 0 
	*	1 1 1 0 0 0 1 1 
	*	1 1 0 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[5] ^ g_out[2];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 98
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 0 0 	0 0 0 1 0 1 1 1 
*	1 0 0 0 1 0 1 0 	0 0 0 1 1 1 0 1 
*	0 1 1 1 1 0 1 0 	1 0 0 1 1 1 1 1 
*	1 0 0 0 0 0 1 1 	1 1 1 1 0 1 0 1 
*	0 1 1 0 1 0 0 0 	1 0 0 0 1 0 1 0 
*	1 1 1 1 0 1 0 0 	0 1 1 0 0 1 0 0 
*	1 0 1 0 1 0 0 0 	1 1 0 1 1 1 0 1 
*	0 1 0 1 1 1 1 1 	1 1 0 1 1 0 1 0 
*
* S = F2 A9 F6 6B F3 14 17 3B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_98 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3];
	assign g_in[6] = in[7] ^ in[3] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[4] = in[7] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[3];
	assign g_in[0] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 0 1 0 
	*	1 0 0 1 1 0 0 1 
	*	0 1 0 1 1 0 0 1 
	*	0 0 0 1 1 1 0 0 
	*	1 1 1 1 1 1 1 0 
	*	0 1 1 0 1 0 0 1 
	*	1 0 0 1 0 0 1 0 
	*	1 0 1 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 99
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 0 0 	0 0 1 1 1 1 0 1 
*	0 1 0 0 0 0 1 0 	0 0 1 1 0 1 1 1 
*	0 1 1 1 1 0 1 0 	1 0 1 1 0 1 0 1 
*	1 1 1 1 1 0 0 1 	0 1 0 1 1 1 1 1 
*	0 1 1 0 1 0 0 0 	1 0 0 0 1 0 1 0 
*	1 0 0 1 1 1 0 0 	1 1 1 0 1 1 0 0 
*	1 0 1 0 1 0 0 0 	0 1 1 1 0 1 1 1 
*	1 1 1 1 0 1 1 1 	0 1 1 1 1 0 1 0 
*
* S = F2 5B F6 9D F3 E7 17 2C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_99 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3];
	assign g_in[6] = in[6] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[3];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 0 1 0 
	*	1 0 1 1 1 0 1 1 
	*	1 1 1 1 1 0 1 1 
	*	0 0 1 1 0 1 0 0 
	*	0 1 0 1 0 1 1 0 
	*	1 1 1 0 1 0 1 1 
	*	1 0 1 1 0 0 1 0 
	*	1 0 0 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 100
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 0 1 0 1 0 	1 0 1 0 1 1 0 1 
*	0 1 0 0 0 0 1 0 	1 0 1 0 1 1 1 0 
*	0 0 0 0 1 0 0 1 	0 1 1 0 0 0 0 1 
*	1 0 1 1 1 0 1 1 	0 0 0 1 0 0 1 0 
*	1 1 1 1 0 1 0 0 	1 1 0 0 0 0 1 1 
*	1 0 0 1 1 1 0 0 	0 1 1 1 1 0 0 0 
*	1 0 1 0 1 0 1 1 	1 1 1 0 1 1 1 0 
*	0 1 1 0 1 0 1 1 	1 1 1 0 0 0 1 1 
*
* S = A9 5B C2 C6 14 E7 2F CB
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_100 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[3] ^ in[1];
	assign g_in[6] = in[6] ^ in[1];
	assign g_in[5] = in[3] ^ in[0];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 0 1 1 
	*	0 1 1 0 0 1 1 0 
	*	0 0 1 0 0 1 1 0 
	*	1 0 1 0 0 1 0 0 
	*	0 0 0 1 1 0 1 1 
	*	0 1 1 1 0 1 1 0 
	*	0 1 1 0 1 1 1 1 
	*	1 0 0 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[2];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 101
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 0 0 	0 1 0 1 1 0 1 1 
*	1 0 0 0 1 0 1 0 	0 1 0 1 1 0 0 1 
*	1 0 1 1 0 0 1 0 	1 1 0 1 0 0 1 1 
*	0 0 0 0 1 0 0 1 	0 0 1 1 0 0 0 1 
*	0 1 1 0 1 0 0 0 	1 0 0 0 0 0 1 0 
*	1 1 1 1 0 1 0 0 	1 1 1 0 0 1 0 0 
*	1 1 0 0 0 0 0 0 	1 0 0 1 1 0 0 1 
*	1 0 1 0 1 0 1 1 	1 0 0 1 0 0 1 0 
*
* S = F2 A9 04 C2 F3 14 E4 2F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_101 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3];
	assign g_in[6] = in[7] ^ in[3] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[1] = in[7] ^ in[6];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 0 0 1 0 
	*	1 1 0 1 1 1 0 1 
	*	0 0 0 1 1 1 0 1 
	*	0 1 0 1 1 1 0 0 
	*	0 0 1 1 0 1 1 0 
	*	1 1 1 0 1 1 0 1 
	*	1 1 0 1 1 0 1 0 
	*	0 1 1 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 102
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 0 0 	1 1 1 1 1 0 0 1 
*	0 1 0 0 0 0 1 0 	1 1 1 1 1 0 1 1 
*	1 0 1 1 0 0 1 0 	0 1 1 1 0 0 0 1 
*	1 0 1 1 1 0 1 1 	0 0 0 1 0 0 1 1 
*	0 1 1 0 1 0 0 0 	1 0 0 0 0 0 1 0 
*	1 0 0 1 1 1 0 0 	0 1 1 0 1 1 0 0 
*	1 1 0 0 0 0 0 0 	1 0 1 1 1 0 1 1 
*	0 1 1 0 1 0 1 1 	1 0 1 1 0 0 1 0 
*
* S = F2 5B 04 C6 F3 E7 E4 CB
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_102 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3];
	assign g_in[6] = in[6] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 0 1 0 
	*	0 1 1 1 0 1 1 1 
	*	0 0 1 1 0 1 1 1 
	*	1 1 1 1 0 1 0 0 
	*	0 0 0 1 1 1 1 0 
	*	0 1 1 0 0 1 1 1 
	*	0 1 1 1 1 0 1 0 
	*	1 1 0 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 103
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 0 1 0 1 0 	1 1 1 0 0 0 0 1 
*	0 1 0 0 0 0 1 0 	1 1 1 0 1 0 1 0 
*	0 1 0 0 1 0 1 1 	0 0 1 0 1 1 0 1 
*	0 1 1 1 0 0 1 1 	1 1 0 1 0 1 1 0 
*	1 1 1 1 0 1 0 0 	1 1 0 0 1 0 1 1 
*	1 0 0 1 1 1 0 0 	1 1 1 1 1 0 0 0 
*	0 0 1 1 0 1 1 1 	1 0 1 0 1 0 1 0 
*	0 0 0 0 0 0 1 1 	1 0 1 0 1 0 1 1 
*
* S = A9 5B 30 6F 14 E7 DC DF
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_103 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[3] ^ in[1];
	assign g_in[6] = in[6] ^ in[1];
	assign g_in[5] = in[6] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 0 1 1 
	*	0 0 1 0 0 0 1 0 
	*	0 1 1 0 0 0 1 0 
	*	1 1 1 0 0 1 0 0 
	*	1 1 0 1 0 0 1 1 
	*	1 1 1 1 0 0 1 0 
	*	0 0 1 0 0 1 1 1 
	*	0 1 0 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[5] ^ g_out[1] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[1] = ~( g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 104
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 0 0 	1 0 0 1 0 0 1 1 
*	1 0 0 0 1 0 1 0 	1 0 0 1 0 1 0 1 
*	0 0 1 1 1 0 0 0 	0 0 0 1 1 0 1 1 
*	0 1 0 0 1 0 1 1 	1 0 1 1 1 1 0 1 
*	0 1 1 0 1 0 0 0 	1 0 0 0 0 1 1 0 
*	1 1 1 1 0 1 0 0 	1 0 1 0 0 1 0 0 
*	0 0 1 1 0 1 0 0 	0 1 0 1 0 1 0 1 
*	0 0 1 1 0 1 1 1 	0 1 0 1 0 1 1 0 
*
* S = F2 A9 5F 30 F3 14 03 DC
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_104 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3];
	assign g_in[6] = in[7] ^ in[3] ^ in[1];
	assign g_in[5] = in[5] ^ in[4] ^ in[3];
	assign g_in[4] = in[6] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[1] = in[5] ^ in[4] ^ in[2];
	assign g_in[0] = in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 0 1 1 0 
	*	0 0 0 1 0 0 0 1 
	*	1 1 0 1 0 0 0 1 
	*	1 0 0 1 1 1 0 0 
	*	1 0 1 1 0 0 1 0 
	*	1 0 1 0 0 0 0 1 
	*	0 0 0 1 1 1 1 0 
	*	1 1 1 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[4] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 105
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 0 0 	1 0 1 1 0 0 0 1 
*	0 1 0 0 0 0 1 0 	1 0 1 1 1 1 1 1 
*	0 0 1 1 1 0 0 0 	0 0 1 1 1 0 0 1 
*	0 1 1 1 0 0 1 1 	1 0 0 1 0 1 1 1 
*	0 1 1 0 1 0 0 0 	1 0 0 0 1 1 1 0 
*	1 0 0 1 1 1 0 0 	1 0 1 0 1 1 0 0 
*	0 0 1 1 0 1 0 0 	1 1 1 1 1 1 1 1 
*	0 0 0 0 0 0 1 1 	1 1 1 1 1 1 1 0 
*
* S = F2 5B 5F 6F F3 E7 03 DF
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_105 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3];
	assign g_in[6] = in[6] ^ in[1];
	assign g_in[5] = in[5] ^ in[4] ^ in[3];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[5] ^ in[4] ^ in[2];
	assign g_in[0] = in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 1 1 0 
	*	0 0 1 1 0 0 1 1 
	*	0 1 1 1 0 0 1 1 
	*	1 0 1 1 0 1 0 0 
	*	1 0 0 1 0 0 1 0 
	*	1 0 1 0 0 0 1 1 
	*	0 0 1 1 0 1 1 0 
	*	0 1 0 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 106
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 0 0 0 1 0 1 0 	0 1 1 0 0 1 0 1 
*	0 1 0 0 0 0 1 0 	0 1 1 0 0 0 1 0 
*	1 1 0 0 0 0 0 1 	1 0 1 0 1 0 0 1 
*	0 0 1 1 0 0 0 1 	1 0 0 1 1 1 1 0 
*	1 1 1 1 0 1 0 0 	1 1 0 0 0 1 1 1 
*	1 0 0 1 1 1 0 0 	0 0 1 1 1 0 0 0 
*	1 1 0 0 0 0 1 1 	0 0 1 0 0 0 1 0 
*	1 0 0 1 1 1 1 1 	0 0 1 0 0 1 1 1 
*
* S = A9 5B 99 34 14 E7 C8 38
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_106 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[3] ^ in[1];
	assign g_in[6] = in[6] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[0];
	assign g_in[4] = in[5] ^ in[4] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 1 1 1 
	*	1 0 1 0 1 0 1 0 
	*	1 1 1 0 1 0 1 0 
	*	0 1 1 0 0 1 0 0 
	*	1 0 0 1 1 1 1 1 
	*	0 0 1 1 1 0 1 0 
	*	1 0 1 0 1 0 1 1 
	*	0 0 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 107
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 0 0 	1 1 0 1 1 1 1 1 
*	1 0 0 0 1 0 1 0 	1 1 0 1 0 0 0 1 
*	1 1 1 1 0 0 0 0 	0 1 0 1 0 1 1 1 
*	1 1 0 0 0 0 0 1 	0 1 1 1 1 0 0 1 
*	0 1 1 0 1 0 0 0 	1 0 0 0 1 1 1 0 
*	1 1 1 1 0 1 0 0 	0 0 1 0 0 1 0 0 
*	0 1 0 1 1 1 0 0 	0 0 0 1 0 0 0 1 
*	1 1 0 0 0 0 1 1 	0 0 0 1 1 1 1 0 
*
* S = F2 A9 AD 99 F3 14 F0 C8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_107 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3];
	assign g_in[6] = in[7] ^ in[3] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4];
	assign g_in[4] = in[7] ^ in[6] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 1 1 0 
	*	0 1 0 1 0 1 0 1 
	*	1 0 0 1 0 1 0 1 
	*	1 1 0 1 1 1 0 0 
	*	0 1 1 1 1 0 1 0 
	*	0 0 1 0 0 1 0 1 
	*	0 1 0 1 0 1 1 0 
	*	0 0 1 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 108
*
* GF(2^8) Norm Basis: [L^32, L^2]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 0 0 	0 1 1 1 0 1 0 1 
*	0 1 0 0 0 0 1 0 	0 1 1 1 0 0 1 1 
*	1 1 1 1 0 0 0 0 	1 1 1 1 1 1 0 1 
*	0 0 1 1 0 0 0 1 	1 1 0 1 1 0 1 1 
*	0 1 1 0 1 0 0 0 	1 0 0 0 0 1 1 0 
*	1 0 0 1 1 1 0 0 	0 0 1 0 1 1 0 0 
*	0 1 0 1 1 1 0 0 	0 0 1 1 0 0 1 1 
*	1 0 0 1 1 1 1 1 	0 0 1 1 0 1 1 0 
*
* S = F2 5B AD 34 F3 E7 F0 38
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_108 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3];
	assign g_in[6] = in[6] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[4];
	assign g_in[4] = in[5] ^ in[4] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 1 1 0 
	*	1 1 1 1 1 1 1 1 
	*	1 0 1 1 1 1 1 1 
	*	0 1 1 1 0 1 0 0 
	*	1 1 0 1 1 0 1 0 
	*	0 0 1 0 1 1 1 1 
	*	1 1 1 1 1 1 1 0 
	*	0 0 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 109
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 0 0 0 1 	0 0 0 0 0 1 1 0 
*	0 0 1 0 1 0 0 1 	1 1 1 0 1 0 1 1 
*	0 0 0 0 0 1 0 1 	1 1 1 1 1 0 0 1 
*	1 1 0 0 0 1 1 1 	1 1 1 1 1 1 0 0 
*	1 1 1 1 1 1 0 1 	1 1 0 0 0 0 0 0 
*	0 0 1 0 0 1 1 1 	0 1 0 1 1 0 0 1 
*	1 0 1 0 0 1 1 1 	1 1 0 1 1 1 0 1 
*	0 0 0 1 0 1 1 1 	0 1 1 1 1 0 0 1 
*
* S = 67 C0 92 77 37 71 7F 7A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_109 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[0];
	assign g_in[6] = in[5] ^ in[3] ^ in[0];
	assign g_in[5] = in[2] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[2] = in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 0 0 0 
	*	0 1 1 1 0 1 1 1 
	*	0 1 0 0 0 0 0 1 
	*	1 1 0 0 0 0 0 1 
	*	0 0 1 1 1 0 1 1 
	*	0 0 0 1 0 0 0 0 
	*	1 0 1 1 0 0 0 0 
	*	1 0 0 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[4];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 110
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 0 0 0 	0 0 0 0 1 1 0 1 
*	0 0 1 0 0 0 0 1 	1 0 0 1 0 1 1 0 
*	1 1 0 0 0 0 1 0 	1 0 1 0 0 1 1 1 
*	0 0 0 0 0 1 0 1 	1 0 1 0 1 0 0 0 
*	1 1 0 1 1 0 1 0 	1 0 0 0 0 0 0 0 
*	1 1 1 1 1 1 0 1 	1 1 1 1 0 1 1 1 
*	1 0 1 1 0 0 0 0 	1 0 1 1 1 0 1 1 
*	1 0 1 0 0 1 1 1 	1 1 1 0 0 1 1 1 
*
* S = A7 67 E5 92 46 37 05 7F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_110 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3];
	assign g_in[6] = in[5] ^ in[0];
	assign g_in[5] = in[7] ^ in[6] ^ in[1];
	assign g_in[4] = in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4];
	assign g_in[0] = in[7] ^ in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 0 1 0 0 
	*	1 1 1 0 1 1 1 0 
	*	1 1 0 0 0 0 1 1 
	*	1 0 0 0 0 0 1 1 
	*	0 0 1 0 0 1 1 0 
	*	0 0 1 1 0 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	0 1 1 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[4];
	assign out[1] = ~( g_out[6] ^ g_out[5] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 111
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 0 0 0 	0 0 0 0 0 1 1 1 
*	0 0 1 0 1 0 0 1 	1 0 1 1 1 1 1 0 
*	1 1 0 0 0 0 1 0 	1 0 1 0 1 1 0 1 
*	1 1 0 0 0 1 1 1 	1 0 1 0 1 0 0 0 
*	1 1 0 1 1 0 1 0 	1 0 0 0 0 0 0 0 
*	0 0 1 0 0 1 1 1 	0 1 0 1 1 1 0 1 
*	1 0 1 1 0 0 0 0 	1 0 0 1 1 0 0 1 
*	0 0 0 1 0 1 1 1 	0 1 1 0 1 1 0 1 
*
* S = A7 C0 E5 77 46 71 05 7A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_111 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3];
	assign g_in[6] = in[5] ^ in[3] ^ in[0];
	assign g_in[5] = in[7] ^ in[6] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4];
	assign g_in[0] = in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 1 0 0 
	*	0 1 1 0 0 1 1 0 
	*	0 1 0 0 0 0 0 1 
	*	1 0 0 0 0 0 0 1 
	*	0 0 1 0 1 1 1 0 
	*	0 0 0 1 0 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	1 1 0 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[6] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[4];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 112
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 0 1 0 1 1 	0 0 0 0 0 0 1 1 
*	0 0 0 0 1 1 0 1 	0 1 0 0 0 0 0 1 
*	1 1 0 0 1 1 1 1 	1 1 1 1 1 1 0 0 
*	1 1 1 0 0 0 1 1 	1 1 1 1 1 0 0 1 
*	1 0 0 1 0 1 1 1 	1 0 0 1 0 0 0 0 
*	0 1 1 1 1 1 0 1 	0 1 0 1 1 1 0 0 
*	1 1 0 0 1 1 0 1 	0 0 1 0 0 0 1 0 
*	0 1 0 0 1 1 0 1 	1 0 0 0 1 1 0 0 
*
* S = D0 82 25 35 3C 32 74 39
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_112 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[6] = in[3] ^ in[2] ^ in[0];
	assign g_in[5] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw2_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 1 1 1 
	*	1 0 0 0 1 0 0 0 
	*	1 1 1 0 1 0 1 1 
	*	1 0 0 1 1 0 1 1 
	*	0 1 1 0 0 0 0 1 
	*	1 0 1 1 0 0 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 1 0 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[3] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4];
	assign out[1] = ~( g_out[4] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 113
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 0 0 1 1 0 	0 0 0 0 0 0 1 0 
*	1 1 1 0 1 0 1 1 	1 1 0 0 0 0 1 1 
*	0 0 1 0 1 1 0 0 	1 0 1 0 1 0 0 0 
*	1 1 0 0 1 1 1 1 	1 0 1 0 0 1 1 1 
*	1 1 1 0 1 0 1 0 	0 1 1 1 0 0 0 0 
*	1 0 0 1 0 1 1 1 	1 1 1 1 1 0 0 0 
*	1 0 0 0 0 0 0 0 	0 0 0 1 0 0 0 1 
*	1 1 0 0 1 1 0 1 	0 1 0 0 1 0 0 0 
*
* S = 52 D0 10 25 0E 3C 4D 74
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_113 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[5] = in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 1 1 0 
	*	0 1 0 0 0 1 0 0 
	*	1 0 0 1 0 1 1 0 
	*	0 1 1 1 0 1 1 0 
	*	1 1 0 1 0 0 1 1 
	*	0 1 1 0 0 0 0 0 
	*	0 0 1 1 0 0 0 0 
	*	1 0 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[2] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5];
	assign out[1] = ~( g_out[5] ^ g_out[4] );
	assign out[0] = ~( g_out[7] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 114
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 0 0 1 1 0 	0 0 0 0 0 0 1 0 
*	0 0 0 0 1 1 0 1 	0 1 0 0 0 0 0 1 
*	0 0 1 0 1 1 0 0 	1 0 1 0 1 0 0 0 
*	1 1 1 0 0 0 1 1 	1 0 1 0 1 1 0 1 
*	1 1 1 0 1 0 1 0 	1 1 0 1 0 0 0 0 
*	0 1 1 1 1 1 0 1 	0 1 0 1 1 0 0 0 
*	1 0 0 0 0 0 0 0 	0 0 1 1 0 0 1 1 
*	0 1 0 0 1 1 0 1 	1 1 0 0 1 0 0 0 
*
* S = 52 82 10 35 0E 32 4D 39
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_114 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[0];
	assign g_in[5] = in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[7];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 1 1 0 
	*	1 1 0 0 1 1 0 0 
	*	1 0 1 1 1 1 1 0 
	*	1 1 0 1 1 1 1 0 
	*	0 1 1 1 0 0 0 1 
	*	1 1 1 0 0 0 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 0 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5];
	assign out[1] = ~( g_out[4] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 115
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 0 1 0 0 	0 0 0 0 1 0 1 1 
*	1 1 1 0 1 1 1 0 	1 0 0 1 1 1 0 1 
*	0 0 1 0 0 0 0 1 	1 1 0 0 0 1 1 1 
*	0 0 1 0 1 0 0 1 	1 1 0 0 0 0 1 1 
*	0 1 0 1 1 0 1 0 	0 0 1 1 0 0 0 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 0 1 1 1 
*	1 1 1 1 1 1 0 1 	0 1 1 0 0 1 1 0 
*	0 0 1 0 0 1 1 1 	1 1 1 0 0 1 1 1 
*
* S = F5 B7 67 C0 48 0B 37 71
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_115 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[2];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[5] ^ in[0];
	assign g_in[4] = in[5] ^ in[3] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 0 1 0 
	*	1 1 1 0 1 1 1 0 
	*	0 0 0 1 0 1 0 1 
	*	0 0 1 1 0 1 0 1 
	*	1 1 1 1 1 1 0 1 
	*	0 1 0 1 0 0 0 0 
	*	1 1 0 1 0 0 0 0 
	*	0 1 1 1 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 116
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 1 0 	0 0 0 0 0 1 1 0 
*	0 0 1 0 0 1 0 0 	0 1 1 1 1 0 1 1 
*	0 0 0 0 1 0 0 0 	1 0 0 0 1 1 1 0 
*	0 0 1 0 0 0 0 1 	1 0 0 0 0 0 1 0 
*	0 1 1 0 1 0 1 0 	0 0 1 0 0 0 0 0 
*	0 1 0 1 1 0 1 0 	1 1 0 0 1 1 1 0 
*	1 1 0 1 1 0 1 0 	1 1 0 1 1 1 0 1 
*	1 1 1 1 1 1 0 1 	1 0 0 1 1 1 1 0 
*
* S = 42 F5 A7 67 43 48 46 37
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_116 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[2];
	assign g_in[5] = in[3];
	assign g_in[4] = in[5] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 0 0 0 1 
	*	1 0 0 1 1 0 0 1 
	*	0 0 1 1 1 1 1 1 
	*	0 0 1 0 1 1 1 1 
	*	1 0 1 0 1 0 1 1 
	*	1 1 1 1 0 0 0 0 
	*	1 0 1 1 0 0 0 0 
	*	1 1 1 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 117
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 1 0 	0 0 0 0 1 1 1 0 
*	1 1 1 0 1 1 1 0 	1 1 0 1 1 0 0 1 
*	0 0 0 0 1 0 0 0 	1 0 0 0 0 1 1 0 
*	0 0 1 0 1 0 0 1 	1 0 0 0 0 0 1 0 
*	0 1 1 0 1 0 1 0 	0 0 1 0 0 0 0 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 0 1 1 0 
*	1 1 0 1 1 0 1 0 	0 1 1 1 0 1 1 1 
*	0 0 1 0 0 1 1 1 	1 0 1 1 0 1 1 0 
*
* S = 42 B7 A7 C0 43 0B 46 71
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_117 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3];
	assign g_in[4] = in[5] ^ in[3] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 0 1 1 
	*	1 0 1 1 1 0 1 1 
	*	0 0 0 1 0 1 0 1 
	*	0 0 1 0 0 1 0 1 
	*	1 0 1 0 1 0 0 1 
	*	0 1 0 1 0 0 0 0 
	*	1 0 0 1 0 0 0 0 
	*	0 1 1 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4];
	assign out[1] = ~( g_out[7] ^ g_out[4] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 118
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 0 1 0 0 	0 0 0 0 0 1 1 1 
*	1 1 1 0 1 1 1 0 	1 1 0 1 1 0 0 1 
*	0 0 0 0 0 1 0 1 	1 1 0 0 1 0 1 1 
*	1 1 0 0 0 1 1 1 	1 1 0 0 1 1 1 1 
*	0 1 0 1 1 0 1 0 	1 1 1 1 0 0 0 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 1 0 1 1 
*	1 0 1 0 0 1 1 1 	1 1 1 0 1 1 1 0 
*	0 0 0 1 0 1 1 1 	0 1 1 0 1 0 1 1 
*
* S = F5 B7 92 77 48 0B 7F 7A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_118 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[2];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[2] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 0 1 0 
	*	0 1 1 0 0 1 1 0 
	*	0 1 0 1 0 0 0 1 
	*	1 1 1 1 0 0 0 1 
	*	0 0 1 1 1 0 0 1 
	*	0 0 0 1 0 0 0 0 
	*	1 0 0 1 0 0 0 0 
	*	1 0 1 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[4];
	assign out[1] = ~( g_out[7] ^ g_out[4] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 119
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 1 0 	0 0 0 0 1 1 1 0 
*	0 0 1 0 0 1 0 0 	1 0 1 1 0 1 1 1 
*	1 1 0 0 0 0 1 0 	1 0 0 0 0 1 1 0 
*	0 0 0 0 0 1 0 1 	1 0 0 0 1 0 1 0 
*	0 1 1 0 1 0 1 0 	1 0 1 0 0 0 0 0 
*	0 1 0 1 1 0 1 0 	1 1 0 0 0 1 1 0 
*	1 0 1 1 0 0 0 0 	1 0 0 1 1 0 0 1 
*	1 0 1 0 0 1 1 1 	1 1 0 1 0 1 1 0 
*
* S = 42 F5 E5 92 43 48 05 7F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_119 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[2];
	assign g_in[5] = in[7] ^ in[6] ^ in[1];
	assign g_in[4] = in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[4];
	assign g_in[0] = in[7] ^ in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 0 1 0 1 
	*	1 1 0 1 1 1 0 1 
	*	1 1 1 1 0 0 1 1 
	*	1 0 1 0 0 0 1 1 
	*	0 0 1 0 0 1 1 1 
	*	0 0 1 1 0 0 0 0 
	*	0 1 1 1 0 0 0 0 
	*	0 1 1 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 120
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 1 0 	0 0 0 0 0 1 1 0 
*	1 1 1 0 1 1 1 0 	1 0 0 1 1 1 0 1 
*	1 1 0 0 0 0 1 0 	1 0 0 0 1 1 1 0 
*	1 1 0 0 0 1 1 1 	1 0 0 0 1 0 1 0 
*	0 1 1 0 1 0 1 0 	1 0 1 0 0 0 0 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 1 1 1 0 
*	1 0 1 1 0 0 0 0 	1 0 1 1 1 0 1 1 
*	0 0 0 1 0 1 1 1 	0 1 1 1 1 1 1 0 
*
* S = 42 B7 E5 77 43 0B 05 7A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_120 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[5] ^ in[4];
	assign g_in[0] = in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 1 1 1 
	*	0 1 1 1 0 1 1 1 
	*	0 1 0 1 0 0 0 1 
	*	1 0 1 0 0 0 0 1 
	*	0 0 1 0 1 1 0 1 
	*	0 0 0 1 0 0 0 0 
	*	1 1 0 1 0 0 0 0 
	*	1 1 1 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[4];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 121
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 0 1 0 0 	0 0 0 0 1 1 1 1 
*	1 1 1 0 1 1 1 0 	0 0 0 1 0 1 0 1 
*	1 1 1 0 1 0 1 1 	1 1 0 0 0 0 1 1 
*	0 0 0 0 1 1 0 1 	1 1 0 0 0 1 1 1 
*	0 1 0 1 1 0 1 0 	0 1 1 1 0 0 0 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 0 0 1 1 
*	1 0 0 1 0 1 1 1 	1 0 1 0 1 0 1 0 
*	0 1 1 1 1 1 0 1 	0 0 1 0 0 0 1 1 
*
* S = F5 B7 D0 82 48 0B 3C 32
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_121 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[2];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[4] = in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 1 1 0 
	*	0 0 1 0 0 0 1 0 
	*	1 0 0 1 1 1 0 1 
	*	0 1 1 1 1 1 0 1 
	*	1 0 1 1 0 1 0 1 
	*	1 1 0 1 0 0 0 0 
	*	0 1 0 1 0 0 0 0 
	*	0 0 1 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[5] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4];
	assign out[1] = ~( g_out[6] ^ g_out[4] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 122
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 1 0 	0 0 0 0 1 0 1 0 
*	0 0 1 0 0 1 0 0 	0 0 1 1 1 1 1 1 
*	1 1 1 0 0 1 1 0 	1 0 0 0 0 0 1 0 
*	1 1 1 0 1 0 1 1 	1 0 0 0 1 1 1 0 
*	0 1 1 0 1 0 1 0 	1 1 1 0 0 0 0 0 
*	0 1 0 1 1 0 1 0 	1 1 0 0 0 0 1 0 
*	1 1 1 0 1 0 1 0 	0 1 0 1 0 1 0 1 
*	1 0 0 1 0 1 1 1 	0 0 0 1 0 0 1 0 
*
* S = 42 F5 52 D0 43 48 0E 3C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_122 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[2];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 0 0 1 
	*	0 0 0 1 0 0 0 1 
	*	0 1 1 1 1 0 1 1 
	*	1 1 1 0 1 0 1 1 
	*	0 1 1 0 1 1 1 1 
	*	1 0 1 1 0 0 0 0 
	*	1 1 1 1 0 0 0 0 
	*	0 0 1 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[6] = ~( g_out[4] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[0] = ~( g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 123
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 1 0 	0 0 0 0 1 0 1 0 
*	1 1 1 0 1 1 1 0 	0 0 0 1 0 1 0 1 
*	1 1 1 0 0 1 1 0 	1 0 0 0 0 0 1 0 
*	0 0 0 0 1 1 0 1 	1 0 0 0 0 1 1 0 
*	0 1 1 0 1 0 1 0 	0 1 1 0 0 0 0 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 0 0 1 0 
*	1 1 1 0 1 0 1 0 	1 1 1 1 1 1 1 1 
*	0 1 1 1 1 1 0 1 	0 0 1 1 0 0 1 0 
*
* S = 42 B7 52 82 43 0B 0E 32
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_123 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 0 1 1 
	*	0 0 1 1 0 0 1 1 
	*	1 1 0 1 1 0 0 1 
	*	0 1 1 0 1 0 0 1 
	*	1 1 1 0 0 1 0 1 
	*	1 0 0 1 0 0 0 0 
	*	0 1 0 1 0 0 0 0 
	*	0 0 1 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4];
	assign out[1] = ~( g_out[6] ^ g_out[4] );
	assign out[0] = ~( g_out[5] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 124
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 0 1 0 0 	0 0 0 0 0 0 1 1 
*	1 1 1 0 1 1 1 0 	0 1 0 1 0 0 0 1 
*	1 1 0 0 1 1 1 1 	1 1 0 0 1 1 1 1 
*	1 1 1 0 0 0 1 1 	1 1 0 0 1 0 1 1 
*	0 1 0 1 1 0 1 0 	1 0 1 1 0 0 0 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 1 1 1 1 
*	1 1 0 0 1 1 0 1 	0 0 1 0 0 0 1 0 
*	0 1 0 0 1 1 0 1 	1 0 1 0 1 1 1 1 
*
* S = F5 B7 25 35 48 0B 74 39
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_124 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[2];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 1 1 0 
	*	1 0 1 0 1 0 1 0 
	*	1 1 0 1 1 0 0 1 
	*	1 0 1 1 1 0 0 1 
	*	0 1 1 1 0 0 0 1 
	*	1 0 0 1 0 0 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 1 1 1 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4];
	assign out[1] = ~( g_out[4] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 125
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 1 0 	0 0 0 0 0 0 1 0 
*	0 0 1 0 0 1 0 0 	1 1 1 1 0 0 1 1 
*	0 0 1 0 1 1 0 0 	1 0 0 0 1 0 1 0 
*	1 1 0 0 1 1 1 1 	1 0 0 0 0 1 1 0 
*	0 1 1 0 1 0 1 0 	0 1 1 0 0 0 0 0 
*	0 1 0 1 1 0 1 0 	1 1 0 0 1 0 1 0 
*	1 0 0 0 0 0 0 0 	0 0 0 1 0 0 0 1 
*	1 1 0 0 1 1 0 1 	0 1 0 1 1 0 1 0 
*
* S = 42 F5 10 25 43 48 4D 74
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_125 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[6] = in[5] ^ in[2];
	assign g_in[5] = in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 1 0 1 
	*	0 1 0 1 0 1 0 1 
	*	1 0 1 1 0 1 1 1 
	*	0 1 1 0 0 1 1 1 
	*	1 1 1 0 0 0 1 1 
	*	0 1 1 1 0 0 0 0 
	*	0 0 1 1 0 0 0 0 
	*	1 0 1 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4];
	assign out[1] = ~( g_out[5] ^ g_out[4] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 126
*
* GF(2^8) Norm Basis: [L^64, L^4]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 1 0 1 0 	0 0 0 0 0 0 1 0 
*	1 1 1 0 1 1 1 0 	0 1 0 1 0 0 0 1 
*	0 0 1 0 1 1 0 0 	1 0 0 0 1 0 1 0 
*	1 1 1 0 0 0 1 1 	1 0 0 0 1 1 1 0 
*	0 1 1 0 1 0 1 0 	1 1 1 0 0 0 0 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 1 0 1 0 
*	1 0 0 0 0 0 0 0 	0 0 1 1 0 0 1 1 
*	0 1 0 0 1 1 0 1 	1 1 1 1 1 0 1 0 
*
* S = 42 B7 10 35 43 0B 4D 39
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_126 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 1 1 1 
	*	1 1 1 1 1 1 1 1 
	*	1 0 0 1 1 1 0 1 
	*	1 1 1 0 1 1 0 1 
	*	0 1 1 0 0 0 0 1 
	*	1 1 0 1 0 0 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 0 1 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4];
	assign out[1] = ~( g_out[4] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 127
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 1 0 1 1 0 1 	0 0 1 0 0 1 0 0 
*	0 1 0 1 0 1 0 1 	0 1 1 0 0 0 1 1 
*	1 1 0 1 1 0 1 1 	1 1 0 1 1 0 1 1 
*	0 1 1 0 0 1 1 1 	0 1 0 1 0 1 1 0 
*	1 1 1 1 0 0 0 1 	0 0 1 0 1 1 1 0 
*	0 1 0 1 1 0 1 1 	1 0 1 1 0 1 1 1 
*	0 1 1 1 1 0 0 1 	1 1 0 1 1 1 0 1 
*	1 0 1 1 0 1 1 1 	1 1 0 0 0 0 1 0 
*
* S = 66 7D 9E 2A 36 CC 73 27
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_127 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[6] = in[6] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[4] = in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 1 0 0 
	*	0 1 1 1 0 1 1 1 
	*	1 1 0 0 1 0 0 1 
	*	1 1 0 1 0 0 0 0 
	*	1 0 1 0 0 0 1 0 
	*	1 1 1 0 1 1 1 1 
	*	1 0 0 0 0 0 1 1 
	*	0 0 0 0 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[3] );

endmodule





/*****************************************************
* S-Box # 128
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 0 0 0 	0 0 0 1 1 1 0 0 
*	0 0 1 0 1 1 0 1 	1 1 0 1 0 0 1 0 
*	1 0 1 1 1 1 0 0 	1 0 1 1 0 1 1 0 
*	1 1 0 1 1 0 1 1 	1 1 1 1 1 1 0 1 
*	1 0 1 0 1 0 1 0 	0 0 0 1 1 0 0 1 
*	1 1 1 1 0 0 0 1 	0 1 1 0 1 1 1 0 
*	1 1 0 0 1 1 1 0 	1 0 1 1 1 0 1 1 
*	0 1 1 1 1 0 0 1 	1 0 0 0 0 0 0 1 
*
* S = 1B 66 B4 9E FA 36 54 73
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_128 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[6] = in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 1 0 0 
	*	1 1 1 0 1 1 1 0 
	*	1 0 0 0 0 1 1 1 
	*	1 0 1 1 0 0 0 0 
	*	0 1 0 1 0 0 0 1 
	*	1 0 0 1 1 0 1 0 
	*	0 1 0 0 0 0 1 0 
	*	0 0 0 0 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[1] );
	assign out[0] = ~( g_out[2] );

endmodule





/*****************************************************
* S-Box # 129
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 0 1 1 0 1 1 	0 0 1 1 0 1 0 0 
*	0 1 1 1 0 1 1 0 	0 1 1 1 0 0 1 0 
*	1 0 1 1 1 1 0 0 	1 0 0 1 1 1 1 0 
*	1 0 1 0 1 0 1 1 	0 1 0 1 0 1 1 1 
*	0 1 1 0 0 1 1 0 	0 0 1 1 1 0 1 1 
*	1 0 0 1 0 1 1 1 	1 1 1 0 0 1 1 0 
*	1 1 1 0 1 1 0 1 	1 0 0 1 1 0 0 1 
*	0 1 1 1 1 0 1 1 	1 0 0 0 0 0 1 1 
*
* S = 1B 7D B4 2A FA CC 54 27
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_129 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 1 0 0 
	*	0 1 1 0 0 1 1 0 
	*	1 0 0 0 1 1 0 1 
	*	1 0 0 1 0 0 0 0 
	*	1 1 1 1 0 0 1 1 
	*	1 0 1 1 1 0 1 0 
	*	1 1 0 0 0 0 1 0 
	*	0 0 0 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[1] );
	assign out[0] = ~( g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 130
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 0 1 0 0 1 	1 1 0 1 1 1 1 0 
*	1 0 1 0 0 0 1 1 	0 0 1 1 0 1 1 0 
*	0 0 0 1 1 1 1 1 	0 0 1 0 0 0 0 1 
*	1 0 0 1 0 0 0 1 	0 1 0 1 0 0 1 1 
*	1 0 0 1 0 1 0 1 	1 1 0 1 0 1 0 0 
*	1 1 0 1 0 0 1 1 	0 0 0 1 1 0 0 0 
*	0 0 0 1 1 1 0 1 	0 0 1 0 0 0 1 0 
*	0 0 1 1 1 1 1 1 	1 0 0 1 1 1 0 1 
*
* S = 31 D2 C9 85 DD 62 98 89
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_130 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[0];
	assign g_in[6] = in[7] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[5] = in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[4] ^ in[0];
	assign g_in[3] = in[7] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[1] = in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_NormNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 1 1 0 
	*	1 0 0 0 1 0 0 0 
	*	1 0 0 1 1 1 0 0 
	*	0 0 1 0 0 0 0 0 
	*	1 0 1 0 1 1 0 1 
	*	0 1 0 0 1 1 1 1 
	*	0 1 1 1 0 1 1 0 
	*	0 0 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[6] = ~( g_out[7] ^ g_out[3] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[5];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 131
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 0 0 1 0 1 0 	1 0 1 1 1 0 0 1 
*	1 1 1 0 1 0 0 1 	0 0 1 0 1 1 0 1 
*	1 0 0 0 1 1 1 0 	0 0 0 1 0 0 1 1 
*	0 0 0 1 1 1 1 1 	1 1 1 1 0 0 1 0 
*	0 1 0 0 0 1 1 0 	1 0 1 1 1 1 0 0 
*	1 0 0 1 0 1 0 1 	0 0 1 1 0 1 0 0 
*	0 0 1 0 0 0 1 0 	0 0 0 1 0 0 0 1 
*	0 0 0 1 1 1 0 1 	0 1 1 1 1 0 1 1 
*
* S = E3 31 4C C9 BF DD 11 98
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_131 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[0];
	assign g_in[5] = in[7] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[1] = in[5] ^ in[1];
	assign g_in[0] = in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 0 0 1 
	*	0 1 0 0 0 1 0 0 
	*	0 1 1 1 1 0 0 0 
	*	0 0 0 1 0 0 0 0 
	*	0 1 0 1 1 0 1 1 
	*	1 1 0 0 1 0 1 0 
	*	1 1 1 0 1 1 0 1 
	*	0 0 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[2] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] );
	assign out[4] = g_out[4];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 132
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 1 0 0 1 0 1 0 	1 0 0 1 1 0 1 1 
*	1 0 1 0 0 0 1 1 	0 0 1 0 0 1 1 1 
*	1 0 0 0 1 1 1 0 	0 0 1 1 0 0 0 1 
*	1 0 0 1 0 0 0 1 	0 1 0 1 0 0 1 0 
*	0 1 0 0 0 1 1 0 	1 0 0 1 0 1 0 0 
*	1 1 0 1 0 0 1 1 	0 0 0 1 1 1 0 0 
*	0 0 1 0 0 0 1 0 	0 0 1 1 0 0 1 1 
*	0 0 1 1 1 1 1 1 	1 1 0 1 1 0 0 1 
*
* S = E3 D2 4C 85 BF 62 11 89
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_132 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[3] ^ in[1];
	assign g_in[6] = in[7] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[5] = in[7] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[4] ^ in[0];
	assign g_in[3] = in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[1] = in[5] ^ in[1];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 0 1 1 
	*	1 1 0 0 1 1 0 0 
	*	1 1 0 1 1 0 0 0 
	*	0 0 1 1 0 0 0 0 
	*	1 1 1 1 1 0 0 1 
	*	0 1 0 0 1 0 1 0 
	*	0 1 1 0 0 1 1 1 
	*	0 0 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] );
	assign out[4] = g_out[5] ^ g_out[4];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 133
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 1 0 1 1 0 	1 0 1 0 0 0 0 1 
*	0 0 1 1 0 0 1 0 	1 0 1 1 1 1 1 1 
*	0 0 1 0 1 1 0 1 	0 1 1 0 1 1 0 1 
*	0 1 0 1 0 1 0 1 	0 1 0 0 1 0 1 1 
*	1 0 0 0 1 0 0 0 	1 0 1 0 1 0 0 1 
*	1 1 1 0 1 1 0 0 	1 1 0 1 1 1 1 0 
*	1 1 1 1 0 0 0 1 	0 1 1 0 0 1 1 0 
*	0 1 0 1 1 0 1 1 	0 0 1 1 1 0 1 0 
*
* S = F8 57 66 7D 45 EB 36 CC
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_133 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[1];
	assign g_in[5] = in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[4] = in[6] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[3] = in[7] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[0] = in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 0 0 1 
	*	1 1 1 0 1 1 1 0 
	*	0 0 1 1 0 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	1 0 0 0 1 0 1 0 
	*	1 0 0 1 1 1 0 0 
	*	0 0 1 0 1 1 1 1 
	*	0 0 0 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[1] );

endmodule





/*****************************************************
* S-Box # 134
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 0 1 0 0 	0 1 0 1 0 0 1 1 
*	1 1 1 1 0 1 1 0 	0 1 1 0 1 0 1 0 
*	0 1 1 1 1 0 0 0 	1 1 0 1 1 0 1 1 
*	0 0 1 0 1 1 0 1 	1 1 0 0 0 1 1 0 
*	0 1 1 0 0 1 0 0 	0 1 0 1 0 1 1 1 
*	1 0 0 0 1 0 0 0 	1 0 1 1 1 0 0 1 
*	1 0 1 0 1 0 1 0 	1 1 0 1 1 1 0 1 
*	1 1 1 1 0 0 0 1 	0 0 1 0 0 1 0 1 
*
* S = AF F8 1B 66 AE 45 FA 36
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_134 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[2];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[4] = in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[3];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 0 0 1 1 
	*	1 0 0 1 1 0 0 1 
	*	0 0 1 0 1 1 1 0 
	*	1 1 0 1 0 0 0 0 
	*	0 1 0 0 0 1 0 1 
	*	0 1 1 1 1 0 0 0 
	*	0 0 0 1 1 0 1 0 
	*	0 0 0 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[5] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4];
	assign out[3] = g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[4] ^ g_out[3] ^ g_out[1] );
	assign out[0] = ~( g_out[0] );

endmodule





/*****************************************************
* S-Box # 135
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 0 1 0 0 	1 1 1 1 0 0 0 1 
*	0 0 1 1 0 0 1 0 	1 1 1 0 1 0 1 0 
*	0 1 1 1 1 0 0 0 	0 1 1 1 1 0 0 1 
*	0 1 0 1 0 1 0 1 	0 1 0 0 1 1 1 0 
*	0 1 1 0 0 1 0 0 	1 1 1 1 1 1 0 1 
*	1 1 1 0 1 1 0 0 	1 0 0 1 1 0 1 1 
*	1 0 1 0 1 0 1 0 	0 1 1 1 0 1 1 1 
*	0 1 0 1 1 0 1 1 	0 0 1 0 1 1 1 1 
*
* S = AF 57 1B 7D AE EB FA CC
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_135 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[2];
	assign g_in[6] = in[5] ^ in[4] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[4] = in[6] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[0] = in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 0 0 1 
	*	1 0 1 1 1 0 1 1 
	*	0 0 1 0 0 1 1 0 
	*	0 1 1 1 0 0 0 0 
	*	1 1 0 0 1 1 1 1 
	*	1 1 0 1 1 0 0 0 
	*	0 0 1 1 1 0 1 0 
	*	0 0 0 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );
	assign out[0] = ~( g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 136
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 1 0 1 1 0 	0 0 1 0 0 1 0 1 
*	0 0 1 1 0 0 1 0 	0 1 1 1 0 0 1 1 
*	1 1 0 1 1 0 1 1 	1 1 1 0 1 0 0 1 
*	0 1 1 0 0 1 1 1 	0 1 0 0 0 1 1 1 
*	1 0 0 0 1 0 0 0 	0 0 1 0 1 1 0 1 
*	1 1 1 0 1 1 0 0 	1 0 0 1 0 1 1 0 
*	0 1 1 1 1 0 0 1 	1 1 1 0 1 1 1 0 
*	1 0 1 1 0 1 1 1 	1 1 1 1 0 0 1 0 
*
* S = F8 57 9E 2A 45 EB 73 27
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_136 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[4] = in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 1 0 1 
	*	0 1 1 0 0 1 1 0 
	*	1 1 1 1 1 0 1 1 
	*	1 1 1 0 0 0 0 0 
	*	1 0 0 0 0 0 1 0 
	*	1 1 0 1 1 1 0 0 
	*	1 0 1 0 0 0 1 1 
	*	0 0 0 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5];
	assign out[3] = g_out[7] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 137
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 0 1 0 0 	0 0 0 1 1 1 1 1 
*	1 1 1 1 0 1 1 0 	1 1 1 0 0 0 1 0 
*	1 0 1 1 1 1 0 0 	1 0 0 1 0 1 1 1 
*	1 1 0 1 1 0 1 1 	1 1 0 0 1 1 1 0 
*	0 1 1 0 0 1 0 0 	0 0 0 1 1 0 1 1 
*	1 0 0 0 1 0 0 0 	0 1 1 1 1 1 0 1 
*	1 1 0 0 1 1 1 0 	1 0 0 1 1 0 0 1 
*	0 1 1 1 1 0 0 1 	1 0 1 0 0 0 0 1 
*
* S = AF F8 B4 9E AE 45 54 73
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_137 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[2];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[3];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 1 1 1 
	*	1 1 0 1 1 1 0 1 
	*	1 0 1 0 0 1 1 0 
	*	1 0 0 1 0 0 0 0 
	*	0 1 0 0 0 0 0 1 
	*	1 0 1 1 1 0 0 0 
	*	0 1 0 1 0 0 1 0 
	*	0 0 0 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[4];
	assign out[3] = g_out[6] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[1] );
	assign out[0] = ~( g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 138
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 0 1 0 0 	0 0 1 1 0 1 0 1 
*	0 0 1 1 0 0 1 0 	0 1 1 0 0 0 1 0 
*	1 0 1 1 1 1 0 0 	1 0 1 1 1 1 0 1 
*	0 1 1 0 0 1 1 1 	0 1 0 0 0 1 1 0 
*	0 1 1 0 0 1 0 0 	0 0 1 1 1 0 0 1 
*	1 1 1 0 1 1 0 0 	1 1 0 1 0 1 1 1 
*	1 1 0 0 1 1 1 0 	1 0 1 1 1 0 1 1 
*	1 0 1 1 0 1 1 1 	1 0 1 0 0 0 1 1 
*
* S = AF 57 B4 2A AE EB 54 27
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_138 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[2];
	assign g_in[6] = in[5] ^ in[4] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 1 0 1 
	*	0 1 1 1 0 1 1 1 
	*	1 0 1 0 1 1 1 0 
	*	1 0 1 1 0 0 0 0 
	*	1 1 0 0 0 0 1 1 
	*	1 0 0 1 1 0 0 0 
	*	1 1 1 1 0 0 1 0 
	*	0 0 0 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] );
	assign out[0] = ~( g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 139
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 1 0 1 1 0 	0 1 1 0 1 0 0 1 
*	0 0 1 1 0 0 1 0 	1 1 1 1 1 0 1 1 
*	1 1 1 0 1 0 0 1 	1 0 1 0 0 1 0 1 
*	1 0 1 0 0 0 1 1 	0 1 0 0 1 1 1 1 
*	1 0 0 0 1 0 0 0 	0 1 1 0 0 0 0 1 
*	1 1 1 0 1 1 0 0 	0 1 0 1 0 0 1 0 
*	1 0 0 1 0 1 0 1 	1 0 1 0 1 0 1 0 
*	1 1 0 1 0 0 1 1 	0 1 1 1 0 1 1 0 
*
* S = F8 57 31 D2 45 EB DD 62
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_139 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[0];
	assign g_in[4] = in[7] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[3] = in[7] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 0 0 1 
	*	0 0 1 0 0 0 1 0 
	*	0 1 1 1 0 0 1 1 
	*	1 0 1 0 0 0 0 0 
	*	1 0 0 0 0 1 1 0 
	*	0 0 0 1 1 1 0 0 
	*	1 1 1 0 1 0 1 1 
	*	0 0 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[6] = ~( g_out[5] ^ g_out[1] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5];
	assign out[3] = g_out[7] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 140
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 0 1 0 0 	1 1 0 1 0 1 1 1 
*	1 1 1 1 0 1 1 0 	1 0 1 0 0 1 1 0 
*	0 1 0 0 1 0 1 0 	0 1 0 1 1 1 1 1 
*	1 1 1 0 1 0 0 1 	1 1 0 0 1 0 1 0 
*	0 1 1 0 0 1 0 0 	1 1 0 1 0 0 1 1 
*	1 0 0 0 1 0 0 0 	1 1 1 1 0 0 0 1 
*	0 1 0 0 0 1 1 0 	0 1 0 1 0 1 0 1 
*	1 0 0 1 0 1 0 1 	1 1 1 0 1 1 0 1 
*
* S = AF F8 E3 31 AE 45 BF DD
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_140 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[2];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[3] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[3];
	assign g_in[1] = in[6] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 0 1 1 1 
	*	0 0 0 1 0 0 0 1 
	*	1 1 1 0 0 0 1 0 
	*	0 1 0 1 0 0 0 0 
	*	0 1 0 0 1 1 0 1 
	*	0 0 1 1 1 0 0 0 
	*	1 0 0 1 0 1 1 0 
	*	0 0 0 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[4] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] );
	assign out[4] = g_out[6] ^ g_out[4];
	assign out[3] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 141
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 0 1 0 0 	0 1 1 1 1 1 0 1 
*	0 0 1 1 0 0 1 0 	1 0 1 0 1 1 1 0 
*	0 1 0 0 1 0 1 0 	1 1 1 1 0 1 0 1 
*	1 0 1 0 0 0 1 1 	0 1 0 0 1 0 1 0 
*	0 1 1 0 0 1 0 0 	0 1 1 1 0 0 0 1 
*	1 1 1 0 1 1 0 0 	0 1 0 1 0 0 1 1 
*	0 1 0 0 0 1 1 0 	1 1 1 1 1 1 1 1 
*	1 1 0 1 0 0 1 1 	0 1 1 0 0 1 1 1 
*
* S = AF 57 E3 D2 AE EB BF 62
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_141 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[2];
	assign g_in[6] = in[5] ^ in[4] ^ in[1];
	assign g_in[5] = in[6] ^ in[3] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 1 0 1 
	*	0 0 1 1 0 0 1 1 
	*	0 1 1 0 0 0 1 0 
	*	1 1 1 1 0 0 0 0 
	*	1 1 0 0 0 1 1 1 
	*	0 0 0 1 1 0 0 0 
	*	1 0 1 1 1 1 1 0 
	*	0 0 0 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[1] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 142
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 1 1 0 1 1 0 	1 1 1 0 1 1 0 1 
*	0 0 1 1 0 0 1 0 	0 0 1 1 0 1 1 1 
*	0 0 0 1 1 1 1 1 	0 0 1 0 0 0 0 1 
*	1 0 0 1 0 0 0 1 	0 1 0 0 0 0 1 1 
*	1 0 0 0 1 0 0 0 	1 1 1 0 0 1 0 1 
*	1 1 1 0 1 1 0 0 	0 0 0 1 1 0 1 0 
*	0 0 0 1 1 1 0 1 	0 0 1 0 0 0 1 0 
*	0 0 1 1 1 1 1 1 	1 0 1 1 1 1 1 0 
*
* S = F8 57 C9 85 45 EB 98 89
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_142 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[6] = in[5] ^ in[4] ^ in[1];
	assign g_in[5] = in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[4] = in[7] ^ in[4] ^ in[0];
	assign g_in[3] = in[7] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 1 0 1 
	*	1 0 1 0 1 0 1 0 
	*	1 0 1 1 1 1 1 1 
	*	0 0 1 0 0 0 0 0 
	*	1 0 0 0 1 1 1 0 
	*	0 1 0 1 1 1 0 0 
	*	0 1 1 0 0 1 1 1 
	*	0 0 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[5];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 143
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 0 1 0 0 	1 0 0 1 1 0 1 1 
*	1 1 1 1 0 1 1 0 	0 0 1 0 1 1 1 0 
*	1 0 0 0 1 1 1 0 	0 0 0 1 0 0 1 1 
*	0 0 0 1 1 1 1 1 	1 1 0 0 0 0 1 0 
*	0 1 1 0 0 1 0 0 	1 0 0 1 1 1 1 1 
*	1 0 0 0 1 0 0 0 	0 0 1 1 0 1 0 1 
*	0 0 1 0 0 0 1 0 	0 0 0 1 0 0 0 1 
*	0 0 0 1 1 1 0 1 	0 1 1 0 1 0 0 1 
*
* S = AF F8 4C C9 AE 45 11 98
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_143 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[2];
	assign g_in[6] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[3];
	assign g_in[1] = in[5] ^ in[1];
	assign g_in[0] = in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 0 1 1 
	*	0 1 0 1 0 1 0 1 
	*	0 1 1 0 1 0 1 0 
	*	0 0 0 1 0 0 0 0 
	*	0 1 0 0 1 0 0 1 
	*	1 1 1 1 1 0 0 0 
	*	1 1 0 1 1 1 1 0 
	*	0 0 0 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[4] = g_out[4];
	assign out[3] = g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 144
*
* GF(2^8) Norm Basis: [L^128, L^8]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 0 0 1 0 0 	1 0 1 1 1 0 0 1 
*	0 0 1 1 0 0 1 0 	0 0 1 0 0 1 1 0 
*	1 0 0 0 1 1 1 0 	0 0 1 1 0 0 0 1 
*	1 0 0 1 0 0 0 1 	0 1 0 0 0 0 1 0 
*	0 1 1 0 0 1 0 0 	1 0 1 1 0 1 0 1 
*	1 1 1 0 1 1 0 0 	0 0 0 1 1 1 1 1 
*	0 0 1 0 0 0 1 0 	0 0 1 1 0 0 1 1 
*	0 0 1 1 1 1 1 1 	1 1 1 0 1 0 1 1 
*
* S = AF 57 4C 85 AE EB 11 89
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_144 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[2];
	assign g_in[6] = in[5] ^ in[4] ^ in[1];
	assign g_in[5] = in[7] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[4] = in[7] ^ in[4] ^ in[0];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[5] ^ in[1];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(g_in[7:4]), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(t1));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[3:0]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(g_in[7:4]));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 0 0 1 
	*	1 1 1 1 1 1 1 1 
	*	1 1 1 0 1 0 1 0 
	*	0 0 1 1 0 0 0 0 
	*	1 1 0 0 1 0 1 1 
	*	0 1 0 1 1 0 0 0 
	*	0 1 1 1 0 1 1 0 
	*	0 0 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] );
	assign out[4] = g_out[5] ^ g_out[4];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule




/*****************************************************
*
* GF(2^8) in Polynomial Basis
*
*****************************************************/



/*****************************************************
* S-Box # 145
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	1 1 0 1 0 1 1 0 
*	0 0 0 0 1 1 1 0 	0 0 0 1 0 1 0 1 
*	1 0 1 0 0 0 1 0 	0 0 1 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 1 0 1 0 0 1 1 
*	1 1 1 1 0 0 1 1 	0 1 0 0 1 1 0 0 
*	1 1 1 1 0 1 0 1 	1 1 0 1 1 1 0 0 
*	0 1 1 1 0 1 1 1 	1 1 0 1 0 0 0 0 
*	0 1 1 0 0 1 0 1 	1 1 1 0 1 1 1 0 
*
* S = 50 B1 ED 0D D6 21 9F 97
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_145 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	1 0 1 1 0 1 0 1 
	*	0 1 1 1 1 1 0 1 
	*	0 1 1 1 1 0 0 0 
	*	0 0 1 0 0 0 0 1 
	*	1 1 0 1 1 0 1 1 
	*	1 1 0 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[2] = g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 146
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 0 1 1 1 1 0 1 
*	1 1 0 1 1 1 0 0 	0 0 1 1 1 1 1 1 
*	0 1 1 1 0 0 1 0 	0 0 0 1 1 1 0 1 
*	1 0 1 0 0 0 1 0 	1 0 1 1 0 0 1 0 
*	0 0 0 0 0 1 1 0 	1 1 0 0 1 0 0 0 
*	1 1 1 1 0 0 1 1 	1 0 1 1 1 0 0 0 
*	0 0 0 1 0 0 1 0 	1 0 1 1 0 0 0 0 
*	0 1 1 1 0 1 1 1 	1 0 0 1 1 0 0 1 
*
* S = E1 50 E0 ED F7 D6 08 9F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_146 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[1] = in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	0 1 1 0 1 1 1 1 
	*	1 1 1 0 1 0 1 1 
	*	1 1 1 0 0 1 0 0 
	*	0 0 0 1 0 0 1 1 
	*	1 0 1 1 0 1 1 0 
	*	1 0 1 1 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[2] = g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 147
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 0 0 1 0 1 1 1 
*	0 0 0 0 1 1 1 0 	0 0 0 1 0 1 0 1 
*	0 1 1 1 0 0 1 0 	0 0 1 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 0 0 1 0 0 1 0 
*	0 0 0 0 0 1 1 0 	0 1 0 0 1 0 0 0 
*	1 1 1 1 0 1 0 1 	1 0 0 1 1 0 0 0 
*	0 0 0 1 0 0 1 0 	1 0 0 1 0 0 0 0 
*	0 1 1 0 0 1 0 1 	1 0 1 1 1 0 1 1 
*
* S = E1 B1 E0 0D F7 21 08 97
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_147 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[1] = in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	1 1 1 0 0 1 0 1 
	*	0 1 1 0 1 0 0 1 
	*	0 1 1 0 1 1 0 0 
	*	0 0 1 1 0 0 0 1 
	*	1 0 0 1 1 1 1 0 
	*	1 0 0 1 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 148
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	0 0 1 0 0 0 1 1 
*	0 1 1 1 0 0 0 0 	1 0 1 1 0 1 0 1 
*	0 0 0 0 0 0 1 0 	1 1 0 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 0 1 0 0 1 1 0 
*	1 1 1 0 0 1 1 1 	1 1 1 0 1 0 0 1 
*	0 1 1 1 0 0 0 1 	0 0 1 0 1 0 0 1 
*	0 1 1 0 0 0 1 1 	0 0 1 0 0 0 0 0 
*	1 1 1 0 0 0 0 1 	0 1 0 0 0 1 0 0 
*
* S = EC B0 51 0C 60 DE 29 68
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_148 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	0 0 0 1 0 1 0 1 
	*	1 0 0 0 0 0 1 0 
	*	1 0 0 0 0 1 1 1 
	*	1 1 0 1 1 0 1 1 
	*	0 0 1 0 0 0 0 1 
	*	0 0 1 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 149
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 0 0 1 0 0 1 0 
*	0 1 1 1 1 1 0 0 	0 1 1 0 1 1 1 1 
*	1 0 1 0 1 1 0 0 	1 0 1 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 0 0 1 1 1 0 1 
*	1 0 0 1 0 1 1 0 	1 0 0 1 0 1 1 1 
*	1 1 1 0 0 1 1 1 	0 0 0 1 0 1 1 1 
*	1 0 0 0 0 0 1 0 	0 0 0 1 0 0 0 0 
*	0 1 1 0 0 0 1 1 	1 1 0 0 1 1 0 0 
*
* S = 5C EC 5D 51 BE 60 41 29
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_149 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	0 0 1 1 1 1 1 1 
	*	0 1 0 0 0 0 0 1 
	*	0 1 0 0 1 1 1 0 
	*	1 0 1 1 0 1 1 0 
	*	0 0 0 1 0 0 1 1 
	*	0 0 0 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 150
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 0 1 1 0 0 1 0 
*	0 1 1 1 0 0 0 0 	1 1 1 0 0 1 0 1 
*	1 0 1 0 1 1 0 0 	1 0 0 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 0 1 1 0 1 1 1 
*	1 0 0 1 0 1 1 0 	1 0 1 1 1 1 0 1 
*	0 1 1 1 0 0 0 1 	0 0 1 1 1 1 0 1 
*	1 0 0 0 0 0 1 0 	0 0 1 1 0 0 0 0 
*	1 1 1 0 0 0 0 1 	0 1 0 0 0 1 0 0 
*
* S = 5C B0 5D 0C BE DE 41 68
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_150 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[1] = in[7] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	0 0 0 1 0 1 0 1 
	*	1 1 0 0 0 0 1 1 
	*	1 1 0 0 0 1 1 0 
	*	1 0 0 1 1 1 1 0 
	*	0 0 1 1 0 0 0 1 
	*	0 0 1 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 151
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 1 0 1 0 1 1 
*	1 1 0 1 1 1 1 0 	0 1 0 1 0 1 0 0 
*	1 1 0 1 1 1 0 0 	1 0 1 0 1 0 1 1 
*	0 0 0 0 1 1 1 0 	0 1 1 0 1 1 1 1 
*	1 0 0 0 0 1 0 0 	0 0 0 1 0 0 1 1 
*	1 0 0 1 0 0 0 0 	0 1 1 0 0 0 1 1 
*	1 1 1 1 0 0 1 1 	0 1 1 0 0 0 0 0 
*	1 1 1 1 0 1 0 1 	1 0 0 1 1 0 0 1 
*
* S = BD BC 50 B1 49 B6 D6 21
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_151 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[2];
	assign g_in[2] = in[7] ^ in[4];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	1 1 0 1 0 1 0 0 
	*	1 1 1 0 0 1 1 0 
	*	1 1 1 0 0 0 1 0 
	*	1 0 1 0 0 1 0 1 
	*	0 1 1 0 1 1 0 1 
	*	0 1 1 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 152
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 1 0 1 1 0 
*	0 1 1 1 1 1 1 0 	1 1 1 1 1 1 0 0 
*	1 1 0 1 0 0 1 0 	0 1 0 1 0 1 1 0 
*	1 1 0 1 1 1 0 0 	1 1 0 1 1 0 1 0 
*	0 0 0 1 0 1 0 0 	0 0 1 1 0 0 1 0 
*	1 0 0 0 0 1 0 0 	1 1 0 1 0 0 1 0 
*	0 0 0 0 0 1 1 0 	1 1 0 1 0 0 0 0 
*	1 1 1 1 0 0 1 1 	0 1 1 1 0 1 1 1 
*
* S = 01 BD E1 50 FF 49 F7 D6
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_152 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[2];
	assign g_in[1] = in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	1 0 1 1 1 1 0 0 
	*	1 0 0 1 1 1 0 1 
	*	1 0 0 1 0 0 0 1 
	*	0 1 0 1 1 1 1 1 
	*	1 1 0 1 1 0 1 1 
	*	1 1 0 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 153
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 1 1 1 1 0 
*	1 1 0 1 1 1 1 0 	0 1 0 1 0 1 0 0 
*	1 1 0 1 0 0 1 0 	1 1 1 1 1 1 1 0 
*	0 0 0 0 1 1 1 0 	0 1 1 1 1 0 1 0 
*	0 0 0 1 0 1 0 0 	0 0 0 1 0 0 1 0 
*	1 0 0 1 0 0 0 0 	0 1 1 1 0 0 1 0 
*	0 0 0 0 0 1 1 0 	0 1 1 1 0 0 0 0 
*	1 1 1 1 0 1 0 1 	1 1 0 1 1 1 0 1 
*
* S = 01 BC E1 B1 FF B6 F7 21
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_153 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4];
	assign g_in[1] = in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	1 0 0 1 0 1 0 0 
	*	1 0 1 1 0 1 1 1 
	*	1 0 1 1 0 0 1 1 
	*	1 1 1 1 0 1 0 1 
	*	0 1 1 1 1 0 0 1 
	*	0 1 1 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 154
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 1 0 0 1 1 1 
*	1 1 0 1 1 1 1 0 	0 0 0 1 0 1 0 0 
*	1 0 1 0 0 0 1 0 	0 0 1 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 1 1 0 0 0 1 1 
*	1 0 0 0 0 1 0 0 	0 1 0 1 1 1 1 1 
*	1 0 0 1 0 0 0 0 	1 1 1 0 1 1 1 1 
*	0 1 1 1 0 1 1 1 	1 1 1 0 0 0 0 0 
*	0 1 1 0 0 1 0 1 	1 1 0 1 1 1 0 1 
*
* S = BD BC ED 0D 49 B6 9F 97
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_154 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[2];
	assign g_in[2] = in[7] ^ in[4];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	1 0 0 1 0 1 0 0 
	*	0 1 1 0 1 1 1 0 
	*	0 1 1 0 1 0 1 0 
	*	0 0 1 0 0 0 0 1 
	*	1 1 1 0 1 0 0 1 
	*	1 1 1 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 155
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 1 1 1 1 0 
*	0 1 1 1 1 1 1 0 	0 0 1 1 1 1 0 0 
*	0 1 1 1 0 0 1 0 	0 0 0 1 1 1 1 0 
*	1 0 1 0 0 0 1 0 	1 0 0 1 0 0 1 0 
*	0 0 0 1 0 1 0 0 	1 1 1 1 1 0 1 0 
*	1 0 0 0 0 1 0 0 	1 0 0 1 1 0 1 0 
*	0 0 0 1 0 0 1 0 	1 0 0 1 0 0 0 0 
*	0 1 1 1 0 1 1 1 	1 0 1 1 1 0 1 1 
*
* S = 01 BD E0 ED FF 49 08 9F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_155 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[2];
	assign g_in[1] = in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	0 1 1 1 1 1 0 0 
	*	1 1 0 1 1 0 0 1 
	*	1 1 0 1 0 1 0 1 
	*	0 0 0 1 0 0 1 1 
	*	1 0 0 1 0 1 1 1 
	*	1 0 0 1 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 156
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 1 0 1 1 0 
*	1 1 0 1 1 1 1 0 	0 0 0 1 0 1 0 0 
*	0 1 1 1 0 0 1 0 	0 0 1 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 0 1 1 0 0 1 0 
*	0 0 0 1 0 1 0 0 	0 1 0 1 1 0 1 0 
*	1 0 0 1 0 0 0 0 	1 0 1 1 1 0 1 0 
*	0 0 0 1 0 0 1 0 	1 0 1 1 0 0 0 0 
*	0 1 1 0 0 1 0 1 	1 0 0 1 1 0 0 1 
*
* S = 01 BC E0 0D FF B6 08 97
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_156 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4];
	assign g_in[1] = in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	1 1 0 1 0 1 0 0 
	*	0 1 1 1 1 0 1 1 
	*	0 1 1 1 1 1 1 1 
	*	0 0 1 1 0 0 0 1 
	*	1 0 1 1 1 1 0 1 
	*	1 0 1 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 157
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 1 0 1 1 1 1 
*	1 1 0 1 1 1 1 0 	1 1 0 1 0 1 0 0 
*	0 1 1 1 1 1 0 0 	0 1 1 0 1 1 1 1 
*	0 1 1 1 0 0 0 0 	1 0 1 0 1 0 1 1 
*	1 0 0 0 0 1 0 0 	1 0 0 1 0 1 1 1 
*	1 0 0 1 0 0 0 0 	1 0 1 0 0 1 1 1 
*	1 1 1 0 0 1 1 1 	1 0 1 0 0 0 0 0 
*	0 1 1 1 0 0 0 1 	0 0 0 1 0 0 0 1 
*
* S = BD BC EC B0 49 B6 60 DE
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_157 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[2];
	assign g_in[2] = in[7] ^ in[4];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	0 1 0 1 0 1 0 0 
	*	0 0 1 0 1 0 1 0 
	*	0 0 1 0 1 1 1 0 
	*	0 1 1 0 1 1 0 1 
	*	1 0 1 0 0 1 0 1 
	*	1 0 1 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 158
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 1 1 0 1 0 
*	0 1 1 1 1 1 1 0 	1 0 1 1 1 1 0 0 
*	0 0 0 0 1 1 0 0 	1 1 0 1 1 0 1 0 
*	0 1 1 1 1 1 0 0 	0 1 0 1 0 1 1 0 
*	0 0 0 1 0 1 0 0 	0 1 1 1 1 1 1 0 
*	1 0 0 0 0 1 0 0 	0 1 0 1 1 1 1 0 
*	1 0 0 1 0 1 1 0 	0 1 0 1 0 0 0 0 
*	1 1 1 0 0 1 1 1 	0 0 1 1 0 0 1 1 
*
* S = 01 BD 5C EC FF 49 BE 60
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_158 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[2];
	assign g_in[1] = in[7] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 1 1 1 1 1 0 0 
	*	0 0 0 1 0 1 0 1 
	*	0 0 0 1 1 0 0 1 
	*	1 1 0 1 1 0 1 1 
	*	0 1 0 1 1 1 1 1 
	*	0 1 0 1 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 159
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 1 1 0 1 0 
*	1 1 0 1 1 1 1 0 	1 0 0 1 0 1 0 0 
*	0 0 0 0 1 1 0 0 	0 1 1 1 1 0 1 0 
*	0 1 1 1 0 0 0 0 	1 1 1 1 1 1 1 0 
*	0 0 0 1 0 1 0 0 	1 1 0 1 0 1 1 0 
*	1 0 0 1 0 0 0 0 	1 1 1 1 0 1 1 0 
*	1 0 0 1 0 1 1 0 	1 1 1 1 0 0 0 0 
*	0 1 1 1 0 0 0 1 	0 0 0 1 0 0 0 1 
*
* S = 01 BC 5C B0 FF B6 BE DE
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_159 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4];
	assign g_in[1] = in[7] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	0 1 0 1 0 1 0 0 
	*	0 0 1 1 1 1 1 1 
	*	0 0 1 1 1 0 1 1 
	*	0 1 1 1 1 0 0 1 
	*	1 1 1 1 0 1 0 1 
	*	1 1 1 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 160
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 1 0 0 0 1 1 
*	1 1 0 1 1 1 1 0 	1 0 0 1 0 1 0 0 
*	0 0 0 0 0 0 1 0 	1 1 1 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 0 1 0 0 1 1 1 
*	1 0 0 0 0 1 0 0 	1 1 0 1 1 0 1 1 
*	1 0 0 1 0 0 0 0 	0 0 1 0 1 0 1 1 
*	0 1 1 0 0 0 1 1 	0 0 1 0 0 0 0 0 
*	1 1 1 0 0 0 0 1 	0 1 0 1 0 1 0 1 
*
* S = BD BC 51 0C 49 B6 29 68
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_160 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[2];
	assign g_in[2] = in[7] ^ in[4];
	assign g_in[1] = in[6] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	0 0 0 1 0 1 0 0 
	*	1 0 1 0 0 0 1 0 
	*	1 0 1 0 0 1 1 0 
	*	1 1 1 0 1 0 0 1 
	*	0 0 1 0 0 0 0 1 
	*	0 0 1 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 161
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 1 0 0 1 0 
*	0 1 1 1 1 1 1 0 	0 1 1 1 1 1 0 0 
*	1 0 1 0 1 1 0 0 	1 0 0 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 0 0 1 1 1 1 0 
*	0 0 0 1 0 1 0 0 	1 0 1 1 0 1 1 0 
*	1 0 0 0 0 1 0 0 	0 0 0 1 0 1 1 0 
*	1 0 0 0 0 0 1 0 	0 0 0 1 0 0 0 0 
*	0 1 1 0 0 0 1 1 	1 1 1 1 1 1 1 1 
*
* S = 01 BD 5D 51 FF 49 41 29
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_161 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[2];
	assign g_in[1] = in[7] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	0 0 1 1 1 1 0 0 
	*	0 1 0 1 0 0 0 1 
	*	0 1 0 1 1 1 0 1 
	*	1 0 0 1 0 1 1 1 
	*	0 0 0 1 0 0 1 1 
	*	0 0 0 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 162
*
* GF(2^8) Poly Basis: [d^1, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 1 0 0 1 0 
*	1 1 0 1 1 1 1 0 	1 1 0 1 0 1 0 0 
*	1 0 1 0 1 1 0 0 	1 0 1 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 0 1 1 0 1 1 0 
*	0 0 0 1 0 1 0 0 	1 0 0 1 1 1 1 0 
*	1 0 0 1 0 0 0 0 	0 0 1 1 1 1 1 0 
*	1 0 0 0 0 0 1 0 	0 0 1 1 0 0 0 0 
*	1 1 1 0 0 0 0 1 	0 1 0 1 0 1 0 1 
*
* S = 01 BC 5D 0C FF B6 41 68
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_162 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4];
	assign g_in[1] = in[7] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	0 0 0 1 0 1 0 0 
	*	1 1 1 1 0 0 1 1 
	*	1 1 1 1 0 1 1 1 
	*	1 0 1 1 1 1 0 1 
	*	0 0 1 1 0 0 0 1 
	*	0 0 1 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 163
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	1 0 1 1 0 1 1 0 
*	0 0 0 0 1 1 1 0 	0 1 0 0 0 1 0 1 
*	1 0 1 0 0 0 1 0 	0 1 0 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 1 1 0 0 0 1 1 
*	0 0 1 0 1 1 1 1 	1 0 0 0 1 1 0 0 
*	1 1 1 1 1 0 1 1 	0 0 0 1 1 1 0 0 
*	1 1 0 1 0 1 0 1 	1 1 0 1 0 0 0 0 
*	1 0 1 1 0 1 0 1 	0 0 0 0 1 1 1 0 
*
* S = 50 B1 ED 0D 86 90 72 9A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_163 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	1 1 1 0 0 1 0 1 
	*	1 0 1 0 1 1 0 1 
	*	1 1 1 1 1 0 0 0 
	*	0 0 1 1 0 0 0 1 
	*	0 1 1 0 1 0 1 1 
	*	0 1 0 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 164
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 1 1 0 1 1 0 1 
*	1 1 0 1 1 1 0 0 	1 1 0 0 1 1 1 1 
*	0 1 1 1 0 0 1 0 	1 1 0 0 1 1 0 1 
*	1 0 1 0 0 0 1 0 	1 0 0 1 0 0 1 0 
*	1 1 0 1 0 1 0 0 	0 1 0 0 1 0 0 0 
*	0 0 1 0 1 1 1 1 	0 0 1 1 1 0 0 0 
*	0 1 1 0 0 0 0 0 	1 0 1 1 0 0 0 0 
*	1 1 0 1 0 1 0 1 	0 0 0 0 1 0 0 1 
*
* S = E1 50 E0 ED 16 86 E8 72
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_164 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	1 0 0 1 1 1 1 1 
	*	0 1 0 1 1 0 1 1 
	*	1 0 1 0 0 1 0 0 
	*	0 0 1 0 0 0 1 1 
	*	1 1 0 1 0 1 1 0 
	*	1 1 1 1 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[2];
	assign out[2] = g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 165
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 1 1 0 0 1 1 1 
*	0 0 0 0 1 1 1 0 	0 1 0 0 0 1 0 1 
*	0 1 1 1 0 0 1 0 	0 1 0 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 0 1 1 0 0 1 0 
*	1 1 0 1 0 1 0 0 	1 1 0 0 1 0 0 0 
*	1 1 1 1 1 0 1 1 	0 0 0 1 1 0 0 0 
*	0 1 1 0 0 0 0 0 	1 0 0 1 0 0 0 0 
*	1 0 1 1 0 1 0 1 	0 0 0 0 1 0 1 1 
*
* S = E1 B1 E0 0D 16 90 E8 9A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_165 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	1 0 1 1 0 1 0 1 
	*	1 1 1 1 1 0 0 1 
	*	1 0 1 0 1 1 0 0 
	*	0 0 1 0 0 0 0 1 
	*	0 1 1 1 1 1 1 0 
	*	0 1 0 1 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 166
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	0 0 0 1 0 0 1 1 
*	0 1 1 1 0 0 0 0 	1 1 1 0 0 1 0 1 
*	0 0 0 0 0 0 1 0 	1 1 1 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 1 0 0 0 1 1 0 
*	1 0 0 1 1 0 1 1 	0 1 1 1 1 0 0 1 
*	0 0 0 0 0 0 0 1 	1 0 1 1 1 0 0 1 
*	0 1 1 0 0 0 0 1 	0 0 1 0 0 0 0 0 
*	0 1 0 0 1 1 1 1 	0 0 0 0 0 1 0 0 
*
* S = EC B0 51 0C 8C 6E 78 64
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_166 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[2] = in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[0];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	0 1 0 0 0 1 0 1 
	*	1 0 1 0 0 0 1 0 
	*	1 1 1 1 0 1 1 1 
	*	0 1 1 0 1 0 1 1 
	*	0 0 1 1 0 0 0 1 
	*	0 1 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 167
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 0 1 1 0 0 1 0 
*	0 1 1 1 1 1 0 0 	1 0 0 1 1 1 1 1 
*	1 0 1 0 1 1 0 0 	1 0 0 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 1 0 0 1 1 0 1 
*	1 0 0 1 1 0 1 0 	1 1 1 0 0 1 1 1 
*	1 0 0 1 1 0 1 1 	0 1 1 0 0 1 1 1 
*	0 0 1 0 1 1 1 0 	0 0 0 1 0 0 0 0 
*	0 1 1 0 0 0 0 1 	0 0 0 0 1 1 0 0 
*
* S = 5C EC 5D 51 E2 8C 1C 78
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_167 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	1 1 0 0 1 1 1 1 
	*	0 1 0 1 0 0 0 1 
	*	1 0 1 0 1 1 1 0 
	*	1 1 0 1 0 1 1 0 
	*	0 0 1 0 0 0 1 1 
	*	1 1 1 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 168
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 0 0 1 0 0 1 0 
*	0 1 1 1 0 0 0 0 	1 0 1 1 0 1 0 1 
*	1 0 1 0 1 1 0 0 	1 0 1 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 1 0 0 0 1 1 1 
*	1 0 0 1 1 0 1 0 	0 1 1 0 1 1 0 1 
*	0 0 0 0 0 0 0 1 	1 1 1 0 1 1 0 1 
*	0 0 1 0 1 1 1 0 	0 0 1 1 0 0 0 0 
*	0 1 0 0 1 1 1 1 	0 0 0 0 0 1 0 0 
*
* S = 5C B0 5D 0C E2 6E 1C 64
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_168 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[0];
	assign g_in[1] = in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	0 1 0 0 0 1 0 1 
	*	1 1 1 1 0 0 1 1 
	*	1 0 1 0 0 1 1 0 
	*	0 1 1 1 1 1 1 0 
	*	0 0 1 0 0 0 0 1 
	*	0 1 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 169
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 0 1 1 0 1 1 
*	1 1 0 1 1 1 1 0 	0 0 0 1 0 1 0 0 
*	1 1 0 1 1 1 0 0 	0 0 0 1 1 0 1 1 
*	0 0 0 0 1 1 1 0 	1 0 0 1 1 1 1 1 
*	1 1 1 1 1 0 1 0 	0 0 1 0 0 0 1 1 
*	0 1 0 0 1 1 1 0 	0 1 0 1 0 0 1 1 
*	0 0 1 0 1 1 1 1 	0 1 1 0 0 0 0 0 
*	1 1 1 1 1 0 1 1 	0 0 0 0 1 0 0 1 
*
* S = BD BC 50 B1 F4 0A 86 90
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_169 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	1 0 0 1 0 1 0 0 
	*	1 0 0 0 0 1 1 0 
	*	1 1 0 0 0 0 1 0 
	*	1 1 1 1 0 1 0 1 
	*	1 0 1 1 1 1 0 1 
	*	0 1 0 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 170
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 1 0 1 1 0 
*	0 1 1 1 1 1 1 0 	0 0 1 1 1 1 0 0 
*	1 1 0 1 0 0 1 0 	0 0 1 1 0 1 1 0 
*	1 1 0 1 1 1 0 0 	0 1 1 1 1 0 1 0 
*	1 0 1 1 0 1 0 0 	0 0 0 1 0 0 1 0 
*	1 1 1 1 1 0 1 0 	1 1 1 1 0 0 1 0 
*	1 1 0 1 0 1 0 0 	1 1 0 1 0 0 0 0 
*	0 0 1 0 1 1 1 1 	0 0 0 0 0 1 1 1 
*
* S = 01 BD E1 50 FE F4 16 86
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_170 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2];
	assign g_in[0] = in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	0 1 1 1 1 1 0 0 
	*	0 1 0 0 1 1 0 1 
	*	1 0 0 0 0 0 0 1 
	*	1 0 1 0 1 1 1 1 
	*	0 1 1 0 1 0 1 1 
	*	1 1 0 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 171
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 1 1 1 1 0 
*	1 1 0 1 1 1 1 0 	0 0 0 1 0 1 0 0 
*	1 1 0 1 0 0 1 0 	0 0 0 1 1 1 1 0 
*	0 0 0 0 1 1 1 0 	1 1 0 1 1 0 1 0 
*	1 0 1 1 0 1 0 0 	0 0 1 1 0 0 1 0 
*	0 1 0 0 1 1 1 0 	0 1 0 1 0 0 1 0 
*	1 1 0 1 0 1 0 0 	0 1 1 1 0 0 0 0 
*	1 1 1 1 1 0 1 1 	0 0 0 0 1 1 0 1 
*
* S = 01 BC E1 B1 FE 0A 16 90
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_171 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	1 1 0 1 0 1 0 0 
	*	1 1 0 0 0 1 1 1 
	*	1 0 0 0 0 0 1 1 
	*	1 0 1 0 0 1 0 1 
	*	1 1 1 0 1 0 0 1 
	*	0 1 0 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 172
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 0 1 0 1 1 1 
*	1 1 0 1 1 1 1 0 	0 1 0 1 0 1 0 0 
*	1 0 1 0 0 0 1 0 	0 1 0 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 1 0 1 0 0 1 1 
*	1 1 1 1 1 0 1 0 	1 0 1 0 1 1 1 1 
*	0 1 0 0 1 1 1 0 	0 0 0 1 1 1 1 1 
*	1 1 0 1 0 1 0 1 	1 1 1 0 0 0 0 0 
*	1 0 1 1 0 1 0 1 	0 0 0 0 1 1 0 1 
*
* S = BD BC ED 0D F4 0A 72 9A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_172 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	1 1 0 1 0 1 0 0 
	*	1 0 0 0 1 1 1 0 
	*	1 1 0 0 1 0 1 0 
	*	0 0 1 1 0 0 0 1 
	*	0 1 1 1 1 0 0 1 
	*	0 1 0 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 173
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 1 1 1 1 0 
*	0 1 1 1 1 1 1 0 	1 1 1 1 1 1 0 0 
*	0 1 1 1 0 0 1 0 	1 1 1 1 1 1 1 0 
*	1 0 1 0 0 0 1 0 	1 0 1 1 0 0 1 0 
*	1 0 1 1 0 1 0 0 	0 1 0 1 1 0 1 0 
*	1 1 1 1 1 0 1 0 	0 0 1 1 1 0 1 0 
*	0 1 1 0 0 0 0 0 	1 0 0 1 0 0 0 0 
*	1 1 0 1 0 1 0 1 	0 0 0 0 1 0 1 1 
*
* S = 01 BD E0 ED FE F4 E8 72
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_173 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[6] ^ in[5];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	1 0 1 1 1 1 0 0 
	*	0 1 0 0 1 0 0 1 
	*	1 0 0 0 0 1 0 1 
	*	0 0 1 0 0 0 1 1 
	*	1 1 1 0 0 1 1 1 
	*	1 1 0 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 174
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 1 0 1 1 0 
*	1 1 0 1 1 1 1 0 	0 1 0 1 0 1 0 0 
*	0 1 1 1 0 0 1 0 	0 1 0 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 0 0 1 0 0 1 0 
*	1 0 1 1 0 1 0 0 	1 1 1 1 1 0 1 0 
*	0 1 0 0 1 1 1 0 	0 0 0 1 1 0 1 0 
*	0 1 1 0 0 0 0 0 	1 0 1 1 0 0 0 0 
*	1 0 1 1 0 1 0 1 	0 0 0 0 1 0 0 1 
*
* S = 01 BC E0 0D FE 0A E8 9A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_174 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	1 0 0 1 0 1 0 0 
	*	1 1 0 0 1 0 1 1 
	*	1 0 0 0 1 1 1 1 
	*	0 0 1 0 0 0 0 1 
	*	0 1 1 0 1 1 0 1 
	*	0 1 0 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 175
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 0 1 1 1 1 1 
*	1 1 0 1 1 1 1 0 	1 0 0 1 0 1 0 0 
*	0 1 1 1 1 1 0 0 	1 0 0 1 1 1 1 1 
*	0 1 1 1 0 0 0 0 	0 0 0 1 1 0 1 1 
*	1 1 1 1 1 0 1 0 	1 1 1 0 0 1 1 1 
*	0 1 0 0 1 1 1 0 	1 1 0 1 0 1 1 1 
*	1 0 0 1 1 0 1 1 	1 0 1 0 0 0 0 0 
*	0 0 0 0 0 0 0 1 	0 0 0 0 0 0 0 1 
*
* S = BD BC EC B0 F4 0A 8C 6E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_175 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	0 0 0 1 0 1 0 0 
	*	1 0 0 0 1 0 1 0 
	*	1 1 0 0 1 1 1 0 
	*	1 0 1 1 1 1 0 1 
	*	1 1 1 1 0 1 0 1 
	*	0 1 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 176
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 1 1 0 1 0 
*	0 1 1 1 1 1 1 0 	0 1 1 1 1 1 0 0 
*	0 0 0 0 1 1 0 0 	0 1 1 1 1 0 1 0 
*	0 1 1 1 1 1 0 0 	0 0 1 1 0 1 1 0 
*	1 0 1 1 0 1 0 0 	1 0 0 1 1 1 1 0 
*	1 1 1 1 1 0 1 0 	1 0 1 1 1 1 1 0 
*	1 0 0 1 1 0 1 0 	0 1 0 1 0 0 0 0 
*	1 0 0 1 1 0 1 1 	0 0 0 0 0 0 1 1 
*
* S = 01 BD 5C EC FE F4 E2 8C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_176 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	0 0 1 1 1 1 0 0 
	*	0 1 0 0 0 1 0 1 
	*	1 0 0 0 1 0 0 1 
	*	0 1 1 0 1 0 1 1 
	*	1 0 1 0 1 1 1 1 
	*	1 1 0 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 177
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 1 1 0 1 0 
*	1 1 0 1 1 1 1 0 	1 1 0 1 0 1 0 0 
*	0 0 0 0 1 1 0 0 	1 1 0 1 1 0 1 0 
*	0 1 1 1 0 0 0 0 	0 0 0 1 1 1 1 0 
*	1 0 1 1 0 1 0 0 	1 0 1 1 0 1 1 0 
*	0 1 0 0 1 1 1 0 	1 0 0 1 0 1 1 0 
*	1 0 0 1 1 0 1 0 	1 1 1 1 0 0 0 0 
*	0 0 0 0 0 0 0 1 	0 0 0 0 0 0 0 1 
*
* S = 01 BC 5C B0 FE 0A E2 6E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_177 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	0 0 0 1 0 1 0 0 
	*	1 1 0 0 1 1 1 1 
	*	1 0 0 0 1 0 1 1 
	*	1 1 1 0 1 0 0 1 
	*	1 0 1 0 0 1 0 1 
	*	0 1 0 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 178
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 0 1 0 0 1 1 
*	1 1 0 1 1 1 1 0 	1 1 0 1 0 1 0 0 
*	0 0 0 0 0 0 1 0 	1 1 0 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 1 0 1 0 1 1 1 
*	1 1 1 1 1 0 1 0 	0 1 1 0 1 0 1 1 
*	0 1 0 0 1 1 1 0 	1 0 0 1 1 0 1 1 
*	0 1 1 0 0 0 0 1 	0 0 1 0 0 0 0 0 
*	0 1 0 0 1 1 1 1 	0 0 0 0 0 1 0 1 
*
* S = BD BC 51 0C F4 0A 78 64
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_178 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[0];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	0 1 0 1 0 1 0 0 
	*	1 0 0 0 0 0 1 0 
	*	1 1 0 0 0 1 1 0 
	*	0 1 1 1 1 0 0 1 
	*	0 0 1 1 0 0 0 1 
	*	0 1 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 179
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 1 0 0 1 0 
*	0 1 1 1 1 1 1 0 	1 0 1 1 1 1 0 0 
*	1 0 1 0 1 1 0 0 	1 0 1 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 1 1 1 1 1 1 0 
*	1 0 1 1 0 1 0 0 	1 1 0 1 0 1 1 0 
*	1 1 1 1 1 0 1 0 	0 1 1 1 0 1 1 0 
*	0 0 1 0 1 1 1 0 	0 0 0 1 0 0 0 0 
*	0 1 1 0 0 0 0 1 	0 0 0 0 1 1 1 1 
*
* S = 01 BD 5D 51 FE F4 1C 78
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_179 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	1 1 1 1 1 1 0 0 
	*	0 1 0 0 0 0 0 1 
	*	1 0 0 0 1 1 0 1 
	*	1 1 1 0 0 1 1 1 
	*	0 0 1 0 0 0 1 1 
	*	1 1 0 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 180
*
* GF(2^8) Poly Basis: [d^16, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 1 0 0 1 0 
*	1 1 0 1 1 1 1 0 	1 0 0 1 0 1 0 0 
*	1 0 1 0 1 1 0 0 	1 0 0 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 1 0 1 0 1 1 0 
*	1 0 1 1 0 1 0 0 	0 1 1 1 1 1 1 0 
*	0 1 0 0 1 1 1 0 	1 1 0 1 1 1 1 0 
*	0 0 1 0 1 1 1 0 	0 0 1 1 0 0 0 0 
*	0 1 0 0 1 1 1 1 	0 0 0 0 0 1 0 1 
*
* S = 01 BC 5D 0C FE 0A 1C 64
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_180 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	0 1 0 1 0 1 0 0 
	*	1 1 0 0 0 0 1 1 
	*	1 0 0 0 0 1 1 1 
	*	0 1 1 0 1 1 0 1 
	*	0 0 1 0 0 0 0 1 
	*	0 1 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 181
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	1 0 0 1 0 1 1 0 
*	0 0 0 0 1 1 1 0 	1 1 0 0 0 1 0 1 
*	1 0 1 0 0 0 1 0 	0 1 1 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 1 0 0 0 0 1 1 
*	0 0 1 0 0 0 1 1 	0 1 1 0 1 1 0 0 
*	1 0 0 0 0 1 1 1 	1 1 1 1 1 1 0 0 
*	0 0 0 0 1 0 1 1 	1 1 0 1 0 0 0 0 
*	0 0 0 1 0 1 0 1 	1 0 1 1 1 1 1 0 
*
* S = 50 B1 ED 0D 87 2D 7E C7
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_181 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[5] ^ in[1] ^ in[0];
	assign g_in[2] = in[7] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	0 1 1 0 0 1 0 1 
	*	1 0 1 1 1 1 0 1 
	*	0 1 1 0 1 0 0 0 
	*	1 1 0 0 0 0 0 1 
	*	0 1 0 1 1 0 1 1 
	*	1 1 0 0 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 182
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 1 1 1 1 1 0 1 
*	1 1 0 1 1 1 0 0 	1 0 0 0 1 1 1 1 
*	0 1 1 1 0 0 1 0 	1 1 0 1 1 1 0 1 
*	1 0 1 0 0 0 1 0 	1 1 0 0 0 0 1 0 
*	1 0 1 0 0 1 0 0 	1 1 0 1 1 0 0 0 
*	0 0 1 0 0 0 1 1 	1 0 1 0 1 0 0 0 
*	0 0 0 1 1 1 1 0 	1 0 1 1 0 0 0 0 
*	0 0 0 0 1 0 1 1 	0 1 1 0 1 0 0 1 
*
* S = E1 50 E0 ED AA 87 B9 7E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_182 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[2];
	assign g_in[2] = in[5] ^ in[1] ^ in[0];
	assign g_in[1] = in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	1 1 0 1 1 1 1 1 
	*	0 1 1 0 1 0 1 1 
	*	1 1 0 1 0 1 0 0 
	*	1 0 0 0 0 0 1 1 
	*	1 1 1 1 0 1 1 0 
	*	1 0 0 0 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 183
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 1 0 1 0 1 1 1 
*	0 0 0 0 1 1 1 0 	1 0 0 0 0 1 0 1 
*	0 1 1 1 0 0 1 0 	0 1 1 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 1 0 0 0 0 1 0 
*	1 0 1 0 0 1 0 0 	0 1 1 1 1 0 0 0 
*	1 0 0 0 0 1 1 1 	1 0 1 0 1 0 0 0 
*	0 0 0 1 1 1 1 0 	1 0 0 1 0 0 0 0 
*	0 0 0 1 0 1 0 1 	1 1 1 0 1 0 1 1 
*
* S = E1 B1 E0 0D AA 2D B9 C7
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_183 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	0 1 1 1 0 1 0 1 
	*	1 1 1 0 1 0 0 1 
	*	0 1 1 1 1 1 0 0 
	*	1 0 0 0 0 0 0 1 
	*	0 1 0 1 1 1 1 0 
	*	1 0 0 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 184
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	1 1 0 0 0 0 1 1 
*	0 1 1 1 0 0 0 0 	1 0 0 1 0 1 0 1 
*	0 0 0 0 0 0 1 0 	0 0 1 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 1 1 0 0 1 1 0 
*	1 0 0 1 1 0 0 1 	0 0 1 1 1 0 0 1 
*	1 0 1 0 1 1 1 1 	1 1 1 1 1 0 0 1 
*	1 0 1 1 0 0 0 1 	0 0 1 0 0 0 0 0 
*	0 0 1 1 1 1 0 1 	0 0 0 1 0 1 0 0 
*
* S = EC B0 51 0C 6D 3E 94 D4
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_184 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[2] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	0 0 1 1 0 1 0 1 
	*	0 0 0 1 0 0 1 0 
	*	0 0 1 1 0 1 1 1 
	*	1 0 0 1 1 0 1 1 
	*	0 1 0 1 0 0 0 1 
	*	1 0 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[4] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 185
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 0 0 0 0 0 1 0 
*	0 1 1 1 1 1 0 0 	0 1 1 1 1 1 1 1 
*	1 0 1 0 1 1 0 0 	0 0 1 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 0 0 1 1 1 0 1 
*	0 0 1 1 0 1 1 0 	0 0 1 0 0 1 1 1 
*	1 0 0 1 1 0 0 1 	1 0 1 0 0 1 1 1 
*	1 0 0 0 1 1 0 0 	0 0 0 1 0 0 0 0 
*	1 0 1 1 0 0 0 1 	0 0 1 1 1 1 0 0 
*
* S = 5C EC 5D 51 53 6D 40 94
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_185 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[1] = in[7] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	0 0 1 0 1 1 1 1 
	*	0 0 1 1 0 0 0 1 
	*	0 0 1 0 1 1 1 0 
	*	0 1 1 1 0 1 1 0 
	*	1 1 1 1 0 0 1 1 
	*	0 1 1 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 186
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 0 0 0 0 0 1 0 
*	0 1 1 1 0 0 0 0 	1 1 0 1 0 1 0 1 
*	1 0 1 0 1 1 0 0 	0 0 1 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 0 1 1 0 1 1 1 
*	0 0 1 1 0 1 1 0 	0 0 1 0 1 1 0 1 
*	1 0 1 0 1 1 1 1 	1 0 1 0 1 1 0 1 
*	1 0 0 0 1 1 0 0 	0 0 1 1 0 0 0 0 
*	0 0 1 1 1 1 0 1 	0 0 0 1 0 1 0 0 
*
* S = 5C B0 5D 0C 53 3E 40 D4
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_186 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[3] ^ in[2];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	0 0 1 0 0 1 0 1 
	*	0 0 0 1 0 0 1 1 
	*	0 0 1 0 0 1 1 0 
	*	1 1 0 1 1 1 1 0 
	*	0 1 0 1 0 0 0 1 
	*	1 1 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 187
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 1 1 1 0 1 1 
*	1 1 0 1 1 1 1 0 	0 0 1 1 0 1 0 0 
*	1 1 0 1 1 1 0 0 	1 0 1 1 1 0 1 1 
*	0 0 0 0 1 1 1 0 	0 0 0 1 1 1 1 1 
*	0 0 1 0 1 0 0 0 	1 0 1 1 0 0 1 1 
*	1 0 0 1 0 0 1 0 	1 1 0 0 0 0 1 1 
*	0 0 1 0 0 0 1 1 	0 1 1 0 0 0 0 0 
*	1 0 0 0 0 1 1 1 	1 1 0 1 1 0 0 1 
*
* S = BD BC 50 B1 F9 EA 87 2D
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_187 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[1];
	assign g_in[1] = in[5] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	1 0 1 1 0 1 0 0 
	*	1 1 0 1 0 1 1 0 
	*	1 0 1 1 0 0 1 0 
	*	0 0 1 1 0 1 0 1 
	*	0 1 0 0 1 1 0 1 
	*	0 0 1 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 188
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 0 0 1 1 0 
*	0 1 1 1 1 1 1 0 	0 0 1 0 1 1 0 0 
*	1 1 0 1 0 0 1 0 	0 1 1 0 0 1 1 0 
*	1 1 0 1 1 1 0 0 	0 0 1 1 1 0 1 0 
*	1 0 1 1 1 0 1 0 	0 1 1 0 0 0 1 0 
*	0 0 1 0 1 0 0 0 	1 0 0 0 0 0 1 0 
*	1 0 1 0 0 1 0 0 	1 1 0 1 0 0 0 0 
*	0 0 1 0 0 0 1 1 	1 0 1 1 0 1 1 1 
*
* S = 01 BD E1 50 13 F9 AA 87
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_188 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[3];
	assign g_in[1] = in[7] ^ in[5] ^ in[2];
	assign g_in[0] = in[5] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	0 1 1 0 1 1 0 0 
	*	1 0 1 1 1 1 0 1 
	*	0 1 1 0 0 0 0 1 
	*	0 0 1 0 1 1 1 1 
	*	1 1 0 0 1 0 1 1 
	*	0 0 1 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 189
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 0 1 1 1 0 
*	1 1 0 1 1 1 1 0 	0 0 1 0 0 1 0 0 
*	1 1 0 1 0 0 1 0 	1 1 1 0 1 1 1 0 
*	0 0 0 0 1 1 1 0 	0 0 0 1 1 0 1 0 
*	1 0 1 1 1 0 1 0 	1 1 1 0 0 0 1 0 
*	1 0 0 1 0 0 1 0 	1 0 0 0 0 0 1 0 
*	1 0 1 0 0 1 0 0 	0 1 1 1 0 0 0 0 
*	1 0 0 0 0 1 1 1 	1 0 0 1 1 1 0 1 
*
* S = 01 BC E1 B1 13 EA AA 2D
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_189 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[2];
	assign g_in[0] = in[7] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	1 1 1 0 0 1 0 0 
	*	1 0 0 1 0 1 1 1 
	*	1 1 1 0 0 0 1 1 
	*	0 0 1 0 0 1 0 1 
	*	0 1 0 0 1 0 0 1 
	*	0 0 1 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 190
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 1 1 0 1 1 1 
*	1 1 0 1 1 1 1 0 	1 1 1 1 0 1 0 0 
*	1 0 1 0 0 0 1 0 	0 1 1 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 1 0 1 0 0 1 1 
*	0 0 1 0 1 0 0 0 	0 1 1 1 1 1 1 1 
*	1 0 0 1 0 0 1 0 	1 1 0 0 1 1 1 1 
*	0 0 0 0 1 0 1 1 	1 1 1 0 0 0 0 0 
*	0 0 0 1 0 1 0 1 	1 0 0 1 1 1 0 1 
*
* S = BD BC ED 0D F9 EA 7E C7
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_190 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[1];
	assign g_in[1] = in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	0 1 1 1 0 1 0 0 
	*	1 0 0 1 1 1 1 0 
	*	0 1 1 1 1 0 1 0 
	*	1 1 1 1 0 0 0 1 
	*	0 1 0 0 1 0 0 1 
	*	1 1 1 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 191
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 0 1 1 1 0 
*	0 1 1 1 1 1 1 0 	1 0 1 0 1 1 0 0 
*	0 1 1 1 0 0 1 0 	1 1 1 0 1 1 1 0 
*	1 0 1 0 0 0 1 0 	1 1 1 1 0 0 1 0 
*	1 0 1 1 1 0 1 0 	1 1 1 0 1 0 1 0 
*	0 0 1 0 1 0 0 0 	1 0 0 0 1 0 1 0 
*	0 0 0 1 1 1 1 0 	1 0 0 1 0 0 0 0 
*	0 0 0 0 1 0 1 1 	0 1 1 1 1 0 1 1 
*
* S = 01 BD E0 ED 13 F9 B9 7E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_191 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[3];
	assign g_in[1] = in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	1 1 1 0 1 1 0 0 
	*	0 1 1 1 1 0 0 1 
	*	1 1 1 0 0 1 0 1 
	*	1 0 1 0 0 0 1 1 
	*	1 1 0 0 0 1 1 1 
	*	1 0 1 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 192
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 0 0 1 1 0 
*	1 1 0 1 1 1 1 0 	1 0 1 0 0 1 0 0 
*	0 1 1 1 0 0 1 0 	0 1 1 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 1 0 1 0 0 1 0 
*	1 0 1 1 1 0 1 0 	0 1 1 0 1 0 1 0 
*	1 0 0 1 0 0 1 0 	1 0 0 0 1 0 1 0 
*	0 0 0 1 1 1 1 0 	1 0 1 1 0 0 0 0 
*	0 0 0 1 0 1 0 1 	1 1 0 1 1 0 0 1 
*
* S = 01 BC E0 0D 13 EA B9 C7
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_192 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[1];
	assign g_in[1] = in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	0 1 1 0 0 1 0 0 
	*	1 1 0 1 1 0 1 1 
	*	0 1 1 0 1 1 1 1 
	*	1 0 1 0 0 0 0 1 
	*	0 1 0 0 1 1 0 1 
	*	1 0 1 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 193
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 1 1 1 1 1 1 
*	1 1 0 1 1 1 1 0 	0 1 1 1 0 1 0 0 
*	0 1 1 1 1 1 0 0 	1 1 1 1 1 1 1 1 
*	0 1 1 1 0 0 0 0 	1 0 0 1 1 0 1 1 
*	0 0 1 0 1 0 0 0 	1 1 1 1 0 1 1 1 
*	1 0 0 1 0 0 1 0 	1 1 0 0 0 1 1 1 
*	1 0 0 1 1 0 0 1 	1 0 1 0 0 0 0 0 
*	1 0 1 0 1 1 1 1 	0 1 0 1 0 0 0 1 
*
* S = BD BC EC B0 F9 EA 6D 3E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_193 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[1];
	assign g_in[1] = in[7] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	1 1 1 1 0 1 0 0 
	*	0 1 0 1 1 0 1 0 
	*	1 1 1 1 1 1 1 0 
	*	0 1 1 1 1 1 0 1 
	*	0 1 0 0 0 1 0 1 
	*	0 1 1 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 194
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 0 1 0 1 0 
*	0 1 1 1 1 1 1 0 	1 1 1 0 1 1 0 0 
*	0 0 0 0 1 1 0 0 	1 0 1 0 1 0 1 0 
*	0 1 1 1 1 1 0 0 	0 1 1 1 0 1 1 0 
*	1 0 1 1 1 0 1 0 	1 0 1 0 1 1 1 0 
*	0 0 1 0 1 0 0 0 	1 0 0 0 1 1 1 0 
*	0 0 1 1 0 1 1 0 	0 1 0 1 0 0 0 0 
*	1 0 0 1 1 0 0 1 	1 1 1 1 0 0 1 1 
*
* S = 01 BD 5C EC 13 F9 53 6D
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_194 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[3];
	assign g_in[1] = in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 0 1 0 1 1 0 0 
	*	1 1 1 1 0 1 0 1 
	*	1 0 1 0 1 0 0 1 
	*	1 1 1 0 1 0 1 1 
	*	1 1 0 0 1 1 1 1 
	*	1 1 1 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 195
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 0 1 0 1 0 
*	1 1 0 1 1 1 1 0 	0 1 1 0 0 1 0 0 
*	0 0 0 0 1 1 0 0 	1 0 1 0 1 0 1 0 
*	0 1 1 1 0 0 0 0 	1 1 0 1 1 1 1 0 
*	1 0 1 1 1 0 1 0 	1 0 1 0 0 1 1 0 
*	1 0 0 1 0 0 1 0 	1 0 0 0 0 1 1 0 
*	0 0 1 1 0 1 1 0 	1 1 1 1 0 0 0 0 
*	1 0 1 0 1 1 1 1 	0 1 0 1 0 0 0 1 
*
* S = 01 BC 5C B0 13 EA 53 3E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_195 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[1];
	assign g_in[1] = in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	1 0 1 0 0 1 0 0 
	*	0 1 0 1 1 1 1 1 
	*	1 0 1 0 1 0 1 1 
	*	0 1 1 0 1 0 0 1 
	*	0 1 0 0 0 1 0 1 
	*	0 1 1 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 196
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 1 1 0 0 1 1 
*	1 1 0 1 1 1 1 0 	1 0 1 1 0 1 0 0 
*	0 0 0 0 0 0 1 0 	0 0 1 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 1 0 1 0 1 1 1 
*	0 0 1 0 1 0 0 0 	0 0 1 1 1 0 1 1 
*	1 0 0 1 0 0 1 0 	1 1 0 0 1 0 1 1 
*	1 0 1 1 0 0 0 1 	0 0 1 0 0 0 0 0 
*	0 0 1 1 1 1 0 1 	0 0 0 1 0 1 0 1 
*
* S = BD BC 51 0C F9 EA 94 D4
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_196 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	0 0 1 1 0 1 0 0 
	*	0 0 0 1 0 0 1 0 
	*	0 0 1 1 0 1 1 0 
	*	1 0 1 1 1 0 0 1 
	*	0 1 0 0 0 0 0 1 
	*	1 0 1 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 197
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 0 0 0 1 0 
*	0 1 1 1 1 1 1 0 	0 1 1 0 1 1 0 0 
*	1 0 1 0 1 1 0 0 	0 0 1 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 0 1 1 1 1 1 0 
*	1 0 1 1 1 0 1 0 	0 0 1 0 0 1 1 0 
*	0 0 1 0 1 0 0 0 	1 0 0 0 0 1 1 0 
*	1 0 0 0 1 1 0 0 	0 0 0 1 0 0 0 0 
*	1 0 1 1 0 0 0 1 	0 0 1 1 1 1 1 1 
*
* S = 01 BD 5D 51 13 F9 40 94
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_197 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[3];
	assign g_in[1] = in[7] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	0 0 1 0 1 1 0 0 
	*	0 0 1 1 0 0 0 1 
	*	0 0 1 0 1 1 0 1 
	*	0 1 1 0 0 1 1 1 
	*	1 1 0 0 0 0 1 1 
	*	0 1 1 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 198
*
* GF(2^8) Poly Basis: [d^2, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 0 0 0 1 0 
*	1 1 0 1 1 1 1 0 	1 1 1 0 0 1 0 0 
*	1 0 1 0 1 1 0 0 	0 0 1 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 0 0 1 0 1 1 0 
*	1 0 1 1 1 0 1 0 	0 0 1 0 1 1 1 0 
*	1 0 0 1 0 0 1 0 	1 0 0 0 1 1 1 0 
*	1 0 0 0 1 1 0 0 	0 0 1 1 0 0 0 0 
*	0 0 1 1 1 1 0 1 	0 0 0 1 0 1 0 1 
*
* S = 01 BC 5D 0C 13 EA 40 D4
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_198 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[1];
	assign g_in[1] = in[7] ^ in[3] ^ in[2];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	0 0 1 0 0 1 0 0 
	*	0 0 0 1 0 0 1 1 
	*	0 0 1 0 0 1 1 1 
	*	1 1 1 0 1 1 0 1 
	*	0 1 0 0 0 0 0 1 
	*	1 1 1 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 199
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	1 1 1 1 0 1 1 0 
*	0 0 0 0 1 1 1 0 	1 0 0 1 0 1 0 1 
*	1 0 1 0 0 0 1 0 	0 0 0 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 1 1 1 0 0 1 1 
*	1 1 1 1 1 1 1 1 	1 0 1 0 1 1 0 0 
*	1 0 0 0 1 0 0 1 	0 0 1 1 1 1 0 0 
*	1 0 1 0 1 0 0 1 	1 1 0 1 0 0 0 0 
*	1 1 0 0 0 1 0 1 	0 1 0 1 1 1 1 0 
*
* S = 50 B1 ED 0D D7 9C 93 CA
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_199 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[7] ^ in[3] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	0 0 1 1 0 1 0 1 
	*	0 1 1 0 1 1 0 1 
	*	1 1 1 0 1 0 0 0 
	*	1 1 0 1 0 0 0 1 
	*	1 1 1 0 1 0 1 1 
	*	0 1 0 0 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 200
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 0 1 0 1 1 0 1 
*	1 1 0 1 1 1 0 0 	0 1 1 1 1 1 1 1 
*	0 1 1 1 0 0 1 0 	0 0 0 0 1 1 0 1 
*	1 0 1 0 0 0 1 0 	1 1 1 0 0 0 1 0 
*	0 1 1 1 0 1 1 0 	0 1 0 1 1 0 0 0 
*	1 1 1 1 1 1 1 1 	0 0 1 0 1 0 0 0 
*	0 1 1 0 1 1 0 0 	1 0 1 1 0 0 0 0 
*	1 0 1 0 1 0 0 1 	1 1 1 1 1 0 0 1 
*
* S = E1 50 E0 ED 4B D7 59 93
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_200 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	0 0 1 0 1 1 1 1 
	*	1 1 0 1 1 0 1 1 
	*	1 0 0 1 0 1 0 0 
	*	1 0 1 1 0 0 1 1 
	*	1 0 0 1 0 1 1 0 
	*	1 1 0 0 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 201
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 0 1 0 0 1 1 1 
*	0 0 0 0 1 1 1 0 	1 1 0 1 0 1 0 1 
*	0 1 1 1 0 0 1 0 	0 0 0 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 1 1 0 0 0 1 0 
*	0 1 1 1 0 1 1 0 	1 1 1 1 1 0 0 0 
*	1 0 0 0 1 0 0 1 	0 0 1 0 1 0 0 0 
*	0 1 1 0 1 1 0 0 	1 0 0 1 0 0 0 0 
*	1 1 0 0 0 1 0 1 	0 1 0 1 1 0 1 1 
*
* S = E1 B1 E0 0D 4B 9C 59 CA
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_201 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[3] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	0 0 1 0 0 1 0 1 
	*	0 1 1 1 1 0 0 1 
	*	1 0 1 1 1 1 0 0 
	*	1 0 0 1 0 0 0 1 
	*	1 0 1 1 1 1 1 0 
	*	0 1 0 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 202
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	1 1 1 1 0 0 1 1 
*	0 1 1 1 0 0 0 0 	1 1 0 0 0 1 0 1 
*	0 0 0 0 0 0 1 0 	0 0 0 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 0 0 0 0 1 1 0 
*	1 1 1 0 0 1 0 1 	1 0 1 0 1 0 0 1 
*	1 1 0 1 1 1 1 1 	0 1 1 0 1 0 0 1 
*	1 0 1 1 0 0 1 1 	0 0 1 0 0 0 0 0 
*	1 0 0 1 0 0 1 1 	0 1 0 1 0 1 0 0 
*
* S = EC B0 51 0C 81 8E C5 D8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_202 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	0 1 1 0 0 1 0 1 
	*	0 0 1 1 0 0 1 0 
	*	0 1 0 0 0 1 1 1 
	*	0 0 1 0 1 0 1 1 
	*	0 1 0 0 0 0 0 1 
	*	1 1 1 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 203
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 0 1 0 0 0 1 0 
*	0 1 1 1 1 1 0 0 	1 0 0 0 1 1 1 1 
*	1 0 1 0 1 1 0 0 	0 0 0 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 1 0 0 1 1 0 1 
*	0 0 1 1 1 0 1 0 	0 1 0 1 0 1 1 1 
*	1 1 1 0 0 1 0 1 	1 1 0 1 0 1 1 1 
*	0 0 1 0 0 0 0 0 	0 0 0 1 0 0 0 0 
*	1 0 1 1 0 0 1 1 	1 1 1 1 1 1 0 0 
*
* S = 5C EC 5D 51 0F 81 1D C5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_203 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[1] = in[5];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	1 1 0 1 1 1 1 1 
	*	0 0 1 0 0 0 0 1 
	*	1 1 0 0 1 1 1 0 
	*	0 0 0 1 0 1 1 0 
	*	1 1 0 0 0 0 1 1 
	*	1 0 0 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 204
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 0 1 0 0 0 1 0 
*	0 1 1 1 0 0 0 0 	1 0 0 0 0 1 0 1 
*	1 0 1 0 1 1 0 0 	0 0 0 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 1 0 0 0 1 1 1 
*	0 0 1 1 1 0 1 0 	1 1 1 1 1 1 0 1 
*	1 1 0 1 1 1 1 1 	0 1 1 1 1 1 0 1 
*	0 0 1 0 0 0 0 0 	0 0 1 1 0 0 0 0 
*	1 0 0 1 0 0 1 1 	0 1 0 1 0 1 0 0 
*
* S = 5C B0 5D 0C 0F 8E 1D D8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_204 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[5];
	assign g_in[0] = in[7] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	0 1 1 1 0 1 0 1 
	*	0 0 1 0 0 0 1 1 
	*	0 1 0 0 0 1 1 0 
	*	0 0 1 1 1 1 1 0 
	*	0 1 0 0 0 0 0 1 
	*	1 0 1 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 205
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 0 0 1 0 1 1 
*	1 1 0 1 1 1 1 0 	0 1 1 1 0 1 0 0 
*	1 1 0 1 1 1 0 0 	0 0 0 0 1 0 1 1 
*	0 0 0 0 1 1 1 0 	1 1 1 0 1 1 1 1 
*	0 1 0 1 0 1 1 0 	1 0 0 0 0 0 1 1 
*	0 1 0 0 1 1 0 0 	1 1 1 1 0 0 1 1 
*	1 1 1 1 1 1 1 1 	0 1 1 0 0 0 0 0 
*	1 0 0 0 1 0 0 1 	0 1 0 0 1 0 0 1 
*
* S = BD BC 50 B1 44 56 D7 9C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_205 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	1 1 1 1 0 1 0 0 
	*	1 0 1 1 0 1 1 0 
	*	1 0 0 1 0 0 1 0 
	*	0 1 1 0 0 1 0 1 
	*	1 0 0 1 1 1 0 1 
	*	0 0 0 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 206
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 0 0 1 1 0 
*	0 1 1 1 1 1 1 0 	1 1 1 0 1 1 0 0 
*	1 1 0 1 0 0 1 0 	0 0 0 0 0 1 1 0 
*	1 1 0 1 1 1 0 0 	1 0 0 1 1 0 1 0 
*	0 0 0 1 1 0 1 0 	0 1 0 0 0 0 1 0 
*	0 1 0 1 0 1 1 0 	1 0 1 0 0 0 1 0 
*	0 1 1 1 0 1 1 0 	1 1 0 1 0 0 0 0 
*	1 1 1 1 1 1 1 1 	1 1 0 0 0 1 1 1 
*
* S = 01 BD E1 50 12 44 4B D7
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_206 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	1 0 1 0 1 1 0 0 
	*	0 1 1 0 1 1 0 1 
	*	0 1 1 1 0 0 0 1 
	*	1 1 0 1 1 1 1 1 
	*	0 1 1 1 1 0 1 1 
	*	0 0 1 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 207
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 0 1 1 1 0 
*	1 1 0 1 1 1 1 0 	0 1 1 0 0 1 0 0 
*	1 1 0 1 0 0 1 0 	0 0 0 0 1 1 1 0 
*	0 0 0 0 1 1 1 0 	1 0 1 1 1 0 1 0 
*	0 0 0 1 1 0 1 0 	1 1 0 0 0 0 1 0 
*	0 1 0 0 1 1 0 0 	1 0 1 0 0 0 1 0 
*	0 1 1 1 0 1 1 0 	0 1 1 1 0 0 0 0 
*	1 0 0 0 1 0 0 1 	0 1 0 0 1 1 0 1 
*
* S = 01 BC E1 B1 12 56 4B 9C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_207 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	1 0 1 0 0 1 0 0 
	*	1 1 1 0 0 1 1 1 
	*	1 1 0 1 0 0 1 1 
	*	0 1 1 1 0 1 0 1 
	*	1 1 0 1 1 0 0 1 
	*	0 0 0 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 208
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 0 0 0 1 1 1 
*	1 1 0 1 1 1 1 0 	1 0 1 1 0 1 0 0 
*	1 0 1 0 0 0 1 0 	0 0 0 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 1 1 0 0 0 1 1 
*	0 1 0 1 0 1 1 0 	1 0 0 0 1 1 1 1 
*	0 1 0 0 1 1 0 0 	0 0 1 1 1 1 1 1 
*	1 0 1 0 1 0 0 1 	1 1 1 0 0 0 0 0 
*	1 1 0 0 0 1 0 1 	0 1 0 0 1 1 0 1 
*
* S = BD BC ED 0D 44 56 93 CA
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_208 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	0 0 1 1 0 1 0 0 
	*	0 1 1 1 1 1 1 0 
	*	1 1 0 1 1 0 1 0 
	*	1 1 1 0 0 0 0 1 
	*	1 1 0 1 1 0 0 1 
	*	0 1 0 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 209
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 0 1 1 1 0 
*	0 1 1 1 1 1 1 0 	0 1 1 0 1 1 0 0 
*	0 1 1 1 0 0 1 0 	0 0 0 0 1 1 1 0 
*	1 0 1 0 0 0 1 0 	1 1 0 1 0 0 1 0 
*	0 0 0 1 1 0 1 0 	0 1 0 0 1 0 1 0 
*	0 1 0 1 0 1 1 0 	0 0 1 0 1 0 1 0 
*	0 1 1 0 1 1 0 0 	1 0 0 1 0 0 0 0 
*	1 0 1 0 1 0 0 1 	1 1 0 0 1 0 1 1 
*
* S = 01 BD E0 ED 12 44 59 93
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_209 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	0 0 1 0 1 1 0 0 
	*	1 1 1 0 1 0 0 1 
	*	1 0 1 1 0 1 0 1 
	*	1 0 0 1 0 0 1 1 
	*	1 0 1 1 0 1 1 1 
	*	1 1 1 1 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 210
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 0 0 1 1 0 
*	1 1 0 1 1 1 1 0 	1 1 1 0 0 1 0 0 
*	0 1 1 1 0 0 1 0 	0 0 0 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 1 1 1 0 0 1 0 
*	0 0 0 1 1 0 1 0 	1 1 0 0 1 0 1 0 
*	0 1 0 0 1 1 0 0 	0 0 1 0 1 0 1 0 
*	0 1 1 0 1 1 0 0 	1 0 1 1 0 0 0 0 
*	1 1 0 0 0 1 0 1 	0 1 0 0 1 0 0 1 
*
* S = 01 BC E0 0D 12 56 59 CA
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_210 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	0 0 1 0 0 1 0 0 
	*	0 1 1 0 1 0 1 1 
	*	1 0 0 1 1 1 1 1 
	*	1 0 1 1 0 0 0 1 
	*	1 0 0 1 1 1 0 1 
	*	0 1 0 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 211
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 0 0 1 1 1 1 
*	1 1 0 1 1 1 1 0 	0 0 1 1 0 1 0 0 
*	0 1 1 1 1 1 0 0 	0 0 0 0 1 1 1 1 
*	0 1 1 1 0 0 0 0 	0 0 1 0 1 0 1 1 
*	0 1 0 1 0 1 1 0 	1 0 0 0 0 1 1 1 
*	0 1 0 0 1 1 0 0 	1 0 1 1 0 1 1 1 
*	1 1 1 0 0 1 0 1 	1 0 1 0 0 0 0 0 
*	1 1 0 1 1 1 1 1 	0 1 0 0 0 0 0 1 
*
* S = BD BC EC B0 44 56 81 8E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_211 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	1 0 1 1 0 1 0 0 
	*	1 1 1 1 1 0 1 0 
	*	0 0 0 1 1 1 1 0 
	*	1 0 1 0 1 1 0 1 
	*	0 0 0 1 0 1 0 1 
	*	1 0 0 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 212
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 0 1 0 1 0 
*	0 1 1 1 1 1 1 0 	0 0 1 0 1 1 0 0 
*	0 0 0 0 1 1 0 0 	0 0 0 0 1 0 1 0 
*	0 1 1 1 1 1 0 0 	0 0 0 1 0 1 1 0 
*	0 0 0 1 1 0 1 0 	0 1 0 0 1 1 1 0 
*	0 1 0 1 0 1 1 0 	0 1 1 0 1 1 1 0 
*	0 0 1 1 1 0 1 0 	0 1 0 1 0 0 0 0 
*	1 1 1 0 0 1 0 1 	1 1 0 0 0 0 1 1 
*
* S = 01 BD 5C EC 12 44 0F 81
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_212 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	0 1 1 0 1 1 0 0 
	*	1 0 1 0 0 1 0 1 
	*	0 0 1 1 1 0 0 1 
	*	0 1 0 1 1 0 1 1 
	*	0 0 1 1 1 1 1 1 
	*	0 1 1 1 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 213
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 0 1 0 1 0 
*	1 1 0 1 1 1 1 0 	0 0 1 0 0 1 0 0 
*	0 0 0 0 1 1 0 0 	0 0 0 0 1 0 1 0 
*	0 1 1 1 0 0 0 0 	0 0 1 1 1 1 1 0 
*	0 0 0 1 1 0 1 0 	1 1 0 0 0 1 1 0 
*	0 1 0 0 1 1 0 0 	1 1 1 0 0 1 1 0 
*	0 0 1 1 1 0 1 0 	1 1 1 1 0 0 0 0 
*	1 1 0 1 1 1 1 1 	0 1 0 0 0 0 0 1 
*
* S = 01 BC 5C B0 12 56 0F 8E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_213 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	1 1 1 0 0 1 0 0 
	*	1 0 1 0 1 1 1 1 
	*	0 0 0 1 1 0 1 1 
	*	1 1 1 1 1 0 0 1 
	*	0 0 0 1 0 1 0 1 
	*	1 1 0 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 214
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 0 0 0 0 1 1 
*	1 1 0 1 1 1 1 0 	1 1 1 1 0 1 0 0 
*	0 0 0 0 0 0 1 0 	0 0 0 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 0 1 0 0 1 1 1 
*	0 1 0 1 0 1 1 0 	1 0 0 0 1 0 1 1 
*	0 1 0 0 1 1 0 0 	0 1 1 1 1 0 1 1 
*	1 0 1 1 0 0 1 1 	0 0 1 0 0 0 0 0 
*	1 0 0 1 0 0 1 1 	0 1 0 0 0 1 0 1 
*
* S = BD BC 51 0C 44 56 C5 D8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_214 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	0 1 1 1 0 1 0 0 
	*	0 0 1 1 0 0 1 0 
	*	0 1 0 1 0 1 1 0 
	*	0 0 1 0 1 0 0 1 
	*	0 1 0 1 0 0 0 1 
	*	1 1 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 215
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 0 0 0 1 0 
*	0 1 1 1 1 1 1 0 	1 0 1 0 1 1 0 0 
*	1 0 1 0 1 1 0 0 	0 0 0 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 1 0 1 1 1 1 0 
*	0 0 0 1 1 0 1 0 	0 1 0 0 0 1 1 0 
*	0 1 0 1 0 1 1 0 	1 1 1 0 0 1 1 0 
*	0 0 1 0 0 0 0 0 	0 0 0 1 0 0 0 0 
*	1 0 1 1 0 0 1 1 	1 1 0 0 1 1 1 1 
*
* S = 01 BD 5D 51 12 44 1D C5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_215 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[5];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	1 1 1 0 1 1 0 0 
	*	0 0 1 0 0 0 0 1 
	*	1 1 1 1 1 1 0 1 
	*	0 0 0 1 0 1 1 1 
	*	1 1 1 1 0 0 1 1 
	*	1 0 1 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 216
*
* GF(2^8) Poly Basis: [d^32, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 0 0 0 1 0 
*	1 1 0 1 1 1 1 0 	1 0 1 0 0 1 0 0 
*	1 0 1 0 1 1 0 0 	0 0 0 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 1 1 1 0 1 1 0 
*	0 0 0 1 1 0 1 0 	1 1 0 0 1 1 1 0 
*	0 1 0 0 1 1 0 0 	0 1 1 0 1 1 1 0 
*	0 0 1 0 0 0 0 0 	0 0 1 1 0 0 0 0 
*	1 0 0 1 0 0 1 1 	0 1 0 0 0 1 0 1 
*
* S = 01 BC 5D 0C 12 56 1D D8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_216 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[3] ^ in[2];
	assign g_in[1] = in[5];
	assign g_in[0] = in[7] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	0 1 1 0 0 1 0 0 
	*	0 0 1 0 0 0 1 1 
	*	0 1 0 1 0 1 1 1 
	*	0 0 1 1 1 1 0 1 
	*	0 1 0 1 0 0 0 1 
	*	1 0 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 217
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 0 1 1 	1 0 1 0 0 1 1 0 
*	1 1 0 1 1 0 0 1 	0 0 0 0 0 1 0 1 
*	0 1 1 1 0 1 0 1 	0 1 0 1 0 1 1 0 
*	0 0 0 0 0 1 1 1 	1 0 1 1 0 0 1 1 
*	0 1 0 1 0 0 1 1 	0 0 0 1 1 1 0 0 
*	0 1 0 1 1 1 0 0 	1 0 0 0 1 1 0 0 
*	1 0 1 0 0 0 1 0 	1 1 0 1 0 0 0 0 
*	0 0 0 1 1 1 0 0 	0 1 1 0 1 1 1 0 
*
* S = 50 B1 ED 0D 3A 91 23 96
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_217 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[1] ^ in[0];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[4] = in[2] ^ in[1] ^ in[0];
	assign g_in[3] = in[6] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[1];
	assign g_in[0] = in[4] ^ in[3] ^ in[2];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	1 0 1 0 0 1 0 1 
	*	1 0 0 1 1 1 0 1 
	*	1 0 0 0 1 0 0 0 
	*	1 0 0 1 0 0 0 1 
	*	0 1 0 0 1 0 1 1 
	*	0 0 1 0 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[3];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 218
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 1 0 1 1 1 0 1 
*	1 1 0 1 1 1 0 0 	0 0 0 0 1 1 1 1 
*	0 1 1 1 0 0 1 0 	1 1 1 1 1 1 0 1 
*	1 0 1 0 0 0 1 0 	0 1 1 0 0 0 1 0 
*	1 1 0 1 1 0 0 0 	0 0 1 1 1 0 0 0 
*	0 1 0 1 0 0 1 1 	0 1 0 0 1 0 0 0 
*	1 0 1 1 1 1 1 0 	1 0 1 1 0 0 0 0 
*	0 1 1 1 0 1 0 1 	1 1 0 1 1 0 0 1 
*
* S = E1 50 E0 ED AB 3A B5 23
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_218 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[3];
	assign g_in[2] = in[6] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	0 1 0 1 1 1 1 1 
	*	0 1 1 1 1 0 1 1 
	*	0 1 0 0 0 1 0 0 
	*	0 1 1 1 0 0 1 1 
	*	1 1 0 0 0 1 1 0 
	*	0 0 0 1 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[2];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[4] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 219
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 1 1 1 0 1 1 1 
*	0 0 0 0 1 1 1 0 	0 0 0 0 0 1 0 1 
*	0 1 1 1 0 0 1 0 	0 1 0 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 1 1 0 0 0 1 0 
*	1 1 0 1 1 0 0 0 	0 0 0 1 1 0 0 0 
*	1 0 0 0 1 0 1 1 	1 1 0 0 1 0 0 0 
*	1 0 1 1 1 1 1 0 	1 0 0 1 0 0 0 0 
*	1 1 0 0 1 0 1 1 	0 1 1 1 1 0 1 1 
*
* S = E1 B1 E0 0D AB 91 B5 96
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_219 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	1 1 1 1 0 1 0 1 
	*	1 1 0 1 1 0 0 1 
	*	1 1 0 0 1 1 0 0 
	*	1 1 0 1 0 0 0 1 
	*	0 1 0 0 1 1 1 0 
	*	0 0 1 1 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 220
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	1 0 1 0 0 0 1 1 
*	0 1 1 1 0 0 0 0 	0 0 0 0 0 1 0 1 
*	0 0 0 0 0 0 1 0 	0 1 0 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 0 0 1 0 1 1 0 
*	0 0 1 1 0 1 0 1 	1 0 1 1 1 0 0 1 
*	1 0 1 0 1 1 0 1 	0 1 1 1 1 0 0 1 
*	0 0 0 1 0 0 1 1 	0 0 1 0 0 0 0 0 
*	1 1 1 0 1 1 0 1 	0 0 1 1 0 1 0 0 
*
* S = EC B0 51 0C 3D 8F 24 88
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_220 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[2] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[4] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	1 0 1 0 0 1 0 1 
	*	1 1 0 0 0 0 1 0 
	*	0 1 1 1 0 1 1 1 
	*	1 1 0 0 1 0 1 1 
	*	1 1 1 0 0 0 0 1 
	*	1 1 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 221
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 1 0 1 0 0 1 0 
*	0 1 1 1 1 1 0 0 	0 0 0 0 1 1 1 1 
*	1 0 1 0 1 1 0 0 	1 1 1 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 0 1 1 1 1 0 1 
*	1 0 0 1 1 0 0 0 	0 1 1 0 0 1 1 1 
*	0 0 1 1 0 1 0 1 	1 1 1 0 0 1 1 1 
*	1 1 1 1 1 1 1 0 	0 0 0 1 0 0 0 0 
*	0 0 0 1 0 0 1 1 	0 0 1 0 1 1 0 0 
*
* S = 5C EC 5D 51 B2 3D AC 24
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_221 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[3];
	assign g_in[2] = in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	0 1 0 1 1 1 1 1 
	*	1 0 0 0 0 0 0 1 
	*	1 1 1 0 1 1 1 0 
	*	1 0 0 0 0 1 1 0 
	*	1 0 0 1 0 0 1 1 
	*	1 0 1 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 222
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 1 1 1 0 0 1 0 
*	0 1 1 1 0 0 0 0 	0 0 0 0 0 1 0 1 
*	1 0 1 0 1 1 0 0 	0 1 0 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 0 0 1 0 1 1 1 
*	1 0 0 1 1 0 0 0 	1 1 1 0 1 1 0 1 
*	1 0 1 0 1 1 0 1 	0 1 1 0 1 1 0 1 
*	1 1 1 1 1 1 1 0 	0 0 1 1 0 0 0 0 
*	1 1 1 0 1 1 0 1 	0 0 1 0 0 1 0 0 
*
* S = 5C B0 5D 0C B2 8F AC 88
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_222 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	1 1 1 1 0 1 0 1 
	*	1 0 0 0 0 0 1 1 
	*	0 1 1 0 0 1 1 0 
	*	1 0 0 0 1 1 1 0 
	*	1 0 1 1 0 0 0 1 
	*	1 0 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 223
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 0 0 1 0 1 1 
*	1 1 0 1 1 1 1 0 	0 0 0 0 0 1 0 0 
*	1 1 0 1 1 1 0 0 	0 1 0 0 1 0 1 1 
*	0 0 0 0 1 1 1 0 	1 1 0 1 1 1 1 1 
*	0 0 1 0 0 1 1 0 	0 1 0 1 0 0 1 1 
*	0 1 0 0 0 0 0 0 	0 0 1 0 0 0 1 1 
*	0 1 0 1 0 0 1 1 	0 1 1 0 0 0 0 0 
*	1 0 0 0 1 0 1 1 	1 0 1 1 1 0 0 1 
*
* S = BD BC 50 B1 19 07 3A 91
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_223 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[6];
	assign g_in[1] = in[6] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	1 0 0 0 0 1 0 0 
	*	0 1 1 1 0 1 1 0 
	*	0 0 1 0 0 0 1 0 
	*	0 1 1 1 0 1 0 1 
	*	0 0 0 1 1 1 0 1 
	*	1 0 1 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 224
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 0 0 1 1 0 
*	0 1 1 1 1 1 1 0 	0 0 0 0 1 1 0 0 
*	1 1 0 1 0 0 1 0 	1 1 0 0 0 1 1 0 
*	1 1 0 1 1 1 0 0 	1 0 1 1 1 0 1 0 
*	0 1 1 0 0 1 1 0 	1 1 1 1 0 0 1 0 
*	0 0 1 0 0 1 1 0 	0 0 0 1 0 0 1 0 
*	1 1 0 1 1 0 0 0 	1 1 0 1 0 0 0 0 
*	0 1 0 1 0 0 1 1 	0 1 1 0 0 1 1 1 
*
* S = 01 BD E1 50 1E 19 AB 3A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_224 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3];
	assign g_in[0] = in[6] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	0 1 0 0 1 1 0 0 
	*	1 1 1 0 1 1 0 1 
	*	0 0 0 1 0 0 0 1 
	*	1 1 1 0 1 1 1 1 
	*	0 0 1 1 1 0 1 1 
	*	0 1 0 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 225
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 0 1 1 1 0 
*	1 1 0 1 1 1 1 0 	0 0 0 0 0 1 0 0 
*	1 1 0 1 0 0 1 0 	0 1 0 0 1 1 1 0 
*	0 0 0 0 1 1 1 0 	1 0 0 1 1 0 1 0 
*	0 1 1 0 0 1 1 0 	0 1 0 1 0 0 1 0 
*	0 1 0 0 0 0 0 0 	0 0 1 1 0 0 1 0 
*	1 1 0 1 1 0 0 0 	0 1 1 1 0 0 0 0 
*	1 0 0 0 1 0 1 1 	1 1 1 0 1 1 0 1 
*
* S = 01 BC E1 B1 1E 07 AB 91
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_225 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[6];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3];
	assign g_in[0] = in[7] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	1 1 0 0 0 1 0 0 
	*	0 1 1 0 0 1 1 1 
	*	0 0 1 1 0 0 1 1 
	*	0 1 1 0 0 1 0 1 
	*	0 0 0 1 1 0 0 1 
	*	1 1 1 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 226
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 0 0 0 1 1 1 
*	1 1 0 1 1 1 1 0 	0 0 0 0 0 1 0 0 
*	1 0 1 0 0 0 1 0 	0 1 0 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 0 0 1 0 0 1 1 
*	0 0 1 0 0 1 1 0 	0 0 0 1 1 1 1 1 
*	0 1 0 0 0 0 0 0 	1 0 1 0 1 1 1 1 
*	0 1 1 1 0 1 0 1 	1 1 1 0 0 0 0 0 
*	1 1 0 0 1 0 1 1 	0 1 1 1 1 1 0 1 
*
* S = BD BC ED 0D 19 07 23 96
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_226 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[6];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	1 0 0 0 0 1 0 0 
	*	1 0 1 1 1 1 1 0 
	*	1 0 1 0 1 0 1 0 
	*	1 0 1 1 0 0 0 1 
	*	0 1 0 1 1 0 0 1 
	*	0 0 1 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 227
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 0 1 1 1 0 
*	0 1 1 1 1 1 1 0 	0 0 0 0 1 1 0 0 
*	0 1 1 1 0 0 1 0 	1 1 0 0 1 1 1 0 
*	1 0 1 0 0 0 1 0 	0 1 1 1 0 0 1 0 
*	0 1 1 0 0 1 1 0 	0 0 1 1 1 0 1 0 
*	0 0 1 0 0 1 1 0 	0 1 0 1 1 0 1 0 
*	1 0 1 1 1 1 1 0 	1 0 0 1 0 0 0 0 
*	0 1 1 1 0 1 0 1 	1 1 1 0 1 0 1 1 
*
* S = 01 BD E0 ED 1E 19 B5 23
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_227 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	0 1 0 0 1 1 0 0 
	*	0 1 1 0 1 0 0 1 
	*	0 1 0 1 0 1 0 1 
	*	0 1 1 0 0 0 1 1 
	*	1 1 1 1 0 1 1 1 
	*	0 0 0 1 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 228
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 0 0 1 1 0 
*	1 1 0 1 1 1 1 0 	0 0 0 0 0 1 0 0 
*	0 1 1 1 0 0 1 0 	0 1 0 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 1 0 1 0 0 1 0 
*	0 1 1 0 0 1 1 0 	0 0 0 1 1 0 1 0 
*	0 1 0 0 0 0 0 0 	1 1 1 1 1 0 1 0 
*	1 0 1 1 1 1 1 0 	1 0 1 1 0 0 0 0 
*	1 1 0 0 1 0 1 1 	0 1 1 0 1 0 0 1 
*
* S = 01 BC E0 0D 1E 07 B5 96
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_228 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[6];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	1 1 0 0 0 1 0 0 
	*	1 1 1 0 1 0 1 1 
	*	1 1 1 1 1 1 1 1 
	*	1 1 1 0 0 0 0 1 
	*	0 1 0 1 1 1 0 1 
	*	0 0 1 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 229
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 0 0 1 1 1 1 
*	1 1 0 1 1 1 1 0 	0 0 0 0 0 1 0 0 
*	0 1 1 1 1 1 0 0 	0 1 0 0 1 1 1 1 
*	0 1 1 1 0 0 0 0 	0 1 0 1 1 0 1 1 
*	0 0 1 0 0 1 1 0 	1 1 0 1 0 1 1 1 
*	0 1 0 0 0 0 0 0 	1 1 1 0 0 1 1 1 
*	0 0 1 1 0 1 0 1 	1 0 1 0 0 0 0 0 
*	1 0 1 0 1 1 0 1 	1 1 1 1 0 0 0 1 
*
* S = BD BC EC B0 19 07 3D 8F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_229 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[6];
	assign g_in[1] = in[5] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	1 0 0 0 0 1 0 0 
	*	0 0 1 1 1 0 1 0 
	*	1 1 1 0 1 1 1 0 
	*	0 0 1 1 1 1 0 1 
	*	1 0 0 1 0 1 0 1 
	*	0 1 1 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 230
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 0 1 0 1 0 
*	0 1 1 1 1 1 1 0 	0 0 0 0 1 1 0 0 
*	0 0 0 0 1 1 0 0 	1 1 0 0 1 0 1 0 
*	0 1 1 1 1 1 0 0 	1 1 1 1 0 1 1 0 
*	0 1 1 0 0 1 1 0 	1 0 1 1 1 1 1 0 
*	0 0 1 0 0 1 1 0 	1 0 0 1 1 1 1 0 
*	1 0 0 1 1 0 0 0 	0 1 0 1 0 0 0 0 
*	0 0 1 1 0 1 0 1 	1 0 1 0 0 0 1 1 
*
* S = 01 BD 5C EC 1E 19 B2 3D
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_230 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[4] ^ in[3];
	assign g_in[0] = in[5] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	0 1 0 0 1 1 0 0 
	*	0 0 1 0 0 1 0 1 
	*	1 0 0 1 1 0 0 1 
	*	0 0 1 0 1 0 1 1 
	*	0 1 1 1 1 1 1 1 
	*	1 1 0 1 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 231
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 0 1 0 1 0 
*	1 1 0 1 1 1 1 0 	0 0 0 0 0 1 0 0 
*	0 0 0 0 1 1 0 0 	0 1 0 0 1 0 1 0 
*	0 1 1 1 0 0 0 0 	0 1 0 1 1 1 1 0 
*	0 1 1 0 0 1 1 0 	1 0 0 1 0 1 1 0 
*	0 1 0 0 0 0 0 0 	1 0 1 1 0 1 1 0 
*	1 0 0 1 1 0 0 0 	1 1 1 1 0 0 0 0 
*	1 0 1 0 1 1 0 1 	1 0 1 0 0 0 0 1 
*
* S = 01 BC 5C B0 1E 07 B2 8F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_231 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[6];
	assign g_in[1] = in[7] ^ in[4] ^ in[3];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	1 1 0 0 0 1 0 0 
	*	0 0 1 0 1 1 1 1 
	*	1 0 1 1 1 0 1 1 
	*	0 0 1 0 1 0 0 1 
	*	1 1 0 1 0 1 0 1 
	*	0 1 1 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 232
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 0 0 0 0 1 1 
*	1 1 0 1 1 1 1 0 	0 0 0 0 0 1 0 0 
*	0 0 0 0 0 0 1 0 	0 1 0 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 0 0 1 0 1 1 1 
*	0 0 1 0 0 1 1 0 	1 0 0 1 1 0 1 1 
*	0 1 0 0 0 0 0 0 	0 1 1 0 1 0 1 1 
*	0 0 0 1 0 0 1 1 	0 0 1 0 0 0 0 0 
*	1 1 1 0 1 1 0 1 	0 0 1 1 0 1 0 1 
*
* S = BD BC 51 0C 19 07 24 88
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_232 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[6];
	assign g_in[1] = in[4] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	1 0 0 0 0 1 0 0 
	*	1 1 1 1 0 0 1 0 
	*	0 1 1 0 0 1 1 0 
	*	1 1 1 1 1 0 0 1 
	*	1 1 0 1 0 0 0 1 
	*	1 1 1 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 233
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 0 0 0 1 0 
*	0 1 1 1 1 1 1 0 	0 0 0 0 1 1 0 0 
*	1 0 1 0 1 1 0 0 	1 1 0 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 0 1 1 1 1 1 0 
*	0 1 1 0 0 1 1 0 	0 1 1 1 0 1 1 0 
*	0 0 1 0 0 1 1 0 	1 1 0 1 0 1 1 0 
*	1 1 1 1 1 1 1 0 	0 0 0 1 0 0 0 0 
*	0 0 0 1 0 0 1 1 	0 0 1 0 1 1 1 1 
*
* S = 01 BD 5D 51 1E 19 AC 24
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_233 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	0 1 0 0 1 1 0 0 
	*	1 0 1 0 0 0 0 1 
	*	1 1 0 1 1 1 0 1 
	*	1 0 1 0 0 1 1 1 
	*	1 0 1 1 0 0 1 1 
	*	1 0 0 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 234
*
* GF(2^8) Poly Basis: [d^4, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 0 0 0 1 0 
*	1 1 0 1 1 1 1 0 	0 0 0 0 0 1 0 0 
*	1 0 1 0 1 1 0 0 	0 1 0 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 0 0 1 0 1 1 0 
*	0 1 1 0 0 1 1 0 	1 1 0 1 1 1 1 0 
*	0 1 0 0 0 0 0 0 	0 1 1 1 1 1 1 0 
*	1 1 1 1 1 1 1 0 	0 0 1 1 0 0 0 0 
*	1 1 1 0 1 1 0 1 	0 0 1 0 0 1 0 1 
*
* S = 01 BC 5D 0C 1E 07 AC 88
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_234 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[6];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	1 1 0 0 0 1 0 0 
	*	1 0 1 0 0 0 1 1 
	*	0 1 1 1 0 1 1 1 
	*	1 0 1 0 1 1 0 1 
	*	1 0 0 1 0 0 0 1 
	*	1 0 1 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 235
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	1 1 0 0 0 1 1 0 
*	0 0 0 0 1 1 1 0 	0 1 0 1 0 1 0 1 
*	1 0 1 0 0 0 1 0 	0 0 1 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 0 0 0 0 0 1 1 
*	1 0 0 0 1 1 1 1 	1 1 0 1 1 1 0 0 
*	1 0 0 0 0 1 0 1 	0 1 0 0 1 1 0 0 
*	1 1 0 1 0 1 1 1 	1 1 0 1 0 0 0 0 
*	0 0 0 1 1 0 1 1 	1 0 0 0 1 1 1 0 
*
* S = 50 B1 ED 0D 6A 20 CE 9B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_235 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[7] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	1 1 1 1 0 1 0 1 
	*	0 1 0 0 1 1 0 1 
	*	0 0 0 0 1 0 0 0 
	*	1 0 0 0 0 0 0 1 
	*	1 1 1 1 1 0 1 1 
	*	1 0 1 0 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[3];
	assign out[2] = g_out[7] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 236
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 0 0 0 1 1 0 1 
*	1 1 0 1 1 1 0 0 	1 1 1 1 1 1 1 1 
*	0 1 1 1 0 0 1 0 	0 0 1 0 1 1 0 1 
*	1 0 1 0 0 0 1 0 	0 1 0 0 0 0 1 0 
*	0 0 0 0 1 0 1 0 	1 0 1 1 1 0 0 0 
*	1 0 0 0 1 1 1 1 	1 1 0 0 1 0 0 0 
*	1 1 0 0 1 1 0 0 	1 0 1 1 0 0 0 0 
*	1 1 0 1 0 1 1 1 	0 1 0 0 1 0 0 1 
*
* S = E1 50 E0 ED 4A 6A 55 CE
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_236 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	1 0 1 0 1 1 1 1 
	*	1 1 0 0 1 0 1 1 
	*	0 0 0 0 0 1 0 0 
	*	0 1 0 0 0 0 1 1 
	*	1 0 1 0 0 1 1 0 
	*	0 1 0 1 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[2];
	assign out[2] = g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 237
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 0 0 0 0 1 1 1 
*	0 0 0 0 1 1 1 0 	0 1 0 1 0 1 0 1 
*	0 1 1 1 0 0 1 0 	0 0 1 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 1 0 0 0 0 1 0 
*	0 0 0 0 1 0 1 0 	1 0 0 1 1 0 0 0 
*	1 0 0 0 0 1 0 1 	0 1 0 0 1 0 0 0 
*	1 1 0 0 1 1 0 0 	1 0 0 1 0 0 0 0 
*	0 0 0 1 1 0 1 1 	1 1 0 0 1 0 1 1 
*
* S = E1 B1 E0 0D 4A 20 55 9B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_237 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2];
	assign g_in[0] = in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	1 0 1 0 0 1 0 1 
	*	0 1 0 0 1 0 0 1 
	*	0 0 0 0 1 1 0 0 
	*	1 1 0 0 0 0 0 1 
	*	1 0 1 0 1 1 1 0 
	*	1 1 1 1 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 238
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	1 0 0 1 0 0 1 1 
*	0 1 1 1 0 0 0 0 	0 1 0 1 0 1 0 1 
*	0 0 0 0 0 0 1 0 	0 1 1 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 1 1 1 0 1 1 0 
*	0 1 0 0 1 0 0 1 	0 0 1 0 1 0 0 1 
*	1 1 0 1 1 1 0 1 	1 1 1 0 1 0 0 1 
*	0 0 0 1 0 0 0 1 	0 0 1 0 0 0 0 0 
*	0 1 0 0 0 0 1 1 	0 1 1 1 0 1 0 0 
*
* S = EC B0 51 0C D1 3F 75 84
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_238 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[3] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[4] ^ in[0];
	assign g_in[0] = in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	1 1 1 1 0 1 0 1 
	*	1 1 1 0 0 0 1 0 
	*	0 0 0 0 0 1 1 1 
	*	0 1 1 1 1 0 1 1 
	*	1 1 1 1 0 0 0 1 
	*	1 0 1 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1];
	assign out[3] = g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 239
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 1 1 1 0 0 1 0 
*	0 1 1 1 1 1 0 0 	1 1 1 1 1 1 1 1 
*	1 0 1 0 1 1 0 0 	1 1 0 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 1 1 0 1 1 0 1 
*	1 0 0 1 0 1 0 0 	0 0 0 1 0 1 1 1 
*	0 1 0 0 1 0 0 1 	1 0 0 1 0 1 1 1 
*	0 1 0 1 0 0 1 0 	0 0 0 1 0 0 0 0 
*	0 0 0 1 0 0 0 1 	1 1 1 0 1 1 0 0 
*
* S = 5C EC 5D 51 EE D1 F1 75
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_239 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[2];
	assign g_in[2] = in[6] ^ in[3] ^ in[0];
	assign g_in[1] = in[6] ^ in[4] ^ in[1];
	assign g_in[0] = in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	1 0 1 0 1 1 1 1 
	*	1 0 0 1 0 0 0 1 
	*	0 0 0 0 1 1 1 0 
	*	1 1 1 0 0 1 1 0 
	*	1 0 1 0 0 0 1 1 
	*	0 1 0 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 240
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 1 0 1 0 0 1 0 
*	0 1 1 1 0 0 0 0 	0 1 0 1 0 1 0 1 
*	1 0 1 0 1 1 0 0 	0 1 1 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 1 1 0 0 1 1 1 
*	1 0 0 1 0 1 0 0 	0 0 1 1 1 1 0 1 
*	1 1 0 1 1 1 0 1 	1 0 1 1 1 1 0 1 
*	0 1 0 1 0 0 1 0 	0 0 1 1 0 0 0 0 
*	0 1 0 0 0 0 1 1 	0 1 1 0 0 1 0 0 
*
* S = 5C B0 5D 0C EE 3F F1 84
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_240 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[6] ^ in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	1 0 1 0 0 1 0 1 
	*	1 0 1 1 0 0 1 1 
	*	0 0 0 0 0 1 1 0 
	*	0 1 1 0 1 1 1 0 
	*	1 0 1 0 0 0 0 1 
	*	1 1 1 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 241
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 1 1 1 0 1 1 
*	1 1 0 1 1 1 1 0 	0 1 0 0 0 1 0 0 
*	1 1 0 1 1 1 0 0 	1 1 1 1 1 0 1 1 
*	0 0 0 0 1 1 1 0 	0 0 1 0 1 1 1 1 
*	0 1 0 1 1 0 0 0 	0 1 1 0 0 0 1 1 
*	1 0 0 1 1 1 1 0 	0 0 0 1 0 0 1 1 
*	1 0 0 0 1 1 1 1 	0 1 1 0 0 0 0 0 
*	1 0 0 0 0 1 0 1 	0 0 1 0 1 0 0 1 
*
* S = BD BC 50 B1 A4 BB 6A 20
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_241 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	1 1 0 0 0 1 0 0 
	*	0 0 0 1 0 1 1 0 
	*	0 0 0 0 0 0 1 0 
	*	0 0 1 0 0 1 0 1 
	*	1 1 0 0 1 1 0 1 
	*	1 0 0 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[1];
	assign out[2] = g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 242
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 0 0 1 1 0 
*	0 1 1 1 1 1 1 0 	1 1 0 0 1 1 0 0 
*	1 1 0 1 0 0 1 0 	1 0 1 0 0 1 1 0 
*	1 1 0 1 1 1 0 0 	0 0 0 1 1 0 1 0 
*	1 1 0 0 0 1 1 0 	1 1 0 1 0 0 1 0 
*	0 1 0 1 1 0 0 0 	0 0 1 1 0 0 1 0 
*	0 0 0 0 1 0 1 0 	1 1 0 1 0 0 0 0 
*	1 0 0 0 1 1 1 1 	0 0 0 1 0 1 1 1 
*
* S = 01 BD E1 50 1F A4 4A 6A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_242 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3];
	assign g_in[1] = in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	1 0 0 0 1 1 0 0 
	*	0 0 1 1 1 1 0 1 
	*	0 0 0 0 0 0 0 1 
	*	0 0 0 1 1 1 1 1 
	*	1 0 0 0 1 0 1 1 
	*	0 1 0 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[0];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 243
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 0 1 1 1 0 
*	1 1 0 1 1 1 1 0 	0 1 0 0 0 1 0 0 
*	1 1 0 1 0 0 1 0 	1 0 1 0 1 1 1 0 
*	0 0 0 0 1 1 1 0 	0 0 1 1 1 0 1 0 
*	1 1 0 0 0 1 1 0 	0 1 1 1 0 0 1 0 
*	1 0 0 1 1 1 1 0 	0 0 0 1 0 0 1 0 
*	0 0 0 0 1 0 1 0 	0 1 1 1 0 0 0 0 
*	1 0 0 0 0 1 0 1 	0 0 1 1 1 1 0 1 
*
* S = 01 BC E1 B1 1F BB 4A 20
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_243 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	1 0 0 0 0 1 0 0 
	*	0 0 0 1 0 1 1 1 
	*	0 0 0 0 0 0 1 1 
	*	0 0 1 1 0 1 0 1 
	*	1 0 0 0 1 0 0 1 
	*	1 1 0 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 244
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 1 1 0 1 1 1 
*	1 1 0 1 1 1 1 0 	0 1 0 0 0 1 0 0 
*	1 0 1 0 0 0 1 0 	0 0 1 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 0 1 0 0 0 1 1 
*	0 1 0 1 1 0 0 0 	1 1 1 0 1 1 1 1 
*	1 0 0 1 1 1 1 0 	0 1 0 1 1 1 1 1 
*	1 1 0 1 0 1 1 1 	1 1 1 0 0 0 0 0 
*	0 0 0 1 1 0 1 1 	1 0 1 0 1 1 0 1 
*
* S = BD BC ED 0D A4 BB CE 9B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_244 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	1 1 0 0 0 1 0 0 
	*	0 1 0 1 1 1 1 0 
	*	0 0 0 0 1 0 1 0 
	*	1 0 1 0 0 0 0 1 
	*	1 1 0 0 1 0 0 1 
	*	1 0 0 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 245
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 0 1 1 1 0 
*	0 1 1 1 1 1 1 0 	1 1 0 0 1 1 0 0 
*	0 1 1 1 0 0 1 0 	0 0 1 0 1 1 1 0 
*	1 0 1 0 0 0 1 0 	0 1 0 1 0 0 1 0 
*	1 1 0 0 0 1 1 0 	1 0 0 1 1 0 1 0 
*	0 1 0 1 1 0 0 0 	1 1 1 1 1 0 1 0 
*	1 1 0 0 1 1 0 0 	1 0 0 1 0 0 0 0 
*	1 1 0 1 0 1 1 1 	0 1 0 1 1 0 1 1 
*
* S = 01 BD E0 ED 1F A4 55 CE
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_245 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	1 0 0 0 1 1 0 0 
	*	1 1 1 1 1 0 0 1 
	*	0 0 0 0 0 1 0 1 
	*	0 1 0 1 0 0 1 1 
	*	1 0 0 0 0 1 1 1 
	*	0 1 0 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 246
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 0 0 1 1 0 
*	1 1 0 1 1 1 1 0 	0 1 0 0 0 1 0 0 
*	0 1 1 1 0 0 1 0 	0 0 1 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 1 1 1 0 0 1 0 
*	1 1 0 0 0 1 1 0 	1 0 1 1 1 0 1 0 
*	1 0 0 1 1 1 1 0 	0 1 0 1 1 0 1 0 
*	1 1 0 0 1 1 0 0 	1 0 1 1 0 0 0 0 
*	0 0 0 1 1 0 1 1 	1 1 1 1 1 0 0 1 
*
* S = 01 BC E0 0D 1F BB 55 9B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_246 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2];
	assign g_in[0] = in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	1 0 0 0 0 1 0 0 
	*	0 1 0 1 1 0 1 1 
	*	0 0 0 0 1 1 1 1 
	*	1 1 1 1 0 0 0 1 
	*	1 0 0 0 1 1 0 1 
	*	1 1 0 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 247
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 1 1 1 1 1 1 
*	1 1 0 1 1 1 1 0 	0 1 0 0 0 1 0 0 
*	0 1 1 1 1 1 0 0 	1 0 1 1 1 1 1 1 
*	0 1 1 1 0 0 0 0 	1 1 1 0 1 0 1 1 
*	0 1 0 1 1 0 0 0 	1 0 1 0 0 1 1 1 
*	1 0 0 1 1 1 1 0 	1 0 0 1 0 1 1 1 
*	0 1 0 0 1 0 0 1 	1 0 1 0 0 0 0 0 
*	1 1 0 1 1 1 0 1 	1 1 1 0 0 0 0 1 
*
* S = BD BC EC B0 A4 BB D1 3F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_247 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[6] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	1 1 0 0 0 1 0 0 
	*	1 0 0 1 1 0 1 0 
	*	0 0 0 0 1 1 1 0 
	*	1 1 1 0 1 1 0 1 
	*	1 1 0 0 0 1 0 1 
	*	1 0 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 248
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 0 1 0 1 0 
*	0 1 1 1 1 1 1 0 	1 1 0 0 1 1 0 0 
*	0 0 0 0 1 1 0 0 	0 1 1 0 1 0 1 0 
*	0 1 1 1 1 1 0 0 	1 0 0 1 0 1 1 0 
*	1 1 0 0 0 1 1 0 	0 1 0 1 1 1 1 0 
*	0 1 0 1 1 0 0 0 	0 1 1 1 1 1 1 0 
*	1 0 0 1 0 1 0 0 	0 1 0 1 0 0 0 0 
*	0 1 0 0 1 0 0 1 	1 0 0 1 0 0 1 1 
*
* S = 01 BD 5C EC 1F A4 EE D1
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_248 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3];
	assign g_in[1] = in[7] ^ in[4] ^ in[2];
	assign g_in[0] = in[6] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 0 0 0 1 1 0 0 
	*	0 1 1 1 0 1 0 1 
	*	0 0 0 0 1 0 0 1 
	*	1 0 0 1 1 0 1 1 
	*	1 0 0 0 1 1 1 1 
	*	0 1 0 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[3] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 249
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 0 1 0 1 0 
*	1 1 0 1 1 1 1 0 	0 1 0 0 0 1 0 0 
*	0 0 0 0 1 1 0 0 	1 1 1 0 1 0 1 0 
*	0 1 1 1 0 0 0 0 	1 0 1 1 1 1 1 0 
*	1 1 0 0 0 1 1 0 	1 1 1 1 0 1 1 0 
*	1 0 0 1 1 1 1 0 	1 1 0 1 0 1 1 0 
*	1 0 0 1 0 1 0 0 	1 1 1 1 0 0 0 0 
*	1 1 0 1 1 1 0 1 	1 0 1 1 0 0 0 1 
*
* S = 01 BC 5C B0 1F BB EE 3F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_249 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[4] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	1 0 0 0 0 1 0 0 
	*	1 1 0 1 1 1 1 1 
	*	0 0 0 0 1 0 1 1 
	*	1 0 1 1 1 0 0 1 
	*	1 0 0 0 0 1 0 1 
	*	1 1 0 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 250
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 1 1 0 0 1 1 
*	1 1 0 1 1 1 1 0 	0 1 0 0 0 1 0 0 
*	0 0 0 0 0 0 1 0 	0 1 1 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 1 1 0 0 1 1 1 
*	0 1 0 1 1 0 0 0 	0 0 1 0 1 0 1 1 
*	1 0 0 1 1 1 1 0 	1 1 0 1 1 0 1 1 
*	0 0 0 1 0 0 0 1 	0 0 1 0 0 0 0 0 
*	0 1 0 0 0 0 1 1 	0 1 1 0 0 1 0 1 
*
* S = BD BC 51 0C A4 BB 75 84
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_250 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[4] ^ in[0];
	assign g_in[0] = in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	1 1 0 0 0 1 0 0 
	*	1 1 0 1 0 0 1 0 
	*	0 0 0 0 0 1 1 0 
	*	0 1 1 0 1 0 0 1 
	*	1 1 0 0 0 0 0 1 
	*	1 0 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 251
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 0 0 0 1 0 
*	0 1 1 1 1 1 1 0 	1 1 0 0 1 1 0 0 
*	1 0 1 0 1 1 0 0 	1 1 1 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 1 0 1 1 1 1 0 
*	1 1 0 0 0 1 1 0 	0 0 0 1 0 1 1 0 
*	0 1 0 1 1 0 0 0 	1 0 1 1 0 1 1 0 
*	0 1 0 1 0 0 1 0 	0 0 0 1 0 0 0 0 
*	0 0 0 1 0 0 0 1 	1 1 0 1 1 1 1 1 
*
* S = 01 BD 5D 51 1F A4 F1 75
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_251 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3];
	assign g_in[1] = in[6] ^ in[4] ^ in[1];
	assign g_in[0] = in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	1 0 0 0 1 1 0 0 
	*	1 0 1 1 0 0 0 1 
	*	0 0 0 0 1 1 0 1 
	*	1 1 0 1 0 1 1 1 
	*	1 0 0 0 0 0 1 1 
	*	0 1 0 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 252
*
* GF(2^8) Poly Basis: [d^64, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 0 0 0 1 0 
*	1 1 0 1 1 1 1 0 	0 1 0 0 0 1 0 0 
*	1 0 1 0 1 1 0 0 	0 1 1 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 1 1 1 0 1 1 0 
*	1 1 0 0 0 1 1 0 	0 0 1 1 1 1 1 0 
*	1 0 0 1 1 1 1 0 	1 0 0 1 1 1 1 0 
*	0 1 0 1 0 0 1 0 	0 0 1 1 0 0 0 0 
*	0 1 0 0 0 0 1 1 	0 1 1 1 0 1 0 1 
*
* S = 01 BC 5D 0C 1F BB F1 84
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_252 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	1 0 0 0 0 1 0 0 
	*	1 0 0 1 0 0 1 1 
	*	0 0 0 0 0 1 1 1 
	*	0 1 1 1 1 1 0 1 
	*	1 0 0 0 0 0 0 1 
	*	1 1 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 253
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	0 1 0 1 0 1 1 0 
*	0 0 0 0 1 1 1 0 	0 1 1 1 0 1 0 1 
*	1 0 1 0 0 0 1 0 	1 0 1 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 0 1 1 0 0 1 1 
*	0 1 0 1 0 0 0 1 	0 1 1 1 1 1 0 0 
*	0 0 1 0 0 1 0 1 	1 1 1 0 1 1 0 0 
*	0 1 1 1 1 0 1 1 	1 1 0 1 0 0 0 0 
*	0 0 0 1 1 0 0 1 	0 1 0 0 1 1 1 0 
*
* S = 50 B1 ED 0D DA 7C CF 26
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_253 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[4] ^ in[0];
	assign g_in[2] = in[5] ^ in[2] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	1 1 0 1 0 1 0 1 
	*	0 0 1 1 1 1 0 1 
	*	0 1 0 1 1 0 0 0 
	*	0 1 0 1 0 0 0 1 
	*	0 0 0 1 1 0 1 1 
	*	1 1 1 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 254
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 1 1 1 1 1 0 1 
*	1 1 0 1 1 1 0 0 	1 1 1 0 1 1 1 1 
*	0 1 1 1 0 0 1 0 	0 1 0 1 1 1 0 1 
*	1 0 1 0 0 0 1 0 	0 0 1 0 0 0 1 0 
*	0 1 1 1 0 1 0 0 	1 1 1 0 1 0 0 0 
*	0 1 0 1 0 0 0 1 	1 0 0 1 1 0 0 0 
*	0 1 1 0 0 0 1 0 	1 0 1 1 0 0 0 0 
*	0 1 1 1 1 0 1 1 	1 1 0 0 1 0 0 1 
*
* S = E1 50 E0 ED A6 DA E9 CF
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_254 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[6] ^ in[4] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	1 0 1 1 1 1 1 1 
	*	0 0 1 0 1 0 1 1 
	*	1 1 1 1 0 1 0 0 
	*	1 1 1 1 0 0 1 1 
	*	0 0 1 1 0 1 1 0 
	*	1 0 1 0 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 255
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 1 0 1 0 1 1 1 
*	0 0 0 0 1 1 1 0 	0 1 1 0 0 1 0 1 
*	0 1 1 1 0 0 1 0 	1 1 1 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 0 1 0 0 0 1 0 
*	0 1 1 1 0 1 0 0 	0 1 1 0 1 0 0 0 
*	0 0 1 0 0 1 0 1 	1 0 1 1 1 0 0 0 
*	0 1 1 0 0 0 1 0 	1 0 0 1 0 0 0 0 
*	0 0 0 1 1 0 0 1 	0 1 0 0 1 0 1 1 
*
* S = E1 B1 E0 0D A6 7C E9 26
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_255 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[5] ^ in[2] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[1];
	assign g_in[0] = in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	1 0 0 1 0 1 0 1 
	*	0 0 1 0 1 0 0 1 
	*	0 1 0 1 1 1 0 0 
	*	0 1 0 1 0 0 0 1 
	*	0 0 0 1 1 1 1 0 
	*	1 0 1 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 256
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	0 1 0 1 0 0 1 1 
*	0 1 1 1 0 0 0 0 	1 0 0 0 0 1 0 1 
*	0 0 0 0 0 0 1 0 	1 0 1 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 1 1 0 0 1 1 0 
*	0 1 0 0 0 1 1 1 	1 0 0 0 1 0 0 1 
*	0 0 0 0 1 1 1 1 	0 1 0 0 1 0 0 1 
*	0 1 1 0 1 1 0 1 	0 0 1 0 0 0 0 0 
*	0 0 1 1 0 0 1 1 	1 1 1 0 0 1 0 0 
*
* S = EC B0 51 0C 80 33 95 69
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_256 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[5] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	0 0 1 0 0 1 0 1 
	*	0 1 1 0 0 0 1 0 
	*	0 1 0 1 0 1 1 1 
	*	0 1 0 1 1 0 1 1 
	*	1 0 1 1 0 0 0 1 
	*	1 1 1 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 257
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 1 1 1 0 0 1 0 
*	0 1 1 1 1 1 0 0 	0 1 0 0 1 1 1 1 
*	1 0 1 0 1 1 0 0 	0 1 0 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 1 0 1 1 1 0 1 
*	0 1 0 0 1 0 0 0 	0 1 0 0 0 1 1 1 
*	0 1 0 0 0 1 1 1 	1 1 0 0 0 1 1 1 
*	0 1 0 1 1 1 1 0 	0 0 0 1 0 0 0 0 
*	0 1 1 0 1 1 0 1 	1 0 0 1 1 1 0 0 
*
* S = 5C EC 5D 51 B3 80 FC 95
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_257 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[6] ^ in[3];
	assign g_in[2] = in[6] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	0 0 0 1 1 1 1 1 
	*	1 1 0 1 0 0 0 1 
	*	1 1 1 1 1 1 1 0 
	*	1 1 1 1 0 1 1 0 
	*	0 1 1 0 0 0 1 1 
	*	1 0 1 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 258
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 1 0 1 0 0 1 0 
*	0 1 1 1 0 0 0 0 	1 1 0 0 0 1 0 1 
*	1 0 1 0 1 1 0 0 	1 1 1 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 1 1 1 0 1 1 1 
*	0 1 0 0 1 0 0 0 	1 1 0 0 1 1 0 1 
*	0 0 0 0 1 1 1 1 	0 1 0 0 1 1 0 1 
*	0 1 0 1 1 1 1 0 	0 0 1 1 0 0 0 0 
*	0 0 1 1 0 0 1 1 	1 0 1 1 0 1 0 0 
*
* S = 5C B0 5D 0C B3 33 FC 69
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_258 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[3];
	assign g_in[2] = in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[5] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	0 0 1 1 0 1 0 1 
	*	0 1 1 1 0 0 1 1 
	*	0 1 0 1 0 1 1 0 
	*	0 1 0 1 1 1 1 0 
	*	1 1 1 0 0 0 0 1 
	*	1 0 1 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 259
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 0 0 1 0 1 1 
*	1 1 0 1 1 1 1 0 	1 1 1 0 0 1 0 0 
*	1 1 0 1 1 1 0 0 	1 0 0 0 1 0 1 1 
*	0 0 0 0 1 1 1 0 	1 1 1 1 1 1 1 1 
*	0 0 1 0 1 0 1 0 	1 1 1 0 0 0 1 1 
*	0 0 1 1 1 1 0 0 	1 0 0 1 0 0 1 1 
*	0 1 0 1 0 0 0 1 	0 1 1 0 0 0 0 0 
*	0 0 1 0 0 1 0 1 	0 0 0 1 1 0 0 1 
*
* S = BD BC 50 B1 15 5A DA 7C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_259 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[4] ^ in[0];
	assign g_in[0] = in[5] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	0 1 1 0 0 1 0 0 
	*	1 1 1 1 0 1 1 0 
	*	0 1 0 0 0 0 1 0 
	*	0 1 0 0 0 1 0 1 
	*	0 1 0 1 1 1 0 1 
	*	1 1 0 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 260
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 0 0 1 1 0 
*	0 1 1 1 1 1 1 0 	1 0 0 1 1 1 0 0 
*	1 1 0 1 0 0 1 0 	0 1 0 0 0 1 1 0 
*	1 1 0 1 1 1 0 0 	1 0 1 0 1 0 1 0 
*	0 0 0 1 0 1 1 0 	1 0 0 1 0 0 1 0 
*	0 0 1 0 1 0 1 0 	0 1 1 1 0 0 1 0 
*	0 1 1 1 0 1 0 0 	1 1 0 1 0 0 0 0 
*	0 1 0 1 0 0 0 1 	0 0 1 1 0 1 1 1 
*
* S = 01 BD E1 50 4F 15 A6 DA
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_260 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[3] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[0] = in[6] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	1 1 0 1 1 1 0 0 
	*	1 0 1 0 1 1 0 1 
	*	1 1 0 0 0 0 0 1 
	*	1 1 0 0 1 1 1 1 
	*	1 1 1 1 1 0 1 1 
	*	1 0 0 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 261
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 0 1 1 1 0 
*	1 1 0 1 1 1 1 0 	1 0 1 1 0 1 0 0 
*	1 1 0 1 0 0 1 0 	1 1 0 0 1 1 1 0 
*	0 0 0 0 1 1 1 0 	1 0 1 0 1 0 1 0 
*	0 0 0 1 0 1 1 0 	1 0 1 1 0 0 1 0 
*	0 0 1 1 1 1 0 0 	1 1 0 1 0 0 1 0 
*	0 1 1 1 0 1 0 0 	0 1 1 1 0 0 0 0 
*	0 0 1 0 0 1 0 1 	0 0 0 1 1 1 0 1 
*
* S = 01 BC E1 B1 4F 5A A6 7C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_261 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[0] = in[5] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	0 1 1 1 0 1 0 0 
	*	1 0 1 0 0 1 1 1 
	*	0 1 0 0 0 0 1 1 
	*	0 1 0 0 0 1 0 1 
	*	0 1 0 1 1 0 0 1 
	*	1 0 0 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 262
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 0 0 0 1 1 1 
*	1 1 0 1 1 1 1 0 	0 1 1 0 0 1 0 0 
*	1 0 1 0 0 0 1 0 	1 0 0 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 0 1 1 0 0 1 1 
*	0 0 1 0 1 0 1 0 	0 1 1 0 1 1 1 1 
*	0 0 1 1 1 1 0 0 	1 1 0 1 1 1 1 1 
*	0 1 1 1 1 0 1 1 	1 1 1 0 0 0 0 0 
*	0 0 0 1 1 0 0 1 	0 1 0 1 1 1 0 1 
*
* S = BD BC ED 0D 15 5A CF 26
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_262 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	1 1 1 0 0 1 0 0 
	*	0 0 1 1 1 1 1 0 
	*	0 1 0 0 1 0 1 0 
	*	0 1 0 0 0 0 0 1 
	*	0 0 0 1 1 0 0 1 
	*	1 1 0 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 263
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 0 1 1 1 0 
*	0 1 1 1 1 1 1 0 	1 1 0 1 1 1 0 0 
*	0 1 1 1 0 0 1 0 	0 1 0 0 1 1 1 0 
*	1 0 1 0 0 0 1 0 	0 0 1 0 0 0 1 0 
*	0 0 0 1 0 1 1 0 	1 1 0 1 1 0 1 0 
*	0 0 1 0 1 0 1 0 	1 0 1 1 1 0 1 0 
*	0 1 1 0 0 0 1 0 	1 0 0 1 0 0 0 0 
*	0 1 1 1 1 0 1 1 	1 1 1 1 1 0 1 1 
*
* S = 01 BD E0 ED 4F 15 E9 CF
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_263 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[3] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	1 0 0 1 1 1 0 0 
	*	0 0 1 0 1 0 0 1 
	*	1 1 0 0 0 1 0 1 
	*	1 1 0 0 0 0 1 1 
	*	0 0 1 1 0 1 1 1 
	*	1 0 0 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 264
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 0 0 1 1 0 
*	1 1 0 1 1 1 1 0 	0 1 1 1 0 1 0 0 
*	0 1 1 1 0 0 1 0 	1 1 0 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 0 1 0 0 0 1 0 
*	0 0 0 1 0 1 1 0 	0 1 1 1 1 0 1 0 
*	0 0 1 1 1 1 0 0 	1 0 0 1 1 0 1 0 
*	0 1 1 0 0 0 1 0 	1 0 1 1 0 0 0 0 
*	0 0 0 1 1 0 0 1 	0 1 0 1 1 0 0 1 
*
* S = 01 BC E0 0D 4F 5A E9 26
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_264 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[5] ^ in[1];
	assign g_in[0] = in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	1 0 1 1 0 1 0 0 
	*	0 0 1 0 1 0 1 1 
	*	0 1 0 0 1 1 1 1 
	*	0 1 0 0 0 0 0 1 
	*	0 0 0 1 1 1 0 1 
	*	1 0 0 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 265
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 0 0 1 1 1 1 
*	1 1 0 1 1 1 1 0 	0 0 1 0 0 1 0 0 
*	0 1 1 1 1 1 0 0 	1 0 0 0 1 1 1 1 
*	0 1 1 1 0 0 0 0 	1 0 1 1 1 0 1 1 
*	0 0 1 0 1 0 1 0 	0 0 1 0 0 1 1 1 
*	0 0 1 1 1 1 0 0 	0 0 0 1 0 1 1 1 
*	0 1 0 0 0 1 1 1 	1 0 1 0 0 0 0 0 
*	0 0 0 0 1 1 1 1 	1 0 0 1 0 0 0 1 
*
* S = BD BC EC B0 15 5A 80 33
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_265 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	1 0 1 0 0 1 0 0 
	*	1 0 1 1 1 0 1 0 
	*	0 1 0 0 1 1 1 0 
	*	0 1 0 0 1 1 0 1 
	*	1 1 0 1 0 1 0 1 
	*	1 1 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 266
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 0 1 0 1 0 
*	0 1 1 1 1 1 1 0 	0 0 0 1 1 1 0 0 
*	0 0 0 0 1 1 0 0 	0 1 0 0 1 0 1 0 
*	0 1 1 1 1 1 0 0 	0 1 1 0 0 1 1 0 
*	0 0 0 1 0 1 1 0 	0 0 0 1 1 1 1 0 
*	0 0 1 0 1 0 1 0 	0 0 1 1 1 1 1 0 
*	0 1 0 0 1 0 0 0 	0 1 0 1 0 0 0 0 
*	0 1 0 0 0 1 1 1 	0 1 1 1 0 0 1 1 
*
* S = 01 BD 5C EC 4F 15 B3 80
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_266 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[3] ^ in[1];
	assign g_in[1] = in[6] ^ in[3];
	assign g_in[0] = in[6] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	0 1 0 1 1 1 0 0 
	*	0 1 1 0 0 1 0 1 
	*	1 1 0 0 1 0 0 1 
	*	1 1 0 0 1 0 1 1 
	*	1 0 1 1 1 1 1 1 
	*	1 0 0 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 267
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 0 1 0 1 0 
*	1 1 0 1 1 1 1 0 	0 0 1 1 0 1 0 0 
*	0 0 0 0 1 1 0 0 	1 1 0 0 1 0 1 0 
*	0 1 1 1 0 0 0 0 	1 1 1 0 1 1 1 0 
*	0 0 0 1 0 1 1 0 	0 0 1 1 0 1 1 0 
*	0 0 1 1 1 1 0 0 	0 0 0 1 0 1 1 0 
*	0 1 0 0 1 0 0 0 	1 1 1 1 0 0 0 0 
*	0 0 0 0 1 1 1 1 	1 1 0 1 0 0 0 1 
*
* S = 01 BC 5C B0 4F 5A B3 33
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_267 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[3];
	assign g_in[0] = in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	1 1 1 1 0 1 0 0 
	*	1 1 1 0 1 1 1 1 
	*	0 1 0 0 1 0 1 1 
	*	0 1 0 0 1 0 0 1 
	*	1 0 0 1 0 1 0 1 
	*	1 0 0 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 268
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 0 0 0 0 1 1 
*	1 1 0 1 1 1 1 0 	1 0 1 0 0 1 0 0 
*	0 0 0 0 0 0 1 0 	1 0 0 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 1 1 1 0 1 1 1 
*	0 0 1 0 1 0 1 0 	1 0 1 0 1 0 1 1 
*	0 0 1 1 1 1 0 0 	0 1 0 1 1 0 1 1 
*	0 1 1 0 1 1 0 1 	0 0 1 0 0 0 0 0 
*	0 0 1 1 0 0 1 1 	1 1 0 1 0 1 0 1 
*
* S = BD BC 51 0C 15 5A 95 69
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_268 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[5] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	0 0 1 0 0 1 0 0 
	*	0 1 1 1 0 0 1 0 
	*	0 1 0 0 0 1 1 0 
	*	0 1 0 0 1 0 0 1 
	*	1 0 0 1 0 0 0 1 
	*	1 1 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 269
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 0 0 0 1 0 
*	0 1 1 1 1 1 1 0 	0 1 0 1 1 1 0 0 
*	1 0 1 0 1 1 0 0 	0 1 0 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 1 1 0 1 1 1 0 
*	0 0 0 1 0 1 1 0 	0 1 0 1 0 1 1 0 
*	0 0 1 0 1 0 1 0 	1 1 1 1 0 1 1 0 
*	0 1 0 1 1 1 1 0 	0 0 0 1 0 0 0 0 
*	0 1 1 0 1 1 0 1 	1 0 1 1 1 1 1 1 
*
* S = 01 BD 5D 51 4F 15 FC 95
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_269 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[3] ^ in[1];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	0 0 0 1 1 1 0 0 
	*	1 1 1 0 0 0 0 1 
	*	1 1 0 0 1 1 0 1 
	*	1 1 0 0 0 1 1 1 
	*	0 1 1 1 0 0 1 1 
	*	1 0 0 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 270
*
* GF(2^8) Poly Basis: [d^8, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 0 0 0 1 0 
*	1 1 0 1 1 1 1 0 	1 1 1 1 0 1 0 0 
*	1 0 1 0 1 1 0 0 	1 1 0 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 1 1 0 0 1 1 0 
*	0 0 0 1 0 1 1 0 	1 1 1 1 1 1 1 0 
*	0 0 1 1 1 1 0 0 	0 1 0 1 1 1 1 0 
*	0 1 0 1 1 1 1 0 	0 0 1 1 0 0 0 0 
*	0 0 1 1 0 0 1 1 	1 0 0 1 0 1 0 1 
*
* S = 01 BC 5D 0C 4F 5A FC 69
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_270 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[5] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	0 0 1 1 0 1 0 0 
	*	0 1 1 0 0 0 1 1 
	*	0 1 0 0 0 1 1 1 
	*	0 1 0 0 1 1 0 1 
	*	1 1 0 1 0 0 0 1 
	*	1 0 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 271
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	0 0 1 1 0 1 1 0 
*	0 0 0 0 1 1 1 0 	0 0 1 0 0 1 0 1 
*	1 0 1 0 0 0 1 0 	1 1 0 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 0 0 0 0 0 1 1 
*	1 0 0 0 1 1 0 1 	1 0 1 1 1 1 0 0 
*	0 0 1 0 1 0 1 1 	0 0 1 0 1 1 0 0 
*	1 1 0 1 1 0 0 1 	1 1 0 1 0 0 0 0 
*	1 1 0 0 1 0 0 1 	1 0 1 0 1 1 1 0 
*
* S = 50 B1 ED 0D 8A CD 22 2B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_271 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[2] = in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	1 0 0 0 0 1 0 1 
	*	1 1 1 0 1 1 0 1 
	*	1 1 0 1 1 0 0 0 
	*	0 1 0 0 0 0 0 1 
	*	1 0 1 0 1 0 1 1 
	*	0 1 1 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[2] = g_out[6] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 272
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 0 1 0 1 1 0 1 
*	1 1 0 1 1 1 0 0 	0 0 0 1 1 1 1 1 
*	0 1 1 1 0 0 1 0 	1 0 0 0 1 1 0 1 
*	1 0 1 0 0 0 1 0 	0 0 0 0 0 0 1 0 
*	1 0 1 0 0 1 1 0 	0 1 1 0 1 0 0 0 
*	1 0 0 0 1 1 0 1 	0 0 0 1 1 0 0 0 
*	0 0 0 1 0 0 0 0 	1 0 1 1 0 0 0 0 
*	1 1 0 1 1 0 0 1 	0 1 0 1 1 0 0 1 
*
* S = E1 50 E0 ED 47 8A 09 22
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_272 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	0 1 0 0 1 1 1 1 
	*	1 0 0 1 1 0 1 1 
	*	1 0 1 1 0 1 0 0 
	*	1 1 0 0 0 0 1 1 
	*	0 1 0 1 0 1 1 0 
	*	1 1 1 0 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 273
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 0 1 0 0 1 1 1 
*	0 0 0 0 1 1 1 0 	0 0 1 1 0 1 0 1 
*	0 1 1 1 0 0 1 0 	1 0 0 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 0 0 0 0 0 1 0 
*	1 0 1 0 0 1 1 0 	1 1 1 0 1 0 0 0 
*	0 0 1 0 1 0 1 1 	0 0 1 1 1 0 0 0 
*	0 0 0 1 0 0 0 0 	1 0 0 1 0 0 0 0 
*	1 1 0 0 1 0 0 1 	1 1 1 1 1 0 1 1 
*
* S = E1 B1 E0 0D 47 CD 09 2B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_273 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	1 1 0 0 0 1 0 1 
	*	1 0 1 1 1 0 0 1 
	*	1 0 0 1 1 1 0 0 
	*	0 1 0 0 0 0 0 1 
	*	1 1 1 1 1 1 1 0 
	*	0 1 1 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[6] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 274
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	0 1 1 0 0 0 1 1 
*	0 1 1 1 0 0 0 0 	1 1 0 1 0 1 0 1 
*	0 0 0 0 0 0 1 0 	1 0 0 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 0 0 0 0 1 1 0 
*	0 0 1 1 1 0 1 1 	0 0 0 1 1 0 0 1 
*	0 1 1 1 1 1 1 1 	1 1 0 1 1 0 0 1 
*	0 1 1 0 1 1 1 1 	0 0 1 0 0 0 0 0 
*	1 0 0 1 1 1 0 1 	1 0 1 0 0 1 0 0 
*
* S = EC B0 51 0C 6C 83 C4 65
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_274 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	0 1 1 1 0 1 0 1 
	*	0 1 0 0 0 0 1 0 
	*	0 0 1 0 0 1 1 1 
	*	1 1 1 0 1 0 1 1 
	*	1 0 1 0 0 0 0 1 
	*	1 0 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 275
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 1 0 1 0 0 1 0 
*	0 1 1 1 1 1 0 0 	1 0 1 1 1 1 1 1 
*	1 0 1 0 1 1 0 0 	0 1 1 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 0 0 0 1 1 0 1 
*	0 1 0 0 0 1 0 0 	0 0 1 1 0 1 1 1 
*	0 0 1 1 1 0 1 1 	1 0 1 1 0 1 1 1 
*	1 1 1 1 0 0 1 0 	0 0 0 1 0 0 0 0 
*	0 1 1 0 1 1 1 1 	0 1 0 1 1 1 0 0 
*
* S = 5C EC 5D 51 EF 6C A1 C4
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_275 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[6] ^ in[2];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	1 1 1 0 1 1 1 1 
	*	1 1 0 0 0 0 0 1 
	*	0 0 0 1 1 1 1 0 
	*	1 0 0 1 0 1 1 0 
	*	0 1 0 1 0 0 1 1 
	*	0 1 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 276
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 1 1 1 0 0 1 0 
*	0 1 1 1 0 0 0 0 	1 0 0 1 0 1 0 1 
*	1 0 1 0 1 1 0 0 	1 1 0 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 0 0 0 0 1 1 1 
*	0 1 0 0 0 1 0 0 	0 0 0 1 1 1 0 1 
*	0 1 1 1 1 1 1 1 	1 0 0 1 1 1 0 1 
*	1 1 1 1 0 0 1 0 	0 0 1 1 0 0 0 0 
*	1 0 0 1 1 1 0 1 	1 1 1 1 0 1 0 0 
*
* S = 5C B0 5D 0C EF 83 A1 65
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_276 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[2];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N2_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	0 1 1 0 0 1 0 1 
	*	0 1 0 0 0 0 1 1 
	*	0 0 1 1 0 1 1 0 
	*	1 0 1 1 1 1 1 0 
	*	1 1 1 1 0 0 0 1 
	*	1 1 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 277
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 1 1 1 0 1 1 
*	1 1 0 1 1 1 1 0 	1 0 1 0 0 1 0 0 
*	1 1 0 1 1 1 0 0 	0 0 1 1 1 0 1 1 
*	0 0 0 0 1 1 1 0 	0 0 0 0 1 1 1 1 
*	0 1 0 1 0 1 0 0 	1 1 0 1 0 0 1 1 
*	1 1 1 0 0 0 1 0 	1 0 1 0 0 0 1 1 
*	1 0 0 0 1 1 0 1 	0 1 1 0 0 0 0 0 
*	0 0 1 0 1 0 1 1 	1 0 0 0 1 0 0 1 
*
* S = BD BC 50 B1 A8 E6 8A CD
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_277 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[7] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	0 0 1 0 0 1 0 0 
	*	1 0 0 1 0 1 1 0 
	*	0 1 1 0 0 0 1 0 
	*	0 0 0 1 0 1 0 1 
	*	1 0 0 0 1 1 0 1 
	*	1 1 1 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[1];
	assign out[2] = g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 278
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 0 0 1 1 0 
*	0 1 1 1 1 1 1 0 	0 1 0 1 1 1 0 0 
*	1 1 0 1 0 0 1 0 	0 0 1 0 0 1 1 0 
*	1 1 0 1 1 1 0 0 	0 0 0 0 1 0 1 0 
*	1 0 1 1 0 1 1 0 	1 0 1 1 0 0 1 0 
*	0 1 0 1 0 1 0 0 	0 1 0 1 0 0 1 0 
*	1 0 1 0 0 1 1 0 	1 1 0 1 0 0 0 0 
*	1 0 0 0 1 1 0 1 	0 1 0 0 0 1 1 1 
*
* S = 01 BD E1 50 4E A8 47 8A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_278 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	0 0 0 1 1 1 0 0 
	*	0 1 1 1 1 1 0 1 
	*	1 1 0 1 0 0 0 1 
	*	0 0 1 1 1 1 1 1 
	*	0 1 0 0 1 0 1 1 
	*	1 0 0 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 279
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 0 1 1 1 0 
*	1 1 0 1 1 1 1 0 	1 1 1 1 0 1 0 0 
*	1 1 0 1 0 0 1 0 	0 0 1 0 1 1 1 0 
*	0 0 0 0 1 1 1 0 	0 0 0 0 1 0 1 0 
*	1 0 1 1 0 1 1 0 	1 0 0 1 0 0 1 0 
*	1 1 1 0 0 0 1 0 	1 1 1 1 0 0 1 0 
*	1 0 1 0 0 1 1 0 	0 1 1 1 0 0 0 0 
*	0 0 1 0 1 0 1 1 	1 1 0 0 1 1 0 1 
*
* S = 01 BC E1 B1 4E E6 47 CD
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_279 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[0] = in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	0 0 1 1 0 1 0 0 
	*	1 1 0 1 0 1 1 1 
	*	0 1 1 1 0 0 1 1 
	*	0 0 0 1 0 1 0 1 
	*	1 1 0 0 1 0 0 1 
	*	1 0 1 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 280
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 1 1 0 1 1 1 
*	1 1 0 1 1 1 1 0 	0 0 1 0 0 1 0 0 
*	1 0 1 0 0 0 1 0 	1 1 1 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 0 0 0 0 0 1 1 
*	0 1 0 1 0 1 0 0 	1 0 0 1 1 1 1 1 
*	1 1 1 0 0 0 1 0 	0 0 1 0 1 1 1 1 
*	1 1 0 1 1 0 0 1 	1 1 1 0 0 0 0 0 
*	1 1 0 0 1 0 0 1 	1 0 0 0 1 1 0 1 
*
* S = BD BC ED 0D A8 E6 22 2B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_280 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	1 0 1 0 0 1 0 0 
	*	1 1 0 1 1 1 1 0 
	*	1 1 1 0 1 0 1 0 
	*	0 1 0 1 0 0 0 1 
	*	1 0 0 0 1 0 0 1 
	*	0 1 1 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 281
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 0 1 1 1 0 
*	0 1 1 1 1 1 1 0 	0 0 0 1 1 1 0 0 
*	0 1 1 1 0 0 1 0 	1 0 1 0 1 1 1 0 
*	1 0 1 0 0 0 1 0 	0 0 0 0 0 0 1 0 
*	1 0 1 1 0 1 1 0 	0 1 1 1 1 0 1 0 
*	0 1 0 1 0 1 0 0 	0 0 0 1 1 0 1 0 
*	0 0 0 1 0 0 0 0 	1 0 0 1 0 0 0 0 
*	1 1 0 1 1 0 0 1 	0 1 0 0 1 0 1 1 
*
* S = 01 BD E0 ED 4E A8 09 22
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_281 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2];
	assign g_in[1] = in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	0 1 0 1 1 1 0 0 
	*	1 0 1 1 1 0 0 1 
	*	1 0 0 1 0 1 0 1 
	*	1 1 1 1 0 0 1 1 
	*	0 1 0 0 0 1 1 1 
	*	1 1 0 1 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 282
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 0 0 1 1 0 
*	1 1 0 1 1 1 1 0 	0 0 1 1 0 1 0 0 
*	0 1 1 1 0 0 1 0 	1 0 1 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 0 0 0 0 0 1 0 
*	1 0 1 1 0 1 1 0 	1 1 0 1 1 0 1 0 
*	1 1 1 0 0 0 1 0 	0 0 1 1 1 0 1 0 
*	0 0 0 1 0 0 0 0 	1 0 1 1 0 0 0 0 
*	1 1 0 0 1 0 0 1 	1 1 0 0 1 0 0 1 
*
* S = 01 BC E0 0D 4E E6 09 2B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_282 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	1 1 1 1 0 1 0 0 
	*	1 0 0 1 1 0 1 1 
	*	1 0 1 1 1 1 1 1 
	*	0 1 0 1 0 0 0 1 
	*	1 1 0 0 1 1 0 1 
	*	0 1 1 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 283
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 1 1 1 1 1 1 
*	1 1 0 1 1 1 1 0 	0 1 1 0 0 1 0 0 
*	0 1 1 1 1 1 0 0 	0 1 1 1 1 1 1 1 
*	0 1 1 1 0 0 0 0 	0 0 0 0 1 0 1 1 
*	0 1 0 1 0 1 0 0 	0 1 0 1 0 1 1 1 
*	1 1 1 0 0 0 1 0 	0 1 1 0 0 1 1 1 
*	0 0 1 1 1 0 1 1 	1 0 1 0 0 0 0 0 
*	0 1 1 1 1 1 1 1 	1 0 0 0 0 0 0 1 
*
* S = BD BC EC B0 A8 E6 6C 83
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_283 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	1 1 1 0 0 1 0 0 
	*	0 0 0 1 1 0 1 0 
	*	1 0 1 0 1 1 1 0 
	*	1 0 0 1 1 1 0 1 
	*	1 0 0 0 0 1 0 1 
	*	0 0 1 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 284
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 0 1 0 1 0 
*	0 1 1 1 1 1 1 0 	1 1 0 1 1 1 0 0 
*	0 0 0 0 1 1 0 0 	1 1 1 0 1 0 1 0 
*	0 1 1 1 1 1 0 0 	0 0 0 0 0 1 1 0 
*	1 0 1 1 0 1 1 0 	1 1 1 1 1 1 1 0 
*	0 1 0 1 0 1 0 0 	1 1 0 1 1 1 1 0 
*	0 1 0 0 0 1 0 0 	0 1 0 1 0 0 0 0 
*	0 0 1 1 1 0 1 1 	0 1 0 0 0 0 1 1 
*
* S = 01 BD 5C EC 4E A8 EF 6C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_284 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2];
	assign g_in[1] = in[6] ^ in[2];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 0 0 1 1 1 0 0 
	*	0 0 1 1 0 1 0 1 
	*	0 1 0 1 1 0 0 1 
	*	0 1 1 1 1 0 1 1 
	*	0 1 0 0 1 1 1 1 
	*	0 0 0 1 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 285
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 0 1 0 1 0 
*	1 1 0 1 1 1 1 0 	0 1 1 1 0 1 0 0 
*	0 0 0 0 1 1 0 0 	0 1 1 0 1 0 1 0 
*	0 1 1 1 0 0 0 0 	0 0 0 0 1 1 1 0 
*	1 0 1 1 0 1 1 0 	0 1 0 1 0 1 1 0 
*	1 1 1 0 0 0 1 0 	0 1 1 1 0 1 1 0 
*	0 1 0 0 0 1 0 0 	1 1 1 1 0 0 0 0 
*	0 1 1 1 1 1 1 1 	1 1 0 0 0 0 0 1 
*
* S = 01 BC 5C B0 4E E6 EF 83
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_285 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[6] ^ in[2];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	1 0 1 1 0 1 0 0 
	*	0 0 0 1 1 1 1 1 
	*	1 1 1 1 1 0 1 1 
	*	1 1 0 1 1 0 0 1 
	*	1 1 0 0 0 1 0 1 
	*	0 0 1 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 286
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 1 1 0 0 1 1 
*	1 1 0 1 1 1 1 0 	1 1 1 0 0 1 0 0 
*	0 0 0 0 0 0 1 0 	1 0 1 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 0 0 0 0 1 1 1 
*	0 1 0 1 0 1 0 0 	0 0 0 1 1 0 1 1 
*	1 1 1 0 0 0 1 0 	1 1 1 0 1 0 1 1 
*	0 1 1 0 1 1 1 1 	0 0 1 0 0 0 0 0 
*	1 0 0 1 1 1 0 1 	1 0 0 0 0 1 0 1 
*
* S = BD BC 51 0C A8 E6 C4 65
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_286 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	0 1 1 0 0 1 0 0 
	*	0 1 0 1 0 0 1 0 
	*	0 0 1 0 0 1 1 0 
	*	1 1 0 1 1 0 0 1 
	*	1 0 0 0 0 0 0 1 
	*	1 0 1 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 287
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 0 0 0 1 0 
*	0 1 1 1 1 1 1 0 	1 0 0 1 1 1 0 0 
*	1 0 1 0 1 1 0 0 	0 1 1 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 0 0 0 1 1 1 0 
*	1 0 1 1 0 1 1 0 	0 0 1 1 0 1 1 0 
*	0 1 0 1 0 1 0 0 	1 0 0 1 0 1 1 0 
*	1 1 1 1 0 0 1 0 	0 0 0 1 0 0 0 0 
*	0 1 1 0 1 1 1 1 	0 1 0 0 1 1 1 1 
*
* S = 01 BD 5D 51 4E A8 A1 C4
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_287 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	1 1 0 1 1 1 0 0 
	*	1 1 1 1 0 0 0 1 
	*	0 0 0 1 1 1 0 1 
	*	1 0 1 1 0 1 1 1 
	*	0 1 0 0 0 0 1 1 
	*	0 1 0 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 288
*
* GF(2^8) Poly Basis: [d^128, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 0 0 0 1 0 
*	1 1 0 1 1 1 1 0 	1 0 1 1 0 1 0 0 
*	1 0 1 0 1 1 0 0 	1 1 1 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 0 0 0 0 1 1 0 
*	1 0 1 1 0 1 1 0 	0 0 0 1 1 1 1 0 
*	1 1 1 0 0 0 1 0 	1 0 1 1 1 1 1 0 
*	1 1 1 1 0 0 1 0 	0 0 1 1 0 0 0 0 
*	1 0 0 1 1 1 0 1 	1 1 0 0 0 1 0 1 
*
* S = 01 BC 5D 0C 4E E6 A1 65
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_288 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N2_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	0 1 1 1 0 1 0 0 
	*	0 1 0 1 0 0 1 1 
	*	0 0 1 1 0 1 1 1 
	*	1 0 0 1 1 1 0 1 
	*	1 1 0 0 0 0 0 1 
	*	1 1 1 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 289
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	0 1 1 1 0 1 1 0 
*	0 0 0 0 1 1 1 0 	1 1 1 1 0 1 0 1 
*	1 0 1 0 0 0 1 0 	1 0 0 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 0 0 1 0 0 1 1 
*	0 1 0 1 1 1 0 1 	1 0 0 1 1 1 0 0 
*	0 1 0 1 1 0 0 1 	0 0 0 0 1 1 0 0 
*	1 0 1 0 0 1 0 1 	1 1 0 1 0 0 0 0 
*	1 0 1 1 1 0 0 1 	1 1 1 1 1 1 1 0 
*
* S = 50 B1 ED 0D DB C1 C3 7B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_289 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	0 1 0 1 0 1 0 1 
	*	0 0 1 0 1 1 0 1 
	*	1 1 0 0 1 0 0 0 
	*	1 0 1 0 0 0 0 1 
	*	0 0 1 0 1 0 1 1 
	*	0 1 1 0 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 290
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 1 1 0 1 1 0 1 
*	1 1 0 1 1 1 0 0 	1 0 1 0 1 1 1 1 
*	0 1 1 1 0 0 1 0 	0 1 0 0 1 1 0 1 
*	1 0 1 0 0 0 1 0 	0 1 1 1 0 0 1 0 
*	0 0 0 0 0 1 0 0 	0 1 1 1 1 0 0 0 
*	0 1 0 1 1 1 0 1 	0 0 0 0 1 0 0 0 
*	0 0 0 1 1 1 0 0 	1 0 1 1 0 0 0 0 
*	1 0 1 0 0 1 0 1 	1 0 1 0 1 0 0 1 
*
* S = E1 50 E0 ED 1A DB B8 C3
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_290 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[2];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	1 1 1 1 1 1 1 1 
	*	0 0 0 1 1 0 1 1 
	*	1 0 0 0 0 1 0 0 
	*	0 1 0 1 0 0 1 1 
	*	0 0 0 1 0 1 1 0 
	*	1 1 0 1 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[2];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 291
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 1 1 0 0 1 1 1 
*	0 0 0 0 1 1 1 0 	1 0 1 0 0 1 0 1 
*	0 1 1 1 0 0 1 0 	1 1 0 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 1 0 1 0 0 1 0 
*	0 0 0 0 0 1 0 0 	1 1 0 1 1 0 0 0 
*	0 1 0 1 1 0 0 1 	0 0 0 0 1 0 0 0 
*	0 0 0 1 1 1 0 0 	1 0 0 1 0 0 0 0 
*	1 0 1 1 1 0 0 1 	1 0 1 0 1 0 1 1 
*
* S = E1 B1 E0 0D 1A C1 B8 7B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_291 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[2];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[1] = in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	0 1 0 1 0 1 0 1 
	*	0 0 1 1 1 0 0 1 
	*	1 0 0 0 1 1 0 0 
	*	1 1 1 1 0 0 0 1 
	*	0 0 1 1 1 1 1 0 
	*	0 1 1 1 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 292
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	1 0 0 0 0 0 1 1 
*	0 1 1 1 0 0 0 0 	1 1 1 1 0 1 0 1 
*	0 0 0 0 0 0 1 0 	0 1 1 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 1 0 0 0 1 1 0 
*	0 1 0 0 0 1 0 1 	1 1 0 0 1 0 0 1 
*	1 0 1 0 0 0 0 1 	0 0 0 0 1 0 0 1 
*	1 0 1 1 1 1 0 1 	0 0 1 0 0 0 0 0 
*	0 1 0 0 0 0 0 1 	1 1 1 1 0 1 0 0 
*
* S = EC B0 51 0C 61 63 79 D9
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_292 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[2] ^ in[0];
	assign g_in[2] = in[7] ^ in[5] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[6] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	0 1 0 1 0 1 0 1 
	*	1 1 0 1 0 0 1 0 
	*	1 0 0 1 0 1 1 1 
	*	1 0 1 0 1 0 1 1 
	*	1 1 0 1 0 0 0 1 
	*	0 0 1 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 293
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 1 0 0 0 0 1 0 
*	0 1 1 1 1 1 0 0 	1 0 1 0 1 1 1 1 
*	1 0 1 0 1 1 0 0 	1 1 1 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 0 0 0 1 1 0 1 
*	1 1 1 0 0 1 0 0 	1 0 0 0 0 1 1 1 
*	0 1 0 0 0 1 0 1 	0 0 0 0 0 1 1 1 
*	1 1 1 1 1 1 0 0 	0 0 0 1 0 0 0 0 
*	1 0 1 1 1 1 0 1 	1 0 1 0 1 1 0 0 
*
* S = 5C EC 5D 51 02 61 A0 79
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_293 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[6] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	1 1 1 1 1 1 1 1 
	*	1 0 1 1 0 0 0 1 
	*	0 1 1 1 1 1 1 0 
	*	0 1 0 1 0 1 1 0 
	*	1 0 1 1 0 0 1 1 
	*	0 0 1 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 294
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 1 0 0 0 0 1 0 
*	0 1 1 1 0 0 0 0 	1 0 1 0 0 1 0 1 
*	1 0 1 0 1 1 0 0 	0 1 1 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 0 0 0 0 1 1 1 
*	1 1 1 0 0 1 0 0 	1 0 0 0 1 1 0 1 
*	1 0 1 0 0 0 0 1 	0 0 0 0 1 1 0 1 
*	1 1 1 1 1 1 0 0 	0 0 1 1 0 0 0 0 
*	0 1 0 0 0 0 0 1 	1 0 1 0 0 1 0 0 
*
* S = 5C B0 5D 0C 02 63 A0 D9
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_294 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[5] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[6] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	0 1 0 1 0 1 0 1 
	*	1 0 0 1 0 0 1 1 
	*	1 1 0 1 0 1 1 0 
	*	1 1 1 1 1 1 1 0 
	*	1 0 0 1 0 0 0 1 
	*	0 0 1 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 295
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 1 0 1 0 1 1 
*	1 1 0 1 1 1 1 0 	1 1 0 0 0 1 0 0 
*	1 1 0 1 1 1 0 0 	0 0 1 0 1 0 1 1 
*	0 0 0 0 1 1 1 0 	0 1 1 1 1 1 1 1 
*	1 1 1 1 1 0 0 0 	0 1 1 1 0 0 1 1 
*	1 1 1 0 0 0 0 0 	0 0 0 0 0 0 1 1 
*	0 1 0 1 1 1 0 1 	0 1 1 0 0 0 0 0 
*	0 1 0 1 1 0 0 1 	1 1 0 0 1 0 0 1 
*
* S = BD BC 50 B1 18 BA DB C1
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_295 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[6] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	0 1 0 0 0 1 0 0 
	*	1 0 1 0 0 1 1 0 
	*	0 0 1 1 0 0 1 0 
	*	1 0 0 0 0 1 0 1 
	*	1 0 1 0 1 1 0 1 
	*	1 0 1 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 296
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 1 0 1 1 0 
*	0 1 1 1 1 1 1 0 	1 0 0 0 1 1 0 0 
*	1 1 0 1 0 0 1 0 	0 0 0 1 0 1 1 0 
*	1 1 0 1 1 1 0 0 	1 1 1 0 1 0 1 0 
*	0 0 0 1 1 0 0 0 	1 1 1 0 0 0 1 0 
*	1 1 1 1 1 0 0 0 	0 0 0 0 0 0 1 0 
*	0 0 0 0 0 1 0 0 	1 1 0 1 0 0 0 0 
*	0 1 0 1 1 1 0 1 	1 0 0 0 0 1 1 1 
*
* S = 01 BD E1 50 A2 18 1A DB
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_296 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[1] = in[2];
	assign g_in[0] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	1 1 0 0 1 1 0 0 
	*	0 1 0 1 1 1 0 1 
	*	0 0 1 0 0 0 0 1 
	*	0 1 0 0 1 1 1 1 
	*	0 1 0 1 1 0 1 1 
	*	0 1 1 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 297
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 1 1 1 1 0 
*	1 1 0 1 1 1 1 0 	1 0 0 0 0 1 0 0 
*	1 1 0 1 0 0 1 0 	0 0 1 1 1 1 1 0 
*	0 0 0 0 1 1 1 0 	0 1 1 0 1 0 1 0 
*	0 0 0 1 1 0 0 0 	0 1 1 0 0 0 1 0 
*	1 1 1 0 0 0 0 0 	0 0 0 0 0 0 1 0 
*	0 0 0 0 0 1 0 0 	0 1 1 1 0 0 0 0 
*	0 1 0 1 1 0 0 1 	1 0 0 0 1 1 0 1 
*
* S = 01 BC E1 B1 A2 BA 1A C1
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_297 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5];
	assign g_in[1] = in[2];
	assign g_in[0] = in[6] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	0 1 0 0 0 1 0 0 
	*	1 1 1 1 0 1 1 1 
	*	0 0 1 0 0 0 1 1 
	*	1 1 0 0 0 1 0 1 
	*	1 1 1 1 1 0 0 1 
	*	1 1 1 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 298
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 1 0 0 1 1 1 
*	1 1 0 1 1 1 1 0 	1 1 0 0 0 1 0 0 
*	1 0 1 0 0 0 1 0 	1 0 1 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 0 1 1 0 0 1 1 
*	1 1 1 1 1 0 0 0 	1 0 1 1 1 1 1 1 
*	1 1 1 0 0 0 0 0 	0 0 0 0 1 1 1 1 
*	1 0 1 0 0 1 0 1 	1 1 1 0 0 0 0 0 
*	1 0 1 1 1 0 0 1 	1 1 0 0 1 1 0 1 
*
* S = BD BC ED 0D 18 BA C3 7B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_298 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5];
	assign g_in[1] = in[7] ^ in[5] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	0 1 0 0 0 1 0 0 
	*	0 0 1 0 1 1 1 0 
	*	1 1 1 1 1 0 1 0 
	*	1 0 0 0 0 0 0 1 
	*	0 0 1 0 1 0 0 1 
	*	0 1 1 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 299
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 1 1 1 1 0 
*	0 1 1 1 1 1 1 0 	1 0 0 0 1 1 0 0 
*	0 1 1 1 0 0 1 0 	0 1 0 1 1 1 1 0 
*	1 0 1 0 0 0 1 0 	0 1 1 0 0 0 1 0 
*	0 0 0 1 1 0 0 0 	0 1 1 0 1 0 1 0 
*	1 1 1 1 1 0 0 0 	0 0 0 0 1 0 1 0 
*	0 0 0 1 1 1 0 0 	1 0 0 1 0 0 0 0 
*	1 0 1 0 0 1 0 1 	1 0 0 0 1 0 1 1 
*
* S = 01 BD E0 ED A2 18 B8 C3
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_299 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[1] = in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	1 1 0 0 1 1 0 0 
	*	0 0 0 1 1 0 0 1 
	*	1 0 1 0 0 1 0 1 
	*	0 1 0 0 0 0 1 1 
	*	0 0 0 1 0 1 1 1 
	*	1 1 1 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 300
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 1 0 1 1 0 
*	1 1 0 1 1 1 1 0 	1 0 0 0 0 1 0 0 
*	0 1 1 1 0 0 1 0 	1 1 1 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 1 1 0 0 0 1 0 
*	0 0 0 1 1 0 0 0 	1 1 1 0 1 0 1 0 
*	1 1 1 0 0 0 0 0 	0 0 0 0 1 0 1 0 
*	0 0 0 1 1 1 0 0 	1 0 1 1 0 0 0 0 
*	1 0 1 1 1 0 0 1 	1 0 0 0 1 0 0 1 
*
* S = 01 BC E0 0D A2 BA B8 7B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_300 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5];
	assign g_in[1] = in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	0 1 0 0 0 1 0 0 
	*	0 0 1 1 1 0 1 1 
	*	1 0 1 0 1 1 1 1 
	*	1 1 0 0 0 0 0 1 
	*	0 0 1 1 1 1 0 1 
	*	0 1 1 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 301
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 1 0 1 1 1 1 
*	1 1 0 1 1 1 1 0 	1 1 0 0 0 1 0 0 
*	0 1 1 1 1 1 0 0 	1 1 1 0 1 1 1 1 
*	0 1 1 1 0 0 0 0 	0 0 1 1 1 0 1 1 
*	1 1 1 1 1 0 0 0 	0 0 1 1 0 1 1 1 
*	1 1 1 0 0 0 0 0 	0 0 0 0 0 1 1 1 
*	0 1 0 0 0 1 0 1 	1 0 1 0 0 0 0 0 
*	1 0 1 0 0 0 0 1 	1 1 0 0 0 0 0 1 
*
* S = BD BC EC B0 18 BA 61 63
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_301 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5];
	assign g_in[1] = in[6] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	0 1 0 0 0 1 0 0 
	*	0 1 1 0 1 0 1 0 
	*	0 1 1 1 1 1 1 0 
	*	1 0 0 0 1 1 0 1 
	*	0 1 1 0 0 1 0 1 
	*	1 1 1 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 302
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 1 1 0 1 0 
*	0 1 1 1 1 1 1 0 	1 0 0 0 1 1 0 0 
*	0 0 0 0 1 1 0 0 	1 0 0 1 1 0 1 0 
*	0 1 1 1 1 1 0 0 	0 0 1 0 0 1 1 0 
*	0 0 0 1 1 0 0 0 	0 0 1 0 1 1 1 0 
*	1 1 1 1 1 0 0 0 	0 0 0 0 1 1 1 0 
*	1 1 1 0 0 1 0 0 	0 1 0 1 0 0 0 0 
*	0 1 0 0 0 1 0 1 	1 0 0 0 0 0 1 1 
*
* S = 01 BD 5C EC A2 18 02 61
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_302 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[2];
	assign g_in[0] = in[6] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 1 0 0 1 1 0 0 
	*	1 1 0 1 0 1 0 1 
	*	1 1 1 0 1 0 0 1 
	*	0 1 0 0 1 0 1 1 
	*	1 1 0 1 1 1 1 1 
	*	1 0 1 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 303
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 1 1 0 1 0 
*	1 1 0 1 1 1 1 0 	1 0 0 0 0 1 0 0 
*	0 0 0 0 1 1 0 0 	1 0 1 1 1 0 1 0 
*	0 1 1 1 0 0 0 0 	0 0 1 0 1 1 1 0 
*	0 0 0 1 1 0 0 0 	0 0 1 0 0 1 1 0 
*	1 1 1 0 0 0 0 0 	0 0 0 0 0 1 1 0 
*	1 1 1 0 0 1 0 0 	1 1 1 1 0 0 0 0 
*	1 0 1 0 0 0 0 1 	1 0 0 0 0 0 0 1 
*
* S = 01 BC 5C B0 A2 BA 02 63
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_303 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	0 1 0 0 0 1 0 0 
	*	0 1 1 1 1 1 1 1 
	*	0 1 1 0 1 0 1 1 
	*	1 1 0 0 1 0 0 1 
	*	0 1 1 1 0 1 0 1 
	*	1 0 1 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 304
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 1 0 0 0 1 1 
*	1 1 0 1 1 1 1 0 	1 1 0 0 0 1 0 0 
*	0 0 0 0 0 0 1 0 	0 1 1 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 1 1 1 0 1 1 1 
*	1 1 1 1 1 0 0 0 	1 1 1 1 1 0 1 1 
*	1 1 1 0 0 0 0 0 	0 0 0 0 1 0 1 1 
*	1 0 1 1 1 1 0 1 	0 0 1 0 0 0 0 0 
*	0 1 0 0 0 0 0 1 	1 1 0 0 0 1 0 1 
*
* S = BD BC 51 0C 18 BA 79 D9
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_304 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[6] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	0 1 0 0 0 1 0 0 
	*	1 1 1 0 0 0 1 0 
	*	1 0 1 1 0 1 1 0 
	*	1 0 0 0 1 0 0 1 
	*	1 1 1 0 0 0 0 1 
	*	0 0 1 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 305
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 1 0 0 1 0 
*	0 1 1 1 1 1 1 0 	1 0 0 0 1 1 0 0 
*	1 0 1 0 1 1 0 0 	1 1 0 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 0 1 0 1 1 1 0 
*	0 0 0 1 1 0 0 0 	1 0 1 0 0 1 1 0 
*	1 1 1 1 1 0 0 0 	0 0 0 0 0 1 1 0 
*	1 1 1 1 1 1 0 0 	0 0 0 1 0 0 0 0 
*	1 0 1 1 1 1 0 1 	1 0 0 0 1 1 1 1 
*
* S = 01 BD 5D 51 A2 18 A0 79
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_305 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	1 1 0 0 1 1 0 0 
	*	1 0 0 1 0 0 0 1 
	*	0 1 1 0 1 1 0 1 
	*	0 1 0 0 0 1 1 1 
	*	1 0 0 1 0 0 1 1 
	*	0 0 1 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 306
*
* GF(2^8) Poly Basis: [L^1, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 1 0 0 1 0 
*	1 1 0 1 1 1 1 0 	1 0 0 0 0 1 0 0 
*	1 0 1 0 1 1 0 0 	0 1 1 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 0 1 0 0 1 1 0 
*	0 0 0 1 1 0 0 0 	1 0 1 0 1 1 1 0 
*	1 1 1 0 0 0 0 0 	0 0 0 0 1 1 1 0 
*	1 1 1 1 1 1 0 0 	0 0 1 1 0 0 0 0 
*	0 1 0 0 0 0 0 1 	1 0 0 0 0 1 0 1 
*
* S = 01 BC 5D 0C A2 BA A0 D9
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_306 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[6] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 0 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	0 1 0 0 0 1 0 0 
	*	1 0 1 1 0 0 1 1 
	*	1 1 1 0 0 1 1 1 
	*	1 1 0 0 1 1 0 1 
	*	1 0 1 1 0 0 0 1 
	*	0 0 1 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 307
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	0 0 0 1 0 1 1 0 
*	0 0 0 0 1 1 1 0 	1 0 1 0 0 1 0 1 
*	1 0 1 0 0 0 1 0 	1 1 1 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 0 1 0 0 0 1 1 
*	1 0 0 0 0 0 0 1 	0 1 0 1 1 1 0 0 
*	0 1 0 1 0 1 1 1 	1 1 0 0 1 1 0 0 
*	0 0 0 0 0 1 1 1 	1 1 0 1 0 0 0 0 
*	0 1 1 0 1 0 0 1 	0 0 0 1 1 1 1 0 
*
* S = 50 B1 ED 0D 8B 70 2E 76
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_307 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[0];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	0 0 0 0 0 1 0 1 
	*	1 1 1 1 1 1 0 1 
	*	0 1 0 0 1 0 0 0 
	*	1 0 1 1 0 0 0 1 
	*	1 0 0 1 1 0 1 1 
	*	1 1 1 0 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[3];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 308
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 0 1 1 1 1 0 1 
*	1 1 0 1 1 1 0 0 	0 1 0 1 1 1 1 1 
*	0 1 1 1 0 0 1 0 	1 0 0 1 1 1 0 1 
*	1 0 1 0 0 0 1 0 	0 1 0 1 0 0 1 0 
*	1 1 0 1 0 1 1 0 	1 1 1 1 1 0 0 0 
*	1 0 0 0 0 0 0 1 	1 0 0 0 1 0 0 0 
*	0 1 1 0 1 1 1 0 	1 0 1 1 0 0 0 0 
*	0 0 0 0 0 1 1 1 	0 0 1 1 1 0 0 1 
*
* S = E1 50 E0 ED FB 8B 58 2E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_308 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	0 0 0 0 1 1 1 1 
	*	1 0 1 0 1 0 1 1 
	*	1 1 0 0 0 1 0 0 
	*	0 1 1 0 0 0 1 1 
	*	0 1 1 1 0 1 1 0 
	*	1 0 0 1 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[2];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 309
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 0 0 1 0 1 1 1 
*	0 0 0 0 1 1 1 0 	1 1 1 1 0 1 0 1 
*	0 1 1 1 0 0 1 0 	1 0 1 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 1 1 1 0 0 1 0 
*	1 1 0 1 0 1 1 0 	0 1 0 1 1 0 0 0 
*	0 1 0 1 0 1 1 1 	1 0 0 0 1 0 0 0 
*	0 1 1 0 1 1 1 0 	1 0 0 1 0 0 0 0 
*	0 1 1 0 1 0 0 1 	0 0 0 1 1 0 1 1 
*
* S = E1 B1 E0 0D FB 70 58 76
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_309 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	0 0 0 0 0 1 0 1 
	*	1 0 1 0 1 0 0 1 
	*	0 1 0 0 1 1 0 0 
	*	1 1 1 0 0 0 0 1 
	*	1 1 0 1 1 1 1 0 
	*	1 0 1 1 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 310
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	1 0 1 1 0 0 1 1 
*	0 1 1 1 0 0 0 0 	1 0 1 0 0 1 0 1 
*	0 0 0 0 0 0 1 0 	0 1 0 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 0 1 0 0 1 1 0 
*	0 0 1 1 1 0 0 1 	0 1 0 1 1 0 0 1 
*	1 1 0 1 0 0 0 1 	1 0 0 1 1 0 0 1 
*	1 0 1 1 1 1 1 1 	0 0 1 0 0 0 0 0 
*	1 1 1 0 1 1 1 1 	1 0 1 1 0 1 0 0 
*
* S = EC B0 51 0C 8D D3 28 D5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_310 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	0 0 0 0 0 1 0 1 
	*	1 1 1 1 0 0 1 0 
	*	1 1 1 0 0 1 1 1 
	*	0 0 0 1 1 0 1 1 
	*	1 1 0 0 0 0 0 1 
	*	0 1 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 311
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 1 1 0 0 0 1 0 
*	0 1 1 1 1 1 0 0 	0 1 0 1 1 1 1 1 
*	1 0 1 0 1 1 0 0 	1 1 0 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 1 0 1 1 1 0 1 
*	1 1 1 0 1 0 0 0 	1 1 1 1 0 1 1 1 
*	0 0 1 1 1 0 0 1 	0 1 1 1 0 1 1 1 
*	0 1 0 1 0 0 0 0 	0 0 0 1 0 0 0 0 
*	1 0 1 1 1 1 1 1 	0 1 1 0 1 1 0 0 
*
* S = 5C EC 5D 51 5E 8D FD 28
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_311 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[1] = in[6] ^ in[4];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	0 0 0 0 1 1 1 1 
	*	1 0 1 0 0 0 0 1 
	*	1 0 0 1 1 1 1 0 
	*	0 0 1 1 0 1 1 0 
	*	1 0 0 0 0 0 1 1 
	*	1 1 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 312
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 1 1 0 0 0 1 0 
*	0 1 1 1 0 0 0 0 	1 1 1 1 0 1 0 1 
*	1 0 1 0 1 1 0 0 	0 1 0 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 1 1 1 0 1 1 1 
*	1 1 1 0 1 0 0 0 	0 1 0 1 1 1 0 1 
*	1 1 0 1 0 0 0 1 	1 1 0 1 1 1 0 1 
*	0 1 0 1 0 0 0 0 	0 0 1 1 0 0 0 0 
*	1 1 1 0 1 1 1 1 	1 1 1 0 0 1 0 0 
*
* S = 5C B0 5D 0C 5E D3 FD D5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_312 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[0];
	assign g_in[1] = in[6] ^ in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	0 0 0 0 0 1 0 1 
	*	1 0 1 0 0 0 1 1 
	*	1 0 1 1 0 1 1 0 
	*	0 0 0 1 1 1 1 0 
	*	1 0 0 0 0 0 0 1 
	*	0 1 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 313
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 0 1 1 0 1 1 
*	1 1 0 1 1 1 1 0 	1 0 0 0 0 1 0 0 
*	1 1 0 1 1 1 0 0 	1 0 0 1 1 0 1 1 
*	0 0 0 0 1 1 1 0 	1 0 0 0 1 1 1 1 
*	1 0 0 0 0 1 1 0 	0 1 0 0 0 0 1 1 
*	0 0 1 1 1 1 1 0 	0 0 1 1 0 0 1 1 
*	1 0 0 0 0 0 0 1 	0 1 1 0 0 0 0 0 
*	0 1 0 1 0 1 1 1 	0 1 0 1 1 0 0 1 
*
* S = BD BC 50 B1 A5 06 8B 70
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_313 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[0];
	assign g_in[0] = in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	0 0 0 0 0 1 0 0 
	*	1 1 0 0 0 1 1 0 
	*	0 0 0 1 0 0 1 0 
	*	1 1 0 1 0 1 0 1 
	*	0 1 1 1 1 1 0 1 
	*	1 0 0 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[4] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 314
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 1 0 1 1 0 
*	0 1 1 1 1 1 1 0 	0 1 0 0 1 1 0 0 
*	1 1 0 1 0 0 1 0 	0 1 1 1 0 1 1 0 
*	1 1 0 1 1 1 0 0 	0 1 0 0 1 0 1 0 
*	1 0 1 1 1 0 0 0 	1 1 0 0 0 0 1 0 
*	1 0 0 0 0 1 1 0 	0 0 1 0 0 0 1 0 
*	1 1 0 1 0 1 1 0 	1 1 0 1 0 0 0 0 
*	1 0 0 0 0 0 0 1 	1 1 1 1 0 1 1 1 
*
* S = 01 BD E1 50 A3 A5 FB 8B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_314 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	0 0 0 0 1 1 0 0 
	*	1 0 0 0 1 1 0 1 
	*	0 0 1 1 0 0 0 1 
	*	1 0 1 1 1 1 1 1 
	*	1 1 1 0 1 0 1 1 
	*	0 1 1 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 315
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 1 1 1 1 0 
*	1 1 0 1 1 1 1 0 	1 1 0 0 0 1 0 0 
*	1 1 0 1 0 0 1 0 	1 1 0 1 1 1 1 0 
*	0 0 0 0 1 1 1 0 	1 1 0 0 1 0 1 0 
*	1 0 1 1 1 0 0 0 	0 1 0 0 0 0 1 0 
*	0 0 1 1 1 1 1 0 	0 0 1 0 0 0 1 0 
*	1 1 0 1 0 1 1 0 	0 1 1 1 0 0 0 0 
*	0 1 0 1 0 1 1 1 	0 1 0 1 1 1 0 1 
*
* S = 01 BC E1 B1 A3 06 FB 70
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_315 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	0 0 0 0 0 1 0 0 
	*	1 0 0 0 0 1 1 1 
	*	0 0 0 1 0 0 1 1 
	*	1 0 0 1 0 1 0 1 
	*	0 1 1 0 1 0 0 1 
	*	1 1 0 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 316
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 0 1 0 1 1 1 
*	1 1 0 1 1 1 1 0 	1 0 0 0 0 1 0 0 
*	1 0 1 0 0 0 1 0 	1 1 0 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 0 0 0 0 0 1 1 
*	1 0 0 0 0 1 1 0 	0 1 0 0 1 1 1 1 
*	0 0 1 1 1 1 1 0 	1 1 1 1 1 1 1 1 
*	0 0 0 0 0 1 1 1 	1 1 1 0 0 0 0 0 
*	0 1 1 0 1 0 0 1 	0 0 0 1 1 1 0 1 
*
* S = BD BC ED 0D A5 06 2E 76
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_316 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	0 0 0 0 0 1 0 0 
	*	1 1 0 0 1 1 1 0 
	*	0 1 0 1 1 0 1 0 
	*	1 0 0 1 0 0 0 1 
	*	1 0 1 1 1 0 0 1 
	*	1 1 0 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 317
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 1 1 1 1 0 
*	0 1 1 1 1 1 1 0 	0 1 0 0 1 1 0 0 
*	0 1 1 1 0 0 1 0 	1 0 1 1 1 1 1 0 
*	1 0 1 0 0 0 1 0 	0 1 0 0 0 0 1 0 
*	1 0 1 1 1 0 0 0 	1 1 0 0 1 0 1 0 
*	1 0 0 0 0 1 1 0 	1 0 1 0 1 0 1 0 
*	0 1 1 0 1 1 1 0 	1 0 0 1 0 0 0 0 
*	0 0 0 0 0 1 1 1 	0 0 1 1 1 0 1 1 
*
* S = 01 BD E0 ED A3 A5 58 2E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_317 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	0 0 0 0 1 1 0 0 
	*	1 0 0 0 1 0 0 1 
	*	1 1 1 1 0 1 0 1 
	*	0 1 1 1 0 0 1 1 
	*	0 1 1 0 0 1 1 1 
	*	1 0 1 1 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 318
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 1 0 1 1 0 
*	1 1 0 1 1 1 1 0 	1 1 0 0 0 1 0 0 
*	0 1 1 1 0 0 1 0 	1 0 0 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 1 0 0 0 0 1 0 
*	1 0 1 1 1 0 0 0 	0 1 0 0 1 0 1 0 
*	0 0 1 1 1 1 1 0 	1 0 1 0 1 0 1 0 
*	0 1 1 0 1 1 1 0 	1 0 1 1 0 0 0 0 
*	0 1 1 0 1 0 0 1 	0 0 0 1 1 0 0 1 
*
* S = 01 BC E0 0D A3 06 58 76
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_318 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	0 0 0 0 0 1 0 0 
	*	1 0 0 0 1 0 1 1 
	*	0 1 0 1 1 1 1 1 
	*	1 1 0 1 0 0 0 1 
	*	1 1 1 0 1 1 0 1 
	*	1 0 0 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 319
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 0 1 1 1 1 1 
*	1 1 0 1 1 1 1 0 	1 0 0 0 0 1 0 0 
*	0 1 1 1 1 1 0 0 	0 0 0 1 1 1 1 1 
*	0 1 1 1 0 0 0 0 	1 0 0 0 1 0 1 1 
*	1 0 0 0 0 1 1 0 	0 1 0 0 0 1 1 1 
*	0 0 1 1 1 1 1 0 	0 1 1 1 0 1 1 1 
*	0 0 1 1 1 0 0 1 	1 0 1 0 0 0 0 0 
*	1 1 0 1 0 0 0 1 	1 1 0 1 0 0 0 1 
*
* S = BD BC EC B0 A5 06 8D D3
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_319 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	0 0 0 0 0 1 0 0 
	*	1 1 0 0 1 0 1 0 
	*	1 0 0 1 1 1 1 0 
	*	0 1 0 1 1 1 0 1 
	*	0 0 1 1 0 1 0 1 
	*	0 0 0 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 320
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 1 1 0 1 0 
*	0 1 1 1 1 1 1 0 	0 1 0 0 1 1 0 0 
*	0 0 0 0 1 1 0 0 	0 0 1 1 1 0 1 0 
*	0 1 1 1 1 1 0 0 	0 1 0 0 0 1 1 0 
*	1 0 1 1 1 0 0 0 	1 1 0 0 1 1 1 0 
*	1 0 0 0 0 1 1 0 	1 1 1 0 1 1 1 0 
*	1 1 1 0 1 0 0 0 	0 1 0 1 0 0 0 0 
*	0 0 1 1 1 0 0 1 	1 0 1 1 0 0 1 1 
*
* S = 01 BD 5C EC A3 A5 5E 8D
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_320 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[3];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	0 0 0 0 1 1 0 0 
	*	1 0 0 0 0 1 0 1 
	*	0 1 1 1 1 0 0 1 
	*	1 1 1 1 1 0 1 1 
	*	0 0 1 0 1 1 1 1 
	*	0 0 1 1 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 321
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 1 1 0 1 0 
*	1 1 0 1 1 1 1 0 	1 1 0 0 0 1 0 0 
*	0 0 0 0 1 1 0 0 	0 0 0 1 1 0 1 0 
*	0 1 1 1 0 0 0 0 	1 1 0 0 1 1 1 0 
*	1 0 1 1 1 0 0 0 	0 1 0 0 0 1 1 0 
*	0 0 1 1 1 1 1 0 	0 1 1 0 0 1 1 0 
*	1 1 1 0 1 0 0 0 	1 1 1 1 0 0 0 0 
*	1 1 0 1 0 0 0 1 	1 0 0 1 0 0 0 1 
*
* S = 01 BC 5C B0 A3 06 5E D3
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_321 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[3];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	0 0 0 0 0 1 0 0 
	*	1 0 0 0 1 1 1 1 
	*	1 1 0 1 1 0 1 1 
	*	0 1 0 1 1 0 0 1 
	*	0 0 1 0 0 1 0 1 
	*	0 0 0 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 322
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 0 1 0 0 1 1 
*	1 1 0 1 1 1 1 0 	1 0 0 0 0 1 0 0 
*	0 0 0 0 0 0 1 0 	0 1 0 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 0 0 0 0 1 1 1 
*	1 0 0 0 0 1 1 0 	0 1 0 0 1 0 1 1 
*	0 0 1 1 1 1 1 0 	1 0 1 1 1 0 1 1 
*	1 0 1 1 1 1 1 1 	0 0 1 0 0 0 0 0 
*	1 1 1 0 1 1 1 1 	1 0 0 1 0 1 0 1 
*
* S = BD BC 51 0C A5 06 28 D5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_322 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	0 0 0 0 0 1 0 0 
	*	1 1 0 0 0 0 1 0 
	*	1 1 0 1 0 1 1 0 
	*	0 0 0 1 1 0 0 1 
	*	1 1 1 1 0 0 0 1 
	*	0 1 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 323
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 1 0 0 1 0 
*	0 1 1 1 1 1 1 0 	0 1 0 0 1 1 0 0 
*	1 0 1 0 1 1 0 0 	1 1 1 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 1 0 0 1 1 1 0 
*	1 0 1 1 1 0 0 0 	1 1 0 0 0 1 1 0 
*	1 0 0 0 0 1 1 0 	0 1 1 0 0 1 1 0 
*	0 1 0 1 0 0 0 0 	0 0 0 1 0 0 0 0 
*	1 0 1 1 1 1 1 1 	0 1 1 1 1 1 1 1 
*
* S = 01 BD 5D 51 A3 A5 FD 28
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_323 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[7] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[4];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	0 0 0 0 1 1 0 0 
	*	1 0 0 0 0 0 0 1 
	*	1 0 1 1 1 1 0 1 
	*	0 0 1 1 0 1 1 1 
	*	1 0 1 0 0 0 1 1 
	*	1 1 1 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 324
*
* GF(2^8) Poly Basis: [L^16, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 1 0 0 1 0 
*	1 1 0 1 1 1 1 0 	1 1 0 0 0 1 0 0 
*	1 0 1 0 1 1 0 0 	0 1 0 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 1 0 0 0 1 1 0 
*	1 0 1 1 1 0 0 0 	0 1 0 0 1 1 1 0 
*	0 0 1 1 1 1 1 0 	1 1 1 0 1 1 1 0 
*	0 1 0 1 0 0 0 0 	0 0 1 1 0 0 0 0 
*	1 1 1 0 1 1 1 1 	1 1 0 1 0 1 0 1 
*
* S = 01 BC 5D 0C A3 06 FD D5
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_324 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	0 0 0 0 0 1 0 0 
	*	1 0 0 0 0 0 1 1 
	*	1 0 0 1 0 1 1 1 
	*	0 0 0 1 1 1 0 1 
	*	1 0 1 0 0 0 0 1 
	*	0 1 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[2] );
	assign out[4] = g_out[7] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 325
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	1 1 1 0 0 1 1 0 
*	0 0 0 0 1 1 1 0 	1 1 0 1 0 1 0 1 
*	1 0 1 0 0 0 1 0 	0 0 0 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 0 1 0 0 0 1 1 
*	1 0 0 0 0 0 1 1 	0 0 1 1 1 1 0 0 
*	1 1 1 1 1 0 0 1 	1 0 1 0 1 1 0 0 
*	0 0 0 0 1 0 0 1 	1 1 0 1 0 0 0 0 
*	1 0 1 1 1 0 1 1 	0 0 1 1 1 1 1 0 
*
* S = 50 B1 ED 0D 6B 9D C2 C6
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_325 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[1] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[1] = in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	0 1 1 1 0 1 0 1 
	*	0 1 0 1 1 1 0 1 
	*	1 0 0 1 1 0 0 0 
	*	0 1 1 1 0 0 0 1 
	*	1 1 0 0 1 0 1 1 
	*	0 0 1 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 326
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 0 0 1 1 1 0 1 
*	1 1 0 1 1 1 0 0 	1 0 1 1 1 1 1 1 
*	0 1 1 1 0 0 1 0 	0 0 1 1 1 1 0 1 
*	1 0 1 0 0 0 1 0 	0 0 0 1 0 0 1 0 
*	0 1 1 1 1 0 1 0 	0 0 1 0 1 0 0 0 
*	1 0 0 0 0 0 1 1 	0 1 0 1 1 0 0 0 
*	1 0 1 1 0 0 1 0 	1 0 1 1 0 0 0 0 
*	0 0 0 0 1 0 0 1 	0 0 1 0 1 0 0 1 
*
* S = E1 50 E0 ED F6 6B 04 C2
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_326 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	1 1 1 0 1 1 1 1 
	*	1 1 1 1 1 0 1 1 
	*	0 1 1 1 0 1 0 0 
	*	1 1 1 0 0 0 1 1 
	*	1 0 0 0 0 1 1 0 
	*	0 0 1 0 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[5] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 327
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 0 1 1 0 1 1 1 
*	0 0 0 0 1 1 1 0 	1 0 0 1 0 1 0 1 
*	0 1 1 1 0 0 1 0 	0 0 0 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 0 1 1 0 0 1 0 
*	0 1 1 1 1 0 1 0 	0 0 1 0 1 0 0 0 
*	1 1 1 1 1 0 0 1 	1 1 1 1 1 0 0 0 
*	1 0 1 1 0 0 1 0 	1 0 0 1 0 0 0 0 
*	1 0 1 1 1 0 1 1 	0 0 1 0 1 0 1 1 
*
* S = E1 B1 E0 0D F6 9D 04 C6
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_327 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	0 1 1 0 0 1 0 1 
	*	0 1 0 1 1 0 0 1 
	*	1 1 0 1 1 1 0 0 
	*	0 1 1 0 0 0 0 1 
	*	1 0 0 0 1 1 1 0 
	*	0 0 1 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[5] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 328
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	0 1 0 0 0 0 1 1 
*	0 1 1 1 0 0 0 0 	0 0 1 0 0 1 0 1 
*	0 0 0 0 0 0 1 0 	1 0 1 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 1 0 1 0 1 1 0 
*	0 1 0 0 1 0 1 1 	0 1 1 0 1 0 0 1 
*	0 1 1 1 0 0 1 1 	1 0 1 0 1 0 0 1 
*	1 1 0 0 0 0 0 1 	0 0 1 0 0 0 0 0 
*	0 0 1 1 0 0 0 1 	0 1 1 0 0 1 0 0 
*
* S = EC B0 51 0C 30 6F 99 34
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_328 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[0];
	assign g_in[0] = in[5] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	1 0 0 0 0 1 0 1 
	*	0 1 0 1 0 0 1 0 
	*	1 1 0 0 0 1 1 1 
	*	1 0 0 0 1 0 1 1 
	*	1 0 0 1 0 0 0 1 
	*	0 1 1 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[7] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 329
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 1 0 0 0 0 1 0 
*	0 1 1 1 1 1 0 0 	0 0 0 1 1 1 1 1 
*	1 0 1 0 1 1 0 0 	0 1 1 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 0 1 1 1 1 0 1 
*	0 0 1 1 1 0 0 0 	1 1 0 1 0 1 1 1 
*	0 1 0 0 1 0 1 1 	0 1 0 1 0 1 1 1 
*	1 1 1 1 0 0 0 0 	0 0 0 1 0 0 0 0 
*	1 1 0 0 0 0 0 1 	1 1 0 1 1 1 0 0 
*
* S = 5C EC 5D 51 5F 30 AD 99
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_329 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[6] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	0 1 0 0 1 1 1 1 
	*	1 1 1 1 0 0 0 1 
	*	1 0 0 0 1 1 1 0 
	*	0 1 0 0 0 1 1 0 
	*	0 1 1 1 0 0 1 1 
	*	1 1 0 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 330
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 1 0 0 0 0 1 0 
*	0 1 1 1 0 0 0 0 	0 0 1 1 0 1 0 1 
*	1 0 1 0 1 1 0 0 	1 1 1 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 0 0 1 0 1 1 1 
*	0 0 1 1 1 0 0 0 	0 1 1 1 1 1 0 1 
*	0 1 1 1 0 0 1 1 	1 1 1 1 1 1 0 1 
*	1 1 1 1 0 0 0 0 	0 0 1 1 0 0 0 0 
*	0 0 1 1 0 0 0 1 	0 1 1 1 0 1 0 0 
*
* S = 5C B0 5D 0C 5F 6F AD 34
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_330 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4];
	assign g_in[0] = in[5] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	1 1 0 0 0 1 0 1 
	*	0 1 0 1 0 0 1 1 
	*	1 0 0 0 0 1 1 0 
	*	1 1 0 0 1 1 1 0 
	*	1 1 0 1 0 0 0 1 
	*	0 1 1 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 331
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 0 1 1 0 1 1 
*	1 1 0 1 1 1 1 0 	0 1 1 0 0 1 0 0 
*	1 1 0 1 1 1 0 0 	0 1 0 1 1 0 1 1 
*	0 0 0 0 1 1 1 0 	1 0 1 0 1 1 1 1 
*	1 0 0 0 1 0 1 0 	1 1 1 1 0 0 1 1 
*	0 1 0 0 0 0 1 0 	1 0 0 0 0 0 1 1 
*	1 0 0 0 0 0 1 1 	0 1 1 0 0 0 0 0 
*	1 1 1 1 1 0 0 1 	1 1 1 1 1 0 0 1 
*
* S = BD BC 50 B1 A9 5B 6B 9D
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_331 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[1];
	assign g_in[1] = in[7] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	1 1 1 0 0 1 0 0 
	*	0 1 0 0 0 1 1 0 
	*	0 1 1 1 0 0 1 0 
	*	1 1 1 0 0 1 0 1 
	*	0 0 1 1 1 1 0 1 
	*	1 1 1 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 332
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 1 0 1 1 0 
*	0 1 1 1 1 1 1 0 	1 1 0 1 1 1 0 0 
*	1 1 0 1 0 0 1 0 	1 1 1 1 0 1 1 0 
*	1 1 0 1 1 1 0 0 	0 1 0 1 1 0 1 0 
*	1 1 0 0 1 0 0 0 	1 0 1 0 0 0 1 0 
*	1 0 0 0 1 0 1 0 	0 1 0 0 0 0 1 0 
*	0 1 1 1 1 0 1 0 	1 1 0 1 0 0 0 0 
*	1 0 0 0 0 0 1 1 	1 0 1 0 0 1 1 1 
*
* S = 01 BD E1 50 F2 A9 F6 6B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_332 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[6] ^ in[3];
	assign g_in[2] = in[7] ^ in[3] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	1 0 0 1 1 1 0 0 
	*	1 1 0 0 1 1 0 1 
	*	1 1 1 0 0 0 0 1 
	*	1 0 0 1 1 1 1 1 
	*	0 0 1 0 1 0 1 1 
	*	1 0 1 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 333
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 1 1 1 1 0 
*	1 1 0 1 1 1 1 0 	0 1 1 1 0 1 0 0 
*	1 1 0 1 0 0 1 0 	0 1 0 1 1 1 1 0 
*	0 0 0 0 1 1 1 0 	1 1 1 1 1 0 1 0 
*	1 1 0 0 1 0 0 0 	1 0 1 0 0 0 1 0 
*	0 1 0 0 0 0 1 0 	1 1 0 0 0 0 1 0 
*	0 1 1 1 1 0 1 0 	0 1 1 1 0 0 0 0 
*	1 1 1 1 1 0 0 1 	1 0 1 0 1 1 0 1 
*
* S = 01 BC E1 B1 F2 5B F6 9D
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_333 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[3];
	assign g_in[2] = in[6] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	1 0 1 1 0 1 0 0 
	*	0 1 0 0 0 1 1 1 
	*	0 1 1 0 0 0 1 1 
	*	1 0 1 1 0 1 0 1 
	*	0 0 1 0 1 0 0 1 
	*	1 0 1 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 334
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 0 1 0 1 1 1 
*	1 1 0 1 1 1 1 0 	1 1 1 0 0 1 0 0 
*	1 0 1 0 0 0 1 0 	0 0 0 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 0 1 0 0 0 1 1 
*	1 0 0 0 1 0 1 0 	0 0 1 1 1 1 1 1 
*	0 1 0 0 0 0 1 0 	1 0 0 0 1 1 1 1 
*	0 0 0 0 1 0 0 1 	1 1 1 0 0 0 0 0 
*	1 0 1 1 1 0 1 1 	0 0 1 1 1 1 0 1 
*
* S = BD BC ED 0D A9 5B C2 C6
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_334 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[1];
	assign g_in[1] = in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	0 1 1 0 0 1 0 0 
	*	0 1 0 0 1 1 1 0 
	*	1 0 1 1 1 0 1 0 
	*	0 1 1 0 0 0 0 1 
	*	1 1 1 1 1 0 0 1 
	*	0 0 1 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 335
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 1 1 1 1 0 
*	0 1 1 1 1 1 1 0 	1 0 0 1 1 1 0 0 
*	0 1 1 1 0 0 1 0 	0 0 1 1 1 1 1 0 
*	1 0 1 0 0 0 1 0 	0 0 0 1 0 0 1 0 
*	1 1 0 0 1 0 0 0 	0 0 1 0 1 0 1 0 
*	1 0 0 0 1 0 1 0 	0 1 0 0 1 0 1 0 
*	1 0 1 1 0 0 1 0 	1 0 0 1 0 0 0 0 
*	0 0 0 0 1 0 0 1 	0 0 1 0 1 0 1 1 
*
* S = 01 BD E0 ED F2 A9 04 C2
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_335 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[3];
	assign g_in[2] = in[7] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	1 1 0 1 1 1 0 0 
	*	1 1 0 0 1 0 0 1 
	*	0 1 1 0 0 1 0 1 
	*	1 1 0 1 0 0 1 1 
	*	1 0 1 0 0 1 1 1 
	*	0 0 1 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 336
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 1 0 1 1 0 
*	1 1 0 1 1 1 1 0 	1 0 1 1 0 1 0 0 
*	0 1 1 1 0 0 1 0 	0 0 0 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 0 1 1 0 0 1 0 
*	1 1 0 0 1 0 0 0 	0 0 1 0 1 0 1 0 
*	0 1 0 0 0 0 1 0 	1 1 0 0 1 0 1 0 
*	1 0 1 1 0 0 1 0 	1 0 1 1 0 0 0 0 
*	1 0 1 1 1 0 1 1 	0 0 1 0 1 0 0 1 
*
* S = 01 BC E0 0D F2 5B 04 C6
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_336 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[3];
	assign g_in[2] = in[6] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	0 1 1 1 0 1 0 0 
	*	0 1 0 0 1 0 1 1 
	*	1 1 1 0 1 1 1 1 
	*	0 1 1 1 0 0 0 1 
	*	1 0 1 0 1 1 0 1 
	*	0 0 1 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 337
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 0 1 1 1 1 1 
*	1 1 0 1 1 1 1 0 	1 0 1 0 0 1 0 0 
*	0 1 1 1 1 1 0 0 	1 1 0 1 1 1 1 1 
*	0 1 1 1 0 0 0 0 	0 1 1 0 1 0 1 1 
*	1 0 0 0 1 0 1 0 	1 0 1 1 0 1 1 1 
*	0 1 0 0 0 0 1 0 	1 0 0 0 0 1 1 1 
*	0 1 0 0 1 0 1 1 	1 0 1 0 0 0 0 0 
*	0 1 1 1 0 0 1 1 	1 0 1 1 0 0 0 1 
*
* S = BD BC EC B0 A9 5B 30 6F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_337 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[1];
	assign g_in[1] = in[6] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	0 0 1 0 0 1 0 0 
	*	0 1 0 0 1 0 1 0 
	*	0 0 1 1 1 1 1 0 
	*	0 0 1 0 1 1 0 1 
	*	0 1 1 1 0 1 0 1 
	*	1 0 1 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 338
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 1 1 0 1 0 
*	0 1 1 1 1 1 1 0 	0 1 0 1 1 1 0 0 
*	0 0 0 0 1 1 0 0 	1 0 1 1 1 0 1 0 
*	0 1 1 1 1 1 0 0 	1 1 0 1 0 1 1 0 
*	1 1 0 0 1 0 0 0 	0 1 1 0 1 1 1 0 
*	1 0 0 0 1 0 1 0 	0 1 0 0 1 1 1 0 
*	0 0 1 1 1 0 0 0 	0 1 0 1 0 0 0 0 
*	0 1 0 0 1 0 1 1 	0 1 1 0 0 0 1 1 
*
* S = 01 BD 5C EC F2 A9 5F 30
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_338 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[6] ^ in[3];
	assign g_in[2] = in[7] ^ in[3] ^ in[1];
	assign g_in[1] = in[5] ^ in[4] ^ in[3];
	assign g_in[0] = in[6] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	0 0 0 1 1 1 0 0 
	*	1 1 0 0 0 1 0 1 
	*	0 0 1 0 1 0 0 1 
	*	0 0 0 1 1 0 1 1 
	*	1 1 1 0 1 1 1 1 
	*	0 1 1 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 339
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 1 1 0 1 0 
*	1 1 0 1 1 1 1 0 	1 1 1 1 0 1 0 0 
*	0 0 0 0 1 1 0 0 	1 0 0 1 1 0 1 0 
*	0 1 1 1 0 0 0 0 	0 1 1 1 1 1 1 0 
*	1 1 0 0 1 0 0 0 	1 1 1 0 0 1 1 0 
*	0 1 0 0 0 0 1 0 	1 1 0 0 0 1 1 0 
*	0 0 1 1 1 0 0 0 	1 1 1 1 0 0 0 0 
*	0 1 1 1 0 0 1 1 	1 1 1 0 0 0 0 1 
*
* S = 01 BC 5C B0 F2 5B 5F 6F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_339 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[3];
	assign g_in[2] = in[6] ^ in[1];
	assign g_in[1] = in[5] ^ in[4] ^ in[3];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	0 0 1 1 0 1 0 0 
	*	0 1 0 0 1 1 1 1 
	*	0 0 1 0 1 0 1 1 
	*	0 0 1 1 1 0 0 1 
	*	0 1 1 0 0 1 0 1 
	*	1 1 1 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 340
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 0 1 0 0 1 1 
*	1 1 0 1 1 1 1 0 	0 0 1 0 0 1 0 0 
*	0 0 0 0 0 0 1 0 	1 0 0 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 1 1 0 0 1 1 1 
*	1 0 0 0 1 0 1 0 	0 1 1 1 1 0 1 1 
*	0 1 0 0 0 0 1 0 	1 0 0 0 1 0 1 1 
*	1 1 0 0 0 0 0 1 	0 0 1 0 0 0 0 0 
*	0 0 1 1 0 0 0 1 	0 1 1 1 0 1 0 1 
*
* S = BD BC 51 0C A9 5B 99 34
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_340 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[0];
	assign g_in[0] = in[5] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	1 0 1 0 0 1 0 0 
	*	0 1 0 0 0 0 1 0 
	*	1 1 1 1 0 1 1 0 
	*	1 0 1 0 1 0 0 1 
	*	1 0 1 1 0 0 0 1 
	*	0 1 1 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 341
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 1 0 0 1 0 
*	0 1 1 1 1 1 1 0 	0 0 0 1 1 1 0 0 
*	1 0 1 0 1 1 0 0 	0 1 1 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 0 0 1 1 1 1 0 
*	1 1 0 0 1 0 0 0 	1 1 1 0 0 1 1 0 
*	1 0 0 0 1 0 1 0 	0 1 0 0 0 1 1 0 
*	1 1 1 1 0 0 0 0 	0 0 0 1 0 0 0 0 
*	1 1 0 0 0 0 0 1 	1 1 1 0 1 1 1 1 
*
* S = 01 BD 5D 51 F2 A9 AD 99
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_341 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[3];
	assign g_in[2] = in[7] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4];
	assign g_in[0] = in[7] ^ in[6] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	0 1 0 1 1 1 0 0 
	*	1 1 0 0 0 0 0 1 
	*	1 0 1 0 1 1 0 1 
	*	0 1 0 1 0 1 1 1 
	*	0 1 1 0 0 0 1 1 
	*	1 1 1 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 342
*
* GF(2^8) Poly Basis: [L^2, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 1 0 0 1 0 
*	1 1 0 1 1 1 1 0 	0 0 1 1 0 1 0 0 
*	1 0 1 0 1 1 0 0 	1 1 0 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 0 1 1 0 1 1 0 
*	1 1 0 0 1 0 0 0 	0 1 1 0 1 1 1 0 
*	0 1 0 0 0 0 1 0 	1 1 0 0 1 1 1 0 
*	1 1 1 1 0 0 0 0 	0 0 1 1 0 0 0 0 
*	0 0 1 1 0 0 0 1 	0 1 1 0 0 1 0 1 
*
* S = 01 BC 5D 0C F2 5B AD 34
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_342 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[3];
	assign g_in[2] = in[6] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4];
	assign g_in[0] = in[5] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	1 1 1 1 0 1 0 0 
	*	0 1 0 0 0 0 1 1 
	*	1 0 1 0 0 1 1 1 
	*	1 1 1 1 1 1 0 1 
	*	1 1 1 0 0 0 0 1 
	*	0 1 1 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 343
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	1 0 0 0 0 1 1 0 
*	0 0 0 0 1 1 1 0 	1 0 0 0 0 1 0 1 
*	1 0 1 0 0 0 1 0 	0 1 1 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 0 0 1 0 0 1 1 
*	0 1 0 1 1 1 1 1 	1 1 1 1 1 1 0 0 
*	1 1 1 1 0 1 1 1 	0 1 1 0 1 1 0 0 
*	1 0 1 0 1 0 1 1 	1 1 0 1 0 0 0 0 
*	0 1 1 0 1 0 1 1 	1 1 0 1 1 1 1 0 
*
* S = 50 B1 ED 0D 3B 2C 2F CB
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_343 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	0 0 1 0 0 1 0 1 
	*	1 0 0 0 1 1 0 1 
	*	0 0 0 1 1 0 0 0 
	*	0 1 1 0 0 0 0 1 
	*	0 1 1 1 1 0 1 1 
	*	1 0 1 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 344
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 1 0 0 1 1 0 1 
*	1 1 0 1 1 1 0 0 	0 1 0 0 1 1 1 1 
*	0 1 1 1 0 0 1 0 	1 1 1 0 1 1 0 1 
*	1 0 1 0 0 0 1 0 	0 0 1 1 0 0 1 0 
*	1 0 1 0 1 0 0 0 	1 0 1 0 1 0 0 0 
*	0 1 0 1 1 1 1 1 	1 1 0 1 1 0 0 0 
*	1 1 0 0 0 0 0 0 	1 0 1 1 0 0 0 0 
*	1 0 1 0 1 0 1 1 	1 0 1 1 1 0 0 1 
*
* S = E1 50 E0 ED 17 3B E4 2F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_344 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[3];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	0 0 0 1 1 1 1 1 
	*	0 1 0 0 1 0 1 1 
	*	0 0 1 1 0 1 0 0 
	*	1 1 0 1 0 0 1 1 
	*	1 1 1 0 0 1 1 0 
	*	0 1 1 0 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 345
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 1 0 0 0 1 1 1 
*	0 0 0 0 1 1 1 0 	1 1 0 0 0 1 0 1 
*	0 1 1 1 0 0 1 0 	0 1 1 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 0 0 1 0 0 1 0 
*	1 0 1 0 1 0 0 0 	1 0 1 0 1 0 0 0 
*	1 1 1 1 0 1 1 1 	0 1 1 1 1 0 0 0 
*	1 1 0 0 0 0 0 0 	1 0 0 1 0 0 0 0 
*	0 1 1 0 1 0 1 1 	1 0 0 1 1 0 1 1 
*
* S = E1 B1 E0 0D 17 2C E4 CB
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_345 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	0 0 1 1 0 1 0 1 
	*	1 1 0 0 1 0 0 1 
	*	0 0 0 1 1 1 0 0 
	*	0 1 1 1 0 0 0 1 
	*	0 1 1 0 1 1 1 0 
	*	1 1 1 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 346
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	0 1 1 1 0 0 1 1 
*	0 1 1 1 0 0 0 0 	0 1 1 1 0 1 0 1 
*	0 0 0 0 0 0 1 0 	1 0 0 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 0 1 1 0 1 1 0 
*	0 0 1 1 0 1 1 1 	1 1 1 1 1 0 0 1 
*	0 0 0 0 0 0 1 1 	0 0 1 1 1 0 0 1 
*	1 1 0 0 0 0 1 1 	0 0 1 0 0 0 0 0 
*	1 0 0 1 1 1 1 1 	0 0 1 0 0 1 0 0 
*
* S = EC B0 51 0C DC DF C8 38
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_346 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	1 1 0 1 0 1 0 1 
	*	0 1 1 1 0 0 1 0 
	*	1 0 1 1 0 1 1 1 
	*	0 0 1 1 1 0 1 1 
	*	1 0 0 0 0 0 0 1 
	*	0 0 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 347
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 1 1 0 0 0 1 0 
*	0 1 1 1 1 1 0 0 	1 1 1 0 1 1 1 1 
*	1 0 1 0 1 1 0 0 	0 1 0 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 1 1 0 1 1 0 1 
*	0 0 1 1 0 1 0 0 	1 0 1 0 0 1 1 1 
*	0 0 1 1 0 1 1 1 	0 0 1 0 0 1 1 1 
*	0 1 0 1 1 1 0 0 	0 0 0 1 0 0 0 0 
*	1 1 0 0 0 0 1 1 	0 0 0 1 1 1 0 0 
*
* S = 5C EC 5D 51 03 DC F0 C8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_347 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	1 0 1 1 1 1 1 1 
	*	1 1 1 0 0 0 0 1 
	*	0 1 1 0 1 1 1 0 
	*	0 0 1 0 0 1 1 0 
	*	0 1 0 0 0 0 1 1 
	*	0 0 1 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 348
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 1 1 0 0 0 1 0 
*	0 1 1 1 0 0 0 0 	0 1 1 0 0 1 0 1 
*	1 0 1 0 1 1 0 0 	1 1 0 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 1 1 0 0 1 1 1 
*	0 0 1 1 0 1 0 0 	1 0 1 0 1 1 0 1 
*	0 0 0 0 0 0 1 1 	0 0 1 0 1 1 0 1 
*	0 1 0 1 1 1 0 0 	0 0 1 1 0 0 0 0 
*	1 0 0 1 1 1 1 1 	0 0 1 1 0 1 0 0 
*
* S = 5C B0 5D 0C 03 DF F0 38
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_348 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_0_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	1 0 0 1 0 1 0 1 
	*	0 1 1 0 0 0 1 1 
	*	1 1 1 0 0 1 1 0 
	*	0 0 1 0 1 1 1 0 
	*	1 1 0 0 0 0 0 1 
	*	0 0 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 349
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 1 0 1 0 1 1 
*	1 1 0 1 1 1 1 0 	0 0 1 0 0 1 0 0 
*	1 1 0 1 1 1 0 0 	1 1 1 0 1 0 1 1 
*	0 0 0 0 1 1 1 0 	0 1 0 1 1 1 1 1 
*	1 1 1 1 0 1 0 0 	1 1 0 0 0 0 1 1 
*	1 0 0 1 1 1 0 0 	1 0 1 1 0 0 1 1 
*	0 1 0 1 1 1 1 1 	0 1 1 0 0 0 0 0 
*	1 1 1 1 0 1 1 1 	0 1 1 0 1 0 0 1 
*
* S = BD BC 50 B1 14 E7 3B 2C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_349 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	1 0 1 0 0 1 0 0 
	*	0 0 1 0 0 1 1 0 
	*	0 1 0 1 0 0 1 0 
	*	1 0 1 1 0 1 0 1 
	*	1 1 1 0 1 1 0 1 
	*	1 1 0 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 350
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 1 0 1 1 0 
*	0 1 1 1 1 1 1 0 	0 0 0 1 1 1 0 0 
*	1 1 0 1 0 0 1 0 	1 0 0 1 0 1 1 0 
*	1 1 0 1 1 1 0 0 	1 1 1 1 1 0 1 0 
*	0 1 1 0 1 0 0 0 	1 0 0 0 0 0 1 0 
*	1 1 1 1 0 1 0 0 	0 1 1 0 0 0 1 0 
*	1 0 1 0 1 0 0 0 	1 1 0 1 0 0 0 0 
*	0 1 0 1 1 1 1 1 	1 1 0 1 0 1 1 1 
*
* S = 01 BD E1 50 F3 14 17 3B
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_350 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[3];
	assign g_in[0] = in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	0 1 0 1 1 1 0 0 
	*	0 0 0 1 1 1 0 1 
	*	1 1 1 1 0 0 0 1 
	*	0 1 1 0 1 1 1 1 
	*	1 0 0 1 1 0 1 1 
	*	1 0 1 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 351
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 1 1 1 1 0 
*	1 1 0 1 1 1 1 0 	0 0 1 1 0 1 0 0 
*	1 1 0 1 0 0 1 0 	1 0 1 1 1 1 1 0 
*	0 0 0 0 1 1 1 0 	0 1 0 1 1 0 1 0 
*	0 1 1 0 1 0 0 0 	1 0 0 0 0 0 1 0 
*	1 0 0 1 1 1 0 0 	1 1 1 0 0 0 1 0 
*	1 0 1 0 1 0 0 0 	0 1 1 1 0 0 0 0 
*	1 1 1 1 0 1 1 1 	0 1 1 1 1 1 0 1 
*
* S = 01 BC E1 B1 F3 E7 17 2C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_351 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[3];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	1 1 1 1 0 1 0 0 
	*	0 0 1 1 0 1 1 1 
	*	0 1 0 1 0 0 1 1 
	*	1 1 1 0 0 1 0 1 
	*	1 0 1 1 1 0 0 1 
	*	1 0 0 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 352
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 1 0 0 1 1 1 
*	1 1 0 1 1 1 1 0 	1 0 1 0 0 1 0 0 
*	1 0 1 0 0 0 1 0 	0 1 1 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 0 0 1 0 0 1 1 
*	1 1 1 1 0 1 0 0 	1 1 0 0 1 1 1 1 
*	1 0 0 1 1 1 0 0 	0 1 1 1 1 1 1 1 
*	1 0 1 0 1 0 1 1 	1 1 1 0 0 0 0 0 
*	0 1 1 0 1 0 1 1 	1 1 1 0 1 1 0 1 
*
* S = BD BC ED 0D 14 E7 2F CB
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_352 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	0 0 1 0 0 1 0 0 
	*	1 0 1 0 1 1 1 0 
	*	0 0 0 1 1 0 1 0 
	*	0 1 1 1 0 0 0 1 
	*	0 1 1 0 1 0 0 1 
	*	1 0 0 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 353
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 1 1 1 1 0 
*	0 1 1 1 1 1 1 0 	0 1 0 1 1 1 0 0 
*	0 1 1 1 0 0 1 0 	1 1 0 1 1 1 1 0 
*	1 0 1 0 0 0 1 0 	0 0 1 1 0 0 1 0 
*	0 1 1 0 1 0 0 0 	1 0 0 0 1 0 1 0 
*	1 1 1 1 0 1 0 0 	1 1 1 0 1 0 1 0 
*	1 1 0 0 0 0 0 0 	1 0 0 1 0 0 0 0 
*	1 0 1 0 1 0 1 1 	1 0 0 1 1 0 1 1 
*
* S = 01 BD E0 ED F3 14 E4 2F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_353 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[1] = in[7] ^ in[6];
	assign g_in[0] = in[7] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	0 0 0 1 1 1 0 0 
	*	0 1 0 1 1 0 0 1 
	*	0 0 1 1 0 1 0 1 
	*	1 1 1 0 0 0 1 1 
	*	1 1 0 1 0 1 1 1 
	*	0 1 1 1 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 354
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 1 0 1 1 0 
*	1 1 0 1 1 1 1 0 	1 1 1 1 0 1 0 0 
*	0 1 1 1 0 0 1 0 	0 1 1 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 0 0 1 0 0 1 0 
*	0 1 1 0 1 0 0 0 	1 0 0 0 1 0 1 0 
*	1 0 0 1 1 1 0 0 	0 1 1 0 1 0 1 0 
*	1 1 0 0 0 0 0 0 	1 0 1 1 0 0 0 0 
*	0 1 1 0 1 0 1 1 	1 0 1 1 1 0 0 1 
*
* S = 01 BC E0 0D F3 E7 E4 CB
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_354 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6];
	assign g_in[0] = in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	0 0 1 1 0 1 0 0 
	*	1 1 1 1 1 0 1 1 
	*	0 0 0 1 1 1 1 1 
	*	0 1 1 0 0 0 0 1 
	*	0 1 1 1 1 1 0 1 
	*	1 1 0 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 355
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 1 0 1 1 1 1 
*	1 1 0 1 1 1 1 0 	1 1 1 0 0 1 0 0 
*	0 1 1 1 1 1 0 0 	0 0 1 0 1 1 1 1 
*	0 1 1 1 0 0 0 0 	1 1 0 1 1 0 1 1 
*	1 1 1 1 0 1 0 0 	1 1 0 0 0 1 1 1 
*	1 0 0 1 1 1 0 0 	1 1 1 1 0 1 1 1 
*	0 0 1 1 0 1 1 1 	1 0 1 0 0 0 0 0 
*	0 0 0 0 0 0 1 1 	1 0 1 0 0 0 0 1 
*
* S = BD BC EC B0 14 E7 DC DF
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_355 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	0 1 1 0 0 1 0 0 
	*	1 1 1 0 1 0 1 0 
	*	1 1 0 1 1 1 1 0 
	*	1 1 1 1 1 1 0 1 
	*	0 0 1 0 0 1 0 1 
	*	0 1 0 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 356
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 1 1 0 1 0 
*	0 1 1 1 1 1 1 0 	1 0 0 1 1 1 0 0 
*	0 0 0 0 1 1 0 0 	0 0 0 1 1 0 1 0 
*	0 1 1 1 1 1 0 0 	1 0 1 1 0 1 1 0 
*	0 1 1 0 1 0 0 0 	1 0 0 0 1 1 1 0 
*	1 1 1 1 0 1 0 0 	1 0 1 0 1 1 1 0 
*	0 0 1 1 0 1 0 0 	0 1 0 1 0 0 0 0 
*	0 0 1 1 0 1 1 1 	0 1 0 1 0 0 1 1 
*
* S = 01 BD 5C EC F3 14 03 DC
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_356 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[1] = in[5] ^ in[4] ^ in[2];
	assign g_in[0] = in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 1 0 1 1 1 0 0 
	*	1 0 0 1 0 1 0 1 
	*	1 0 1 1 1 0 0 1 
	*	1 0 1 0 1 0 1 1 
	*	0 0 0 1 1 1 1 1 
	*	1 1 1 1 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 357
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 1 1 0 1 0 
*	1 1 0 1 1 1 1 0 	1 0 1 1 0 1 0 0 
*	0 0 0 0 1 1 0 0 	0 0 1 1 1 0 1 0 
*	0 1 1 1 0 0 0 0 	1 0 0 1 1 1 1 0 
*	0 1 1 0 1 0 0 0 	1 0 0 0 0 1 1 0 
*	1 0 0 1 1 1 0 0 	1 0 1 0 0 1 1 0 
*	0 0 1 1 0 1 0 0 	1 1 1 1 0 0 0 0 
*	0 0 0 0 0 0 1 1 	1 1 1 1 0 0 0 1 
*
* S = 01 BC 5C B0 F3 E7 03 DF
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_357 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[5] ^ in[4] ^ in[2];
	assign g_in[0] = in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	0 1 1 1 0 1 0 0 
	*	1 0 1 1 1 1 1 1 
	*	1 0 0 1 1 0 1 1 
	*	1 0 1 0 1 0 0 1 
	*	0 0 1 1 0 1 0 1 
	*	0 1 0 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 358
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 1 0 0 0 1 1 
*	1 1 0 1 1 1 1 0 	0 1 1 0 0 1 0 0 
*	0 0 0 0 0 0 1 0 	1 0 1 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 0 0 1 0 1 1 1 
*	1 1 1 1 0 1 0 0 	1 1 0 0 1 0 1 1 
*	1 0 0 1 1 1 0 0 	0 0 1 1 1 0 1 1 
*	1 1 0 0 0 0 1 1 	0 0 1 0 0 0 0 0 
*	1 0 0 1 1 1 1 1 	0 0 1 0 0 1 0 1 
*
* S = BD BC 51 0C 14 E7 C8 38
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_358 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	1 1 1 0 0 1 0 0 
	*	0 1 1 0 0 0 1 0 
	*	1 0 0 1 0 1 1 0 
	*	0 0 1 1 1 0 0 1 
	*	1 0 1 0 0 0 0 1 
	*	0 0 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 359
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 1 0 0 1 0 
*	0 1 1 1 1 1 1 0 	1 1 0 1 1 1 0 0 
*	1 0 1 0 1 1 0 0 	0 1 0 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 1 1 1 1 1 1 0 
*	0 1 1 0 1 0 0 0 	1 0 0 0 0 1 1 0 
*	1 1 1 1 0 1 0 0 	0 0 1 0 0 1 1 0 
*	0 1 0 1 1 1 0 0 	0 0 0 1 0 0 0 0 
*	1 1 0 0 0 0 1 1 	0 0 0 1 1 1 1 1 
*
* S = 01 BD 5D 51 F3 14 F0 C8
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_359 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	1 0 0 1 1 1 0 0 
	*	1 1 0 1 0 0 0 1 
	*	0 1 1 1 1 1 0 1 
	*	0 0 1 0 0 1 1 1 
	*	0 1 0 1 0 0 1 1 
	*	0 0 1 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 360
*
* GF(2^8) Poly Basis: [L^32, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 1 0 0 1 0 
*	1 1 0 1 1 1 1 0 	0 1 1 1 0 1 0 0 
*	1 0 1 0 1 1 0 0 	1 1 1 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 1 0 1 0 1 1 0 
*	0 1 1 0 1 0 0 0 	1 0 0 0 1 1 1 0 
*	1 0 0 1 1 1 0 0 	0 0 1 0 1 1 1 0 
*	0 1 0 1 1 1 0 0 	0 0 1 1 0 0 0 0 
*	1 0 0 1 1 1 1 1 	0 0 1 1 0 1 0 1 
*
* S = 01 BC 5D 0C F3 E7 F0 38
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_360 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[3];
	assign g_in[2] = in[7] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	1 0 1 1 0 1 0 0 
	*	0 1 1 1 0 0 1 1 
	*	1 1 0 1 0 1 1 1 
	*	0 0 1 0 1 1 0 1 
	*	1 1 1 1 0 0 0 1 
	*	0 0 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 361
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	0 1 1 0 0 1 1 0 
*	0 0 0 0 1 1 1 0 	1 0 1 1 0 1 0 1 
*	1 0 1 0 0 0 1 0 	1 0 0 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 1 0 0 0 0 1 1 
*	0 0 1 0 0 0 0 1 	0 0 0 0 1 1 0 0 
*	0 0 1 0 1 0 0 1 	1 0 0 1 1 1 0 0 
*	0 0 0 0 0 1 0 1 	1 1 0 1 0 0 0 0 
*	1 1 0 0 0 1 1 1 	1 0 0 1 1 1 1 0 
*
* S = 50 B1 ED 0D 67 C0 92 77
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_361 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[5] ^ in[0];
	assign g_in[2] = in[5] ^ in[3] ^ in[0];
	assign g_in[1] = in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 0 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	0 0 0 1 0 1 0 1 
	*	0 0 0 1 1 1 0 1 
	*	1 0 1 1 1 0 0 0 
	*	0 0 0 0 0 0 0 1 
	*	0 0 0 0 1 0 1 1 
	*	0 0 0 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[2] = g_out[0];
	assign out[1] = ~( g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 362
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 1 0 1 1 1 0 1 
*	1 1 0 1 1 1 0 0 	0 1 1 0 1 1 1 1 
*	0 1 1 1 0 0 1 0 	0 1 1 1 1 1 0 1 
*	1 0 1 0 0 0 1 0 	1 0 0 0 0 0 1 0 
*	0 0 0 0 1 0 0 0 	0 0 0 0 1 0 0 0 
*	0 0 1 0 0 0 0 1 	0 1 1 1 1 0 0 0 
*	1 1 0 0 0 0 1 0 	1 0 1 1 0 0 0 0 
*	0 0 0 0 0 1 0 1 	0 1 1 1 1 0 0 1 
*
* S = E1 50 E0 ED A7 67 E5 92
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_362 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[3];
	assign g_in[2] = in[5] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[1];
	assign g_in[0] = in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	0 0 1 1 1 1 1 1 
	*	0 0 1 1 1 0 1 1 
	*	0 1 1 0 0 1 0 0 
	*	0 0 0 0 0 0 1 1 
	*	0 0 0 0 0 1 1 0 
	*	0 0 1 1 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[2];
	assign out[2] = g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 363
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 1 1 1 0 1 1 1 
*	0 0 0 0 1 1 1 0 	1 1 1 0 0 1 0 1 
*	0 1 1 1 0 0 1 0 	1 1 0 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 0 0 0 0 0 1 0 
*	0 0 0 0 1 0 0 0 	0 0 0 0 1 0 0 0 
*	0 0 1 0 1 0 0 1 	1 1 0 1 1 0 0 0 
*	1 1 0 0 0 0 1 0 	1 0 0 1 0 0 0 0 
*	1 1 0 0 0 1 1 1 	1 1 0 1 1 0 1 1 
*
* S = E1 B1 E0 0D A7 C0 E5 77
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_363 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[3];
	assign g_in[2] = in[5] ^ in[3] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	0 0 0 1 0 1 0 1 
	*	0 0 0 1 1 0 0 1 
	*	1 1 1 0 1 1 0 0 
	*	0 0 0 0 0 0 0 1 
	*	0 0 0 0 1 1 1 0 
	*	0 0 0 1 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[0];
	assign out[1] = ~( g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[4] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 364
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	0 0 1 1 0 0 1 1 
*	0 1 1 1 0 0 0 0 	0 0 0 1 0 1 0 1 
*	0 0 0 0 0 0 1 0 	1 1 0 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 0 0 1 0 1 1 0 
*	1 1 1 0 1 0 1 1 	0 0 0 0 1 0 0 1 
*	0 0 0 0 1 1 0 1 	1 1 0 0 1 0 0 1 
*	1 1 0 0 1 1 1 1 	0 0 1 0 0 0 0 0 
*	1 1 1 0 0 0 1 1 	1 1 0 0 0 1 0 0 
*
* S = EC B0 51 0C D0 82 25 35
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_364 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[2] = in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	1 0 1 1 0 1 0 1 
	*	1 0 1 1 0 0 1 0 
	*	0 0 0 1 0 1 1 1 
	*	0 0 0 0 1 0 1 1 
	*	0 0 0 0 0 0 0 1 
	*	1 0 1 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 365
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 0 1 0 0 0 1 0 
*	0 1 1 1 1 1 0 0 	0 0 1 1 1 1 1 1 
*	1 0 1 0 1 1 0 0 	1 0 0 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 1 1 1 1 1 0 1 
*	1 1 1 0 0 1 1 0 	0 0 0 0 0 1 1 1 
*	1 1 1 0 1 0 1 1 	1 0 0 0 0 1 1 1 
*	0 0 1 0 1 1 0 0 	0 0 0 1 0 0 0 0 
*	1 1 0 0 1 1 1 1 	1 0 0 0 1 1 0 0 
*
* S = 5C EC 5D 51 52 D0 10 25
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_365 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	0 1 1 0 1 1 1 1 
	*	0 1 1 0 0 0 0 1 
	*	0 0 1 1 1 1 1 0 
	*	0 0 0 0 0 1 1 0 
	*	0 0 0 0 0 0 1 1 
	*	0 1 1 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 366
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 0 1 0 0 0 1 0 
*	0 1 1 1 0 0 0 0 	0 0 0 1 0 1 0 1 
*	1 0 1 0 1 1 0 0 	1 0 0 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 1 0 1 0 1 1 1 
*	1 1 1 0 0 1 1 0 	0 0 0 0 1 1 0 1 
*	0 0 0 0 1 1 0 1 	1 0 0 0 1 1 0 1 
*	0 0 1 0 1 1 0 0 	0 0 1 1 0 0 0 0 
*	1 1 1 0 0 0 1 1 	1 0 0 0 0 1 0 0 
*
* S = 5C B0 5D 0C 52 82 10 35
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_366 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[2] = in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	1 1 1 0 0 1 0 1 
	*	1 1 1 0 0 0 1 1 
	*	0 0 0 1 0 1 1 0 
	*	0 0 0 0 1 1 1 0 
	*	0 0 0 0 0 0 0 1 
	*	1 1 1 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 367
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 1 1 1 0 1 1 
*	1 1 0 1 1 1 1 0 	1 1 0 1 0 1 0 0 
*	1 1 0 1 1 1 0 0 	0 1 1 1 1 0 1 1 
*	0 0 0 0 1 1 1 0 	0 0 1 1 1 1 1 1 
*	0 0 1 0 0 1 0 0 	0 0 0 0 0 0 1 1 
*	1 1 1 0 1 1 1 0 	0 1 1 1 0 0 1 1 
*	0 0 1 0 0 0 0 1 	0 1 1 0 0 0 0 0 
*	0 0 1 0 1 0 0 1 	0 1 1 1 1 0 0 1 
*
* S = BD BC 50 B1 F5 B7 67 C0
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_367 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[5] ^ in[0];
	assign g_in[0] = in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	0 1 0 1 0 1 0 0 
	*	0 1 0 1 0 1 1 0 
	*	1 1 0 1 0 0 1 0 
	*	0 0 0 0 0 1 0 1 
	*	0 0 0 0 1 1 0 1 
	*	0 1 0 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 368
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 0 0 1 1 0 
*	0 1 1 1 1 1 1 0 	1 0 1 1 1 1 0 0 
*	1 1 0 1 0 0 1 0 	1 1 1 0 0 1 1 0 
*	1 1 0 1 1 1 0 0 	0 0 1 0 1 0 1 0 
*	1 1 0 0 1 0 1 0 	0 0 0 0 0 0 1 0 
*	0 0 1 0 0 1 0 0 	1 1 1 0 0 0 1 0 
*	0 0 0 0 1 0 0 0 	1 1 0 1 0 0 0 0 
*	0 0 1 0 0 0 0 1 	1 1 1 0 0 1 1 1 
*
* S = 01 BD E1 50 42 F5 A7 67
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_368 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[2];
	assign g_in[1] = in[3];
	assign g_in[0] = in[5] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	1 1 1 1 1 1 0 0 
	*	1 1 1 1 1 1 0 1 
	*	1 0 1 1 0 0 0 1 
	*	0 0 0 0 1 1 1 1 
	*	0 0 0 0 1 0 1 1 
	*	1 1 1 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[2] = g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 369
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 0 1 1 1 0 
*	1 1 0 1 1 1 1 0 	1 0 0 1 0 1 0 0 
*	1 1 0 1 0 0 1 0 	0 1 1 0 1 1 1 0 
*	0 0 0 0 1 1 1 0 	0 0 1 0 1 0 1 0 
*	1 1 0 0 1 0 1 0 	0 0 0 0 0 0 1 0 
*	1 1 1 0 1 1 1 0 	0 1 1 0 0 0 1 0 
*	0 0 0 0 1 0 0 0 	0 1 1 1 0 0 0 0 
*	0 0 1 0 1 0 0 1 	0 1 1 0 1 1 0 1 
*
* S = 01 BC E1 B1 42 B7 A7 C0
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_369 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[3];
	assign g_in[0] = in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	0 1 0 1 0 1 0 0 
	*	0 1 0 1 0 1 1 1 
	*	1 0 0 1 0 0 1 1 
	*	0 0 0 0 0 1 0 1 
	*	0 0 0 0 1 0 0 1 
	*	0 1 0 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 370
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 1 1 0 1 1 1 
*	1 1 0 1 1 1 1 0 	1 0 0 1 0 1 0 0 
*	1 0 1 0 0 0 1 0 	1 0 1 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 1 1 1 0 0 1 1 
*	0 0 1 0 0 1 0 0 	0 0 0 0 1 1 1 1 
*	1 1 1 0 1 1 1 0 	1 0 1 1 1 1 1 1 
*	0 0 0 0 0 1 0 1 	1 1 1 0 0 0 0 0 
*	1 1 0 0 0 1 1 1 	1 0 1 1 1 1 0 1 
*
* S = BD BC ED 0D F5 B7 92 77
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_370 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	0 0 0 1 0 1 0 0 
	*	0 0 0 1 1 1 1 0 
	*	1 0 0 1 1 0 1 0 
	*	0 0 0 0 0 0 0 1 
	*	0 0 0 0 1 0 0 1 
	*	0 0 0 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[4] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[0];
	assign out[1] = ~( g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 371
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 0 1 1 1 0 
*	0 1 1 1 1 1 1 0 	0 1 1 1 1 1 0 0 
*	0 1 1 1 0 0 1 0 	0 1 1 0 1 1 1 0 
*	1 0 1 0 0 0 1 0 	1 0 1 0 0 0 1 0 
*	1 1 0 0 1 0 1 0 	0 0 0 0 1 0 1 0 
*	0 0 1 0 0 1 0 0 	0 1 1 0 1 0 1 0 
*	1 1 0 0 0 0 1 0 	1 0 0 1 0 0 0 0 
*	0 0 0 0 0 1 0 1 	0 1 1 0 1 0 1 1 
*
* S = 01 BD E0 ED 42 F5 E5 92
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_371 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[1];
	assign g_in[0] = in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	0 0 1 1 1 1 0 0 
	*	0 0 1 1 1 0 0 1 
	*	0 1 1 1 0 1 0 1 
	*	0 0 0 0 0 0 1 1 
	*	0 0 0 0 0 1 1 1 
	*	0 0 1 1 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 372
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 0 0 1 1 0 
*	1 1 0 1 1 1 1 0 	1 1 0 1 0 1 0 0 
*	0 1 1 1 0 0 1 0 	1 1 1 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 0 1 0 0 0 1 0 
*	1 1 0 0 1 0 1 0 	0 0 0 0 1 0 1 0 
*	1 1 1 0 1 1 1 0 	1 1 1 0 1 0 1 0 
*	1 1 0 0 0 0 1 0 	1 0 1 1 0 0 0 0 
*	1 1 0 0 0 1 1 1 	1 1 1 0 1 0 0 1 
*
* S = 01 BC E0 0D 42 B7 E5 77
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_372 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	0 0 0 1 0 1 0 0 
	*	0 0 0 1 1 0 1 1 
	*	1 1 0 1 1 1 1 1 
	*	0 0 0 0 0 0 0 1 
	*	0 0 0 0 1 1 0 1 
	*	0 0 0 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[4] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[0];
	assign out[1] = ~( g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 373
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 1 1 1 1 1 1 
*	1 1 0 1 1 1 1 0 	0 1 0 1 0 1 0 0 
*	0 1 1 1 1 1 0 0 	0 0 1 1 1 1 1 1 
*	0 1 1 1 0 0 0 0 	0 1 1 1 1 0 1 1 
*	0 0 1 0 0 1 0 0 	0 0 0 0 0 1 1 1 
*	1 1 1 0 1 1 1 0 	0 0 1 1 0 1 1 1 
*	1 1 1 0 1 0 1 1 	1 0 1 0 0 0 0 0 
*	0 0 0 0 1 1 0 1 	0 0 1 1 0 0 0 1 
*
* S = BD BC EC B0 F5 B7 D0 82
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_373 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	1 1 0 1 0 1 0 0 
	*	1 1 0 1 1 0 1 0 
	*	0 1 0 1 1 1 1 0 
	*	0 0 0 0 1 1 0 1 
	*	0 0 0 0 0 1 0 1 
	*	1 1 0 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 374
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 0 1 0 1 0 
*	0 1 1 1 1 1 1 0 	1 1 1 1 1 1 0 0 
*	0 0 0 0 1 1 0 0 	0 0 1 0 1 0 1 0 
*	0 1 1 1 1 1 0 0 	1 1 1 0 0 1 1 0 
*	1 1 0 0 1 0 1 0 	0 0 0 0 1 1 1 0 
*	0 0 1 0 0 1 0 0 	0 0 1 0 1 1 1 0 
*	1 1 1 0 0 1 1 0 	0 1 0 1 0 0 0 0 
*	1 1 1 0 1 0 1 1 	0 0 1 0 0 0 1 1 
*
* S = 01 BD 5C EC 42 F5 52 D0
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_374 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 0 1 1 1 1 0 0 
	*	1 0 1 1 0 1 0 1 
	*	1 1 1 1 1 0 0 1 
	*	0 0 0 0 1 0 1 1 
	*	0 0 0 0 1 1 1 1 
	*	1 0 1 1 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 375
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 0 1 0 1 0 
*	1 1 0 1 1 1 1 0 	0 1 0 1 0 1 0 0 
*	0 0 0 0 1 1 0 0 	0 0 1 0 1 0 1 0 
*	0 1 1 1 0 0 0 0 	0 1 1 0 1 1 1 0 
*	1 1 0 0 1 0 1 0 	0 0 0 0 0 1 1 0 
*	1 1 1 0 1 1 1 0 	0 0 1 0 0 1 1 0 
*	1 1 1 0 0 1 1 0 	1 1 1 1 0 0 0 0 
*	0 0 0 0 1 1 0 1 	0 0 1 0 0 0 0 1 
*
* S = 01 BC 5C B0 42 B7 52 82
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_375 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[2] ^ in[1];
	assign g_in[0] = in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	1 0 0 1 0 1 0 0 
	*	1 0 0 1 1 1 1 1 
	*	0 1 0 1 1 0 1 1 
	*	0 0 0 0 1 0 0 1 
	*	0 0 0 0 0 1 0 1 
	*	1 0 0 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 376
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 1 1 0 0 1 1 
*	1 1 0 1 1 1 1 0 	0 0 0 1 0 1 0 0 
*	0 0 0 0 0 0 1 0 	1 1 1 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 0 1 1 0 1 1 1 
*	0 0 1 0 0 1 0 0 	0 0 0 0 1 0 1 1 
*	1 1 1 0 1 1 1 0 	1 1 1 1 1 0 1 1 
*	1 1 0 0 1 1 1 1 	0 0 1 0 0 0 0 0 
*	1 1 1 0 0 0 1 1 	1 1 1 1 0 1 0 1 
*
* S = BD BC 51 0C F5 B7 25 35
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_376 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	1 0 0 1 0 1 0 0 
	*	1 0 0 1 0 0 1 0 
	*	0 0 0 1 0 1 1 0 
	*	0 0 0 0 1 0 0 1 
	*	0 0 0 0 0 0 0 1 
	*	1 0 0 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 377
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 0 0 0 1 0 
*	0 1 1 1 1 1 1 0 	0 0 1 1 1 1 0 0 
*	1 0 1 0 1 1 0 0 	1 0 1 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 1 1 0 1 1 1 0 
*	1 1 0 0 1 0 1 0 	0 0 0 0 0 1 1 0 
*	0 0 1 0 0 1 0 0 	1 0 1 0 0 1 1 0 
*	0 0 1 0 1 1 0 0 	0 0 0 1 0 0 0 0 
*	1 1 0 0 1 1 1 1 	1 0 1 0 1 1 1 1 
*
* S = 01 BD 5D 51 42 F5 10 25
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_377 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[2];
	assign g_in[1] = in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	0 1 1 1 1 1 0 0 
	*	0 1 1 1 0 0 0 1 
	*	0 0 1 1 1 1 0 1 
	*	0 0 0 0 0 1 1 1 
	*	0 0 0 0 0 0 1 1 
	*	0 1 1 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 378
*
* GF(2^8) Poly Basis: [L^4, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 0 0 0 1 0 
*	1 1 0 1 1 1 1 0 	0 0 0 1 0 1 0 0 
*	1 0 1 0 1 1 0 0 	1 0 1 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 1 1 0 0 1 1 0 
*	1 1 0 0 1 0 1 0 	0 0 0 0 1 1 1 0 
*	1 1 1 0 1 1 1 0 	1 0 1 0 1 1 1 0 
*	0 0 1 0 1 1 0 0 	0 0 1 1 0 0 0 0 
*	1 1 1 0 0 0 1 1 	1 0 1 0 0 1 0 1 
*
* S = 01 BC 5D 0C 42 B7 10 35
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_378 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[1] = in[5] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	1 1 0 1 0 1 0 0 
	*	1 1 0 1 0 0 1 1 
	*	0 0 0 1 0 1 1 1 
	*	0 0 0 0 1 1 0 1 
	*	0 0 0 0 0 0 0 1 
	*	1 1 0 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 379
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	0 0 0 0 0 1 1 0 
*	0 0 0 0 1 1 1 0 	1 1 1 0 0 1 0 1 
*	1 0 1 0 0 0 1 0 	1 1 1 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 1 1 1 0 0 1 1 
*	1 1 1 1 1 1 0 1 	1 1 0 0 1 1 0 0 
*	0 0 1 0 0 1 1 1 	0 1 0 1 1 1 0 0 
*	1 0 1 0 0 1 1 1 	1 1 0 1 0 0 0 0 
*	0 0 0 1 0 1 1 1 	0 1 1 1 1 1 1 0 
*
* S = 50 B1 ED 0D 37 71 7F 7A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_379 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[2] = in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	0 1 0 0 0 1 0 1 
	*	1 1 0 0 1 1 0 1 
	*	0 0 1 1 1 0 0 0 
	*	0 0 0 1 0 0 0 1 
	*	1 0 1 1 1 0 1 1 
	*	1 0 0 1 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3];
	assign out[2] = g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 380
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 0 0 0 1 1 0 1 
*	1 1 0 1 1 1 0 0 	1 0 0 1 1 1 1 1 
*	0 1 1 1 0 0 1 0 	1 0 1 0 1 1 0 1 
*	1 0 1 0 0 0 1 0 	1 0 1 0 0 0 1 0 
*	1 1 0 1 1 0 1 0 	1 0 0 0 1 0 0 0 
*	1 1 1 1 1 1 0 1 	1 1 1 1 1 0 0 0 
*	1 0 1 1 0 0 0 0 	1 0 1 1 0 0 0 0 
*	1 0 1 0 0 1 1 1 	1 1 1 0 1 0 0 1 
*
* S = E1 50 E0 ED 46 37 05 7F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_380 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4];
	assign g_in[0] = in[7] ^ in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	1 1 0 0 1 1 1 1 
	*	1 0 0 0 1 0 1 1 
	*	0 0 1 0 0 1 0 0 
	*	0 0 1 1 0 0 1 1 
	*	0 1 1 0 0 1 1 0 
	*	0 1 1 1 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[2];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 381
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 0 0 0 0 1 1 1 
*	0 0 0 0 1 1 1 0 	1 0 1 1 0 1 0 1 
*	0 1 1 1 0 0 1 0 	1 0 1 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 0 1 0 0 0 1 0 
*	1 1 0 1 1 0 1 0 	1 0 0 0 1 0 0 0 
*	0 0 1 0 0 1 1 1 	0 1 0 1 1 0 0 0 
*	1 0 1 1 0 0 0 0 	1 0 0 1 0 0 0 0 
*	0 0 0 1 0 1 1 1 	0 1 1 0 1 0 1 1 
*
* S = E1 B1 E0 0D 46 71 05 7A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_381 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4];
	assign g_in[0] = in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	0 1 0 0 0 1 0 1 
	*	1 0 0 0 1 0 0 1 
	*	0 0 1 0 1 1 0 0 
	*	0 0 0 1 0 0 0 1 
	*	1 1 1 0 1 1 1 0 
	*	1 1 0 1 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 382
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	0 0 0 0 0 0 1 1 
*	0 1 1 1 0 0 0 0 	0 1 0 0 0 1 0 1 
*	0 0 0 0 0 0 1 0 	1 1 1 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 1 1 1 0 1 1 0 
*	1 0 0 1 0 1 1 1 	1 0 0 1 1 0 0 1 
*	0 1 1 1 1 1 0 1 	0 1 0 1 1 0 0 1 
*	1 1 0 0 1 1 0 1 	0 0 1 0 0 0 0 0 
*	0 1 0 0 1 1 0 1 	1 0 0 0 0 1 0 0 
*
* S = EC B0 51 0C 3C 32 74 39
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_382 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	1 1 1 0 0 1 0 1 
	*	1 0 0 1 0 0 1 0 
	*	0 1 1 0 0 1 1 1 
	*	1 0 1 1 1 0 1 1 
	*	0 0 0 1 0 0 0 1 
	*	1 1 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 383
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 0 0 0 0 0 1 0 
*	0 1 1 1 1 1 0 0 	1 1 0 0 1 1 1 1 
*	1 0 1 0 1 1 0 0 	1 0 1 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 0 1 0 1 1 0 1 
*	1 1 1 0 1 0 1 0 	0 1 1 1 0 1 1 1 
*	1 0 0 1 0 1 1 1 	1 1 1 1 0 1 1 1 
*	1 0 0 0 0 0 0 0 	0 0 0 1 0 0 0 0 
*	1 1 0 0 1 1 0 1 	0 1 0 0 1 1 0 0 
*
* S = 5C EC 5D 51 0E 3C 4D 74
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_383 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[1] = in[7];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	1 0 0 1 1 1 1 1 
	*	0 1 1 1 0 0 0 1 
	*	1 1 0 1 1 1 1 0 
	*	0 1 1 0 0 1 1 0 
	*	0 0 1 1 0 0 1 1 
	*	1 0 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 384
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	0 0 0 0 0 0 1 0 
*	0 1 1 1 0 0 0 0 	0 1 0 0 0 1 0 1 
*	1 0 1 0 1 1 0 0 	1 0 1 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 0 1 0 0 1 1 1 
*	1 1 1 0 1 0 1 0 	1 1 0 1 1 1 0 1 
*	0 1 1 1 1 1 0 1 	0 1 0 1 1 1 0 1 
*	1 0 0 0 0 0 0 0 	0 0 1 1 0 0 0 0 
*	0 1 0 0 1 1 0 1 	1 1 0 0 0 1 0 0 
*
* S = 5C B0 5D 0C 0E 32 4D 39
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_384 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[7];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_1_N_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	1 0 1 1 0 1 0 1 
	*	1 1 0 1 0 0 1 1 
	*	0 1 1 1 0 1 1 0 
	*	1 1 1 0 1 1 1 0 
	*	0 0 0 1 0 0 0 1 
	*	1 0 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 385
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 0 0 1 0 1 1 
*	1 1 0 1 1 1 1 0 	1 0 0 1 0 1 0 0 
*	1 1 0 1 1 1 0 0 	1 1 0 0 1 0 1 1 
*	0 0 0 0 1 1 1 0 	1 1 0 0 1 1 1 1 
*	0 1 0 1 1 0 1 0 	0 0 1 1 0 0 1 1 
*	0 0 1 1 0 0 0 0 	0 1 0 0 0 0 1 1 
*	1 1 1 1 1 1 0 1 	0 1 1 0 0 0 0 0 
*	0 0 1 0 0 1 1 1 	1 1 1 0 1 0 0 1 
*
* S = BD BC 50 B1 48 0B 37 71
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_385 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 0 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	0 0 0 1 0 1 0 0 
	*	0 0 1 1 0 1 1 0 
	*	1 1 1 1 0 0 1 0 
	*	0 1 0 1 0 1 0 1 
	*	1 1 0 1 1 1 0 1 
	*	0 1 1 1 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[4] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 386
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 0 0 1 1 0 
*	0 1 1 1 1 1 1 0 	0 1 1 1 1 1 0 0 
*	1 1 0 1 0 0 1 0 	1 0 0 0 0 1 1 0 
*	1 1 0 1 1 1 0 0 	1 0 0 0 1 0 1 0 
*	0 1 1 0 1 0 1 0 	0 0 1 0 0 0 1 0 
*	0 1 0 1 1 0 1 0 	1 1 0 0 0 0 1 0 
*	1 1 0 1 1 0 1 0 	1 1 0 1 0 0 0 0 
*	1 1 1 1 1 1 0 1 	1 0 0 1 0 1 1 1 
*
* S = 01 BD E1 50 43 48 46 37
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_386 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	0 0 1 1 1 1 0 0 
	*	0 0 1 0 1 1 0 1 
	*	1 0 1 0 0 0 0 1 
	*	1 1 1 1 1 1 1 1 
	*	1 0 1 1 1 0 1 1 
	*	1 1 1 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 387
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 0 1 1 1 0 
*	1 1 0 1 1 1 1 0 	1 1 0 1 0 1 0 0 
*	1 1 0 1 0 0 1 0 	1 0 0 0 1 1 1 0 
*	0 0 0 0 1 1 1 0 	1 0 0 0 1 0 1 0 
*	0 1 1 0 1 0 1 0 	0 0 1 0 0 0 1 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 0 0 1 0 
*	1 1 0 1 1 0 1 0 	0 1 1 1 0 0 0 0 
*	0 0 1 0 0 1 1 1 	1 0 1 1 1 1 0 1 
*
* S = 01 BC E1 B1 43 0B 46 71
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_387 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[0] = in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	0 0 0 1 0 1 0 0 
	*	0 0 1 0 0 1 1 1 
	*	1 0 1 0 0 0 1 1 
	*	0 1 0 1 0 1 0 1 
	*	1 0 0 1 1 0 0 1 
	*	0 1 1 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[4] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 388
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 0 0 0 1 1 1 
*	1 1 0 1 1 1 1 0 	1 1 0 1 0 1 0 0 
*	1 0 1 0 0 0 1 0 	1 1 0 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	1 1 0 0 0 0 1 1 
*	0 1 0 1 1 0 1 0 	1 1 1 1 1 1 1 1 
*	0 0 1 1 0 0 0 0 	0 1 0 0 1 1 1 1 
*	1 0 1 0 0 1 1 1 	1 1 1 0 0 0 0 0 
*	0 0 0 1 0 1 1 1 	0 1 1 0 1 1 0 1 
*
* S = BD BC ED 0D 48 0B 7F 7A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_388 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[5] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 0 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	0 1 0 1 0 1 0 0 
	*	1 1 1 1 1 1 1 0 
	*	0 0 1 1 1 0 1 0 
	*	0 0 0 1 0 0 0 1 
	*	1 0 0 1 1 0 0 1 
	*	1 0 1 1 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 389
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 0 1 1 1 0 
*	0 1 1 1 1 1 1 0 	1 0 1 1 1 1 0 0 
*	0 1 1 1 0 0 1 0 	1 0 0 0 1 1 1 0 
*	1 0 1 0 0 0 1 0 	1 0 0 0 0 0 1 0 
*	0 1 1 0 1 0 1 0 	1 0 1 0 1 0 1 0 
*	0 1 0 1 1 0 1 0 	1 1 0 0 1 0 1 0 
*	1 0 1 1 0 0 0 0 	1 0 0 1 0 0 0 0 
*	1 0 1 0 0 1 1 1 	1 1 0 1 1 0 1 1 
*
* S = 01 BD E0 ED 43 48 05 7F
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_389 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[4];
	assign g_in[0] = in[7] ^ in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	1 1 1 1 1 1 0 0 
	*	1 0 1 0 1 0 0 1 
	*	0 0 1 0 0 1 0 1 
	*	0 0 1 1 0 0 1 1 
	*	0 1 1 1 0 1 1 1 
	*	0 1 1 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 390
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 0 0 1 1 0 
*	1 1 0 1 1 1 1 0 	1 0 0 1 0 1 0 0 
*	0 1 1 1 0 0 1 0 	1 0 0 0 0 1 1 0 
*	1 1 0 1 0 0 0 0 	1 0 0 0 0 0 1 0 
*	0 1 1 0 1 0 1 0 	1 0 1 0 1 0 1 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 1 0 1 0 
*	1 0 1 1 0 0 0 0 	1 0 1 1 0 0 0 0 
*	0 0 0 1 0 1 1 1 	0 1 1 1 1 0 0 1 
*
* S = 01 BC E0 0D 43 0B 05 7A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_390 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[5] ^ in[4];
	assign g_in[0] = in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	0 1 0 1 0 1 0 0 
	*	1 0 1 0 1 0 1 1 
	*	0 0 1 0 1 1 1 1 
	*	0 0 0 1 0 0 0 1 
	*	1 1 0 1 1 1 0 1 
	*	1 1 1 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 391
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 0 0 1 1 1 1 
*	1 1 0 1 1 1 1 0 	0 0 0 1 0 1 0 0 
*	0 1 1 1 1 1 0 0 	1 1 0 0 1 1 1 1 
*	0 1 1 1 0 0 0 0 	1 1 0 0 1 0 1 1 
*	0 1 0 1 1 0 1 0 	0 1 1 1 0 1 1 1 
*	0 0 1 1 0 0 0 0 	0 1 0 0 0 1 1 1 
*	1 0 0 1 0 1 1 1 	1 0 1 0 0 0 0 0 
*	0 1 1 1 1 1 0 1 	0 0 1 0 0 0 0 1 
*
* S = BD BC EC B0 48 0B 3C 32
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_391 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[4] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 0 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	1 0 0 1 0 1 0 0 
	*	0 1 1 1 1 0 1 0 
	*	1 0 1 1 1 1 1 0 
	*	1 1 0 1 1 1 0 1 
	*	0 1 0 1 0 1 0 1 
	*	0 0 1 1 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 392
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 0 1 0 1 0 
*	0 1 1 1 1 1 1 0 	0 0 1 1 1 1 0 0 
*	0 0 0 0 1 1 0 0 	1 0 0 0 1 0 1 0 
*	0 1 1 1 1 1 0 0 	1 0 0 0 0 1 1 0 
*	0 1 1 0 1 0 1 0 	1 1 1 0 1 1 1 0 
*	0 1 0 1 1 0 1 0 	1 1 0 0 1 1 1 0 
*	1 1 1 0 1 0 1 0 	0 1 0 1 0 0 0 0 
*	1 0 0 1 0 1 1 1 	0 0 0 1 0 0 1 1 
*
* S = 01 BD 5C EC 43 48 0E 3C
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_392 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	0 1 1 1 1 1 0 0 
	*	1 1 1 0 0 1 0 1 
	*	0 1 1 0 1 0 0 1 
	*	1 0 1 1 1 0 1 1 
	*	1 1 1 1 1 1 1 1 
	*	0 0 1 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 393
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 0 1 0 1 0 
*	1 1 0 1 1 1 1 0 	0 0 0 1 0 1 0 0 
*	0 0 0 0 1 1 0 0 	1 0 0 0 1 0 1 0 
*	0 1 1 1 0 0 0 0 	1 0 0 0 1 1 1 0 
*	0 1 1 0 1 0 1 0 	0 1 1 0 0 1 1 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 0 1 1 0 
*	1 1 1 0 1 0 1 0 	1 1 1 1 0 0 0 0 
*	0 1 1 1 1 1 0 1 	0 0 1 1 0 0 0 1 
*
* S = 01 BC 5C B0 43 0B 0E 32
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_393 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	1 1 0 1 0 1 0 0 
	*	0 1 1 0 1 1 1 1 
	*	1 1 1 0 1 0 1 1 
	*	1 0 0 1 1 0 0 1 
	*	0 1 0 1 0 1 0 1 
	*	0 0 1 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 394
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 0 0 0 0 1 1 
*	1 1 0 1 1 1 1 0 	0 1 0 1 0 1 0 0 
*	0 0 0 0 0 0 1 0 	1 1 0 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	1 1 0 0 0 1 1 1 
*	0 1 0 1 1 0 1 0 	1 0 1 1 1 0 1 1 
*	0 0 1 1 0 0 0 0 	0 1 0 0 1 0 1 1 
*	1 1 0 0 1 1 0 1 	0 0 1 0 0 0 0 0 
*	0 1 0 0 1 1 0 1 	1 0 1 0 0 1 0 1 
*
* S = BD BC 51 0C 48 0B 74 39
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_394 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	1 1 0 1 0 1 0 0 
	*	1 0 1 1 0 0 1 0 
	*	0 1 1 1 0 1 1 0 
	*	1 0 0 1 1 0 0 1 
	*	0 0 0 1 0 0 0 1 
	*	1 1 1 1 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 395
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 0 0 0 1 0 
*	0 1 1 1 1 1 1 0 	1 1 1 1 1 1 0 0 
*	1 0 1 0 1 1 0 0 	1 0 0 0 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 0 0 0 1 1 1 0 
*	0 1 1 0 1 0 1 0 	0 1 1 0 0 1 1 0 
*	0 1 0 1 1 0 1 0 	1 1 0 0 0 1 1 0 
*	1 0 0 0 0 0 0 0 	0 0 0 1 0 0 0 0 
*	1 1 0 0 1 1 0 1 	0 1 0 1 1 1 1 1 
*
* S = 01 BD 5D 51 43 48 4D 74
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_395 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[1];
	assign g_in[1] = in[7];
	assign g_in[0] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	1 0 1 1 1 1 0 0 
	*	0 1 1 0 0 0 0 1 
	*	1 1 1 0 1 1 0 1 
	*	0 1 1 1 0 1 1 1 
	*	0 0 1 1 0 0 1 1 
	*	1 0 1 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 396
*
* GF(2^8) Poly Basis: [L^64, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 0 0 0 1 0 
*	1 1 0 1 1 1 1 0 	0 1 0 1 0 1 0 0 
*	1 0 1 0 1 1 0 0 	1 0 0 0 0 0 1 0 
*	1 0 1 0 1 1 1 0 	1 0 0 0 0 1 1 0 
*	0 1 1 0 1 0 1 0 	1 1 1 0 1 1 1 0 
*	0 0 1 1 0 0 0 0 	0 1 0 0 1 1 1 0 
*	1 0 0 0 0 0 0 0 	0 0 1 1 0 0 0 0 
*	0 1 0 0 1 1 0 1 	1 1 1 1 0 1 0 1 
*
* S = 01 BC 5D 0C 43 0B 4D 39
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_396 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[5] ^ in[4];
	assign g_in[1] = in[7];
	assign g_in[0] = in[6] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	1 0 0 1 0 1 0 0 
	*	1 1 1 0 0 0 1 1 
	*	0 1 1 0 0 1 1 1 
	*	1 1 0 1 1 1 0 1 
	*	0 0 0 1 0 0 0 1 
	*	1 0 1 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 397
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	0 1 0 0 0 1 1 0 
*	0 0 0 0 1 1 1 0 	0 0 1 1 0 1 0 1 
*	1 0 1 0 0 0 1 0 	1 0 1 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 1 1 0 0 0 1 1 
*	0 0 1 0 1 1 0 1 	1 1 1 0 1 1 0 0 
*	0 1 0 1 0 1 0 1 	0 1 1 1 1 1 0 0 
*	1 1 0 1 1 0 1 1 	1 1 0 1 0 0 0 0 
*	0 1 1 0 0 1 1 1 	0 0 1 0 1 1 1 0 
*
* S = 50 B1 ED 0D 66 7D 9E 2A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_397 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	1 0 0 1 0 1 0 1 
	*	0 0 0 0 1 1 0 1 
	*	0 0 1 0 1 0 0 0 
	*	1 1 1 1 0 0 0 1 
	*	0 0 1 1 1 0 1 1 
	*	1 0 0 0 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[3];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[3] );

endmodule





/*****************************************************
* S-Box # 398
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	1 1 0 0 1 1 0 1 
*	1 1 0 1 1 1 0 0 	0 0 1 0 1 1 1 1 
*	0 1 1 1 0 0 1 0 	0 1 1 0 1 1 0 1 
*	1 0 1 0 0 0 1 0 	1 1 0 1 0 0 1 0 
*	0 1 1 1 1 0 0 0 	1 0 0 1 1 0 0 0 
*	0 0 1 0 1 1 0 1 	1 1 1 0 1 0 0 0 
*	1 0 1 1 1 1 0 0 	1 0 1 1 0 0 0 0 
*	1 1 0 1 1 0 1 1 	0 0 0 1 1 0 0 1 
*
* S = E1 50 E0 ED 1B 66 B4 9E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_398 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	0 1 1 1 1 1 1 1 
	*	0 0 0 0 1 0 1 1 
	*	0 0 0 1 0 1 0 0 
	*	1 0 1 0 0 0 1 1 
	*	0 0 1 0 0 1 1 0 
	*	0 1 0 0 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[6] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 399
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 1 0 0 0 1 1 1 
*	0 0 0 0 1 1 1 0 	0 0 1 0 0 1 0 1 
*	0 1 1 1 0 0 1 0 	1 1 1 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 1 1 1 0 0 1 0 
*	0 1 1 1 1 0 0 0 	1 0 1 1 1 0 0 0 
*	0 1 0 1 0 1 0 1 	0 1 1 0 1 0 0 0 
*	1 0 1 1 1 1 0 0 	1 0 0 1 0 0 0 0 
*	0 1 1 0 0 1 1 1 	0 0 1 1 1 0 1 1 
*
* S = E1 B1 E0 0D 1B 7D B4 2A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_399 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[2] = in[6] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	1 1 0 1 0 1 0 1 
	*	0 0 0 0 1 0 0 1 
	*	0 0 1 1 1 1 0 0 
	*	1 0 1 0 0 0 0 1 
	*	0 0 1 0 1 1 1 0 
	*	1 1 0 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[3] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 400
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	1 1 1 0 0 0 1 1 
*	0 1 1 1 0 0 0 0 	0 1 1 0 0 1 0 1 
*	0 0 0 0 0 0 1 0 	0 0 0 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 0 1 1 0 1 1 0 
*	1 1 1 0 1 0 0 1 	0 1 0 0 1 0 0 1 
*	1 0 1 0 0 0 1 1 	1 0 0 0 1 0 0 1 
*	0 0 0 1 1 1 1 1 	0 0 1 0 0 0 0 0 
*	1 0 0 1 0 0 0 1 	1 1 0 1 0 1 0 0 
*
* S = EC B0 51 0C 31 D2 C9 85
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_400 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[0];
	assign g_in[2] = in[7] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[1] = in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	1 1 0 0 0 1 0 1 
	*	0 0 0 0 0 0 1 0 
	*	1 1 0 1 0 1 1 1 
	*	1 1 1 1 1 0 1 1 
	*	0 1 1 0 0 0 0 1 
	*	0 1 1 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 401
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 0 0 1 0 0 1 0 
*	0 1 1 1 1 1 0 0 	1 1 0 1 1 1 1 1 
*	1 0 1 0 1 1 0 0 	0 0 1 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 0 1 0 1 1 0 1 
*	0 1 0 0 1 0 1 0 	1 1 0 0 0 1 1 1 
*	1 1 1 0 1 0 0 1 	0 1 0 0 0 1 1 1 
*	1 0 0 0 1 1 1 0 	0 0 0 1 0 0 0 0 
*	0 0 0 1 1 1 1 1 	1 0 1 1 1 1 0 0 
*
* S = 5C EC 5D 51 E3 31 4C C9
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_401 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[6] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[0];
	assign g_in[1] = in[7] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	1 0 0 0 1 1 1 1 
	*	0 0 0 0 0 0 0 1 
	*	1 0 1 1 1 1 1 0 
	*	1 0 1 0 0 1 1 0 
	*	1 1 0 1 0 0 1 1 
	*	1 1 1 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 402
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 0 1 1 0 0 1 0 
*	0 1 1 1 0 0 0 0 	0 1 1 1 0 1 0 1 
*	1 0 1 0 1 1 0 0 	0 0 0 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 0 1 0 0 1 1 1 
*	0 1 0 0 1 0 1 0 	0 1 0 0 1 1 0 1 
*	1 0 1 0 0 0 1 1 	1 1 0 0 1 1 0 1 
*	1 0 0 0 1 1 1 0 	0 0 1 1 0 0 0 0 
*	1 0 0 1 0 0 0 1 	1 0 0 1 0 1 0 0 
*
* S = 5C B0 5D 0C E3 D2 4C 85
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_402 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[5] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	1 0 0 0 0 1 0 1 
	*	0 0 0 0 0 0 1 1 
	*	1 0 0 1 0 1 1 0 
	*	1 0 1 0 1 1 1 0 
	*	0 1 1 1 0 0 0 1 
	*	0 1 1 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 403
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 0 1 1 0 1 1 
*	1 1 0 1 1 1 1 0 	1 1 1 1 0 1 0 0 
*	1 1 0 1 1 1 0 0 	1 1 0 1 1 0 1 1 
*	0 0 0 0 1 1 1 0 	1 0 1 1 1 1 1 1 
*	1 1 1 1 0 1 1 0 	1 0 0 1 0 0 1 1 
*	0 0 1 1 0 0 1 0 	1 1 1 0 0 0 1 1 
*	0 0 1 0 1 1 0 1 	0 1 1 0 0 0 0 0 
*	0 1 0 1 0 1 0 1 	1 0 1 0 1 0 0 1 
*
* S = BD BC 50 B1 F8 57 66 7D
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_403 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[1];
	assign g_in[1] = in[5] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[6] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	0 1 1 1 0 1 0 0 
	*	0 0 0 0 0 1 1 0 
	*	1 0 1 0 0 0 1 0 
	*	1 1 0 0 0 1 0 1 
	*	1 1 1 1 1 1 0 1 
	*	0 0 1 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 404
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 1 0 1 1 0 
*	0 1 1 1 1 1 1 0 	1 0 1 0 1 1 0 0 
*	1 1 0 1 0 0 1 0 	1 0 1 1 0 1 1 0 
*	1 1 0 1 1 1 0 0 	0 1 1 0 1 0 1 0 
*	1 1 0 0 0 1 0 0 	0 1 1 1 0 0 1 0 
*	1 1 1 1 0 1 1 0 	1 0 0 1 0 0 1 0 
*	0 1 1 1 1 0 0 0 	1 1 0 1 0 0 0 0 
*	0 0 1 0 1 1 0 1 	0 1 0 1 0 1 1 1 
*
* S = 01 BD E1 50 AF F8 1B 66
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_404 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[6] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[0] = in[5] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	1 1 1 0 1 1 0 0 
	*	0 0 0 0 1 1 0 1 
	*	0 1 0 1 0 0 0 1 
	*	1 0 0 0 1 1 1 1 
	*	1 0 1 0 1 0 1 1 
	*	0 0 0 1 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[4] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 405
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 1 1 1 1 0 
*	1 1 0 1 1 1 1 0 	1 0 1 0 0 1 0 0 
*	1 1 0 1 0 0 1 0 	1 0 0 1 1 1 1 0 
*	0 0 0 0 1 1 1 0 	1 1 1 0 1 0 1 0 
*	1 1 0 0 0 1 0 0 	1 1 0 1 0 0 1 0 
*	0 0 1 1 0 0 1 0 	1 0 1 1 0 0 1 0 
*	0 1 1 1 1 0 0 0 	0 1 1 1 0 0 0 0 
*	0 1 0 1 0 1 0 1 	1 1 1 1 1 1 0 1 
*
* S = 01 BC E1 B1 AF 57 1B 7D
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_405 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[2];
	assign g_in[2] = in[5] ^ in[4] ^ in[1];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[3];
	assign g_in[0] = in[6] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	0 1 1 0 0 1 0 0 
	*	0 0 0 0 0 1 1 1 
	*	1 1 1 1 0 0 1 1 
	*	1 0 0 0 0 1 0 1 
	*	1 0 1 0 1 0 0 1 
	*	0 0 1 1 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 406
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 0 1 0 1 1 1 
*	1 1 0 1 1 1 1 0 	0 0 1 1 0 1 0 0 
*	1 0 1 0 0 0 1 0 	1 0 0 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 1 1 1 0 0 1 1 
*	1 1 1 1 0 1 1 0 	1 1 0 1 1 1 1 1 
*	0 0 1 1 0 0 1 0 	0 1 1 0 1 1 1 1 
*	1 1 0 1 1 0 1 1 	1 1 1 0 0 0 0 0 
*	0 1 1 0 0 1 1 1 	0 0 1 0 1 1 0 1 
*
* S = BD BC ED 0D F8 57 9E 2A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_406 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[0] = in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	1 0 1 1 0 1 0 0 
	*	0 0 0 0 1 1 1 0 
	*	0 0 1 0 1 0 1 0 
	*	1 1 0 0 0 0 0 1 
	*	0 0 1 1 1 0 0 1 
	*	1 0 1 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 407
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 1 1 1 1 0 
*	0 1 1 1 1 1 1 0 	0 0 1 0 1 1 0 0 
*	0 1 1 1 0 0 1 0 	0 1 1 1 1 1 1 0 
*	1 0 1 0 0 0 1 0 	1 1 1 0 0 0 1 0 
*	1 1 0 0 0 1 0 0 	1 0 1 1 1 0 1 0 
*	1 1 1 1 0 1 1 0 	1 1 0 1 1 0 1 0 
*	1 0 1 1 1 1 0 0 	1 0 0 1 0 0 0 0 
*	1 1 0 1 1 0 1 1 	0 0 0 1 1 0 1 1 
*
* S = 01 BD E0 ED AF F8 B4 9E
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_407 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	0 1 1 0 1 1 0 0 
	*	0 0 0 0 1 0 0 1 
	*	0 0 0 1 0 1 0 1 
	*	1 0 0 0 0 0 1 1 
	*	0 0 1 0 0 1 1 1 
	*	0 1 0 1 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[3] ^ g_out[0];
	assign out[3] = g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 408
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 1 0 1 1 0 
*	1 1 0 1 1 1 1 0 	0 0 1 0 0 1 0 0 
*	0 1 1 1 0 0 1 0 	1 1 0 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 1 1 0 0 0 1 0 
*	1 1 0 0 0 1 0 0 	1 0 0 1 1 0 1 0 
*	0 0 1 1 0 0 1 0 	0 1 1 1 1 0 1 0 
*	1 0 1 1 1 1 0 0 	1 0 1 1 0 0 0 0 
*	0 1 1 0 0 1 1 1 	0 0 1 1 1 0 0 1 
*
* S = 01 BC E0 0D AF 57 B4 2A
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_408 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[2];
	assign g_in[2] = in[5] ^ in[4] ^ in[1];
	assign g_in[1] = in[7] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[0] = in[6] ^ in[5] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	1 1 1 0 0 1 0 0 
	*	0 0 0 0 1 0 1 1 
	*	0 0 1 1 1 1 1 1 
	*	1 0 0 0 0 0 0 1 
	*	0 0 1 0 1 1 0 1 
	*	1 1 1 1 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 409
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 0 1 1 1 1 1 
*	1 1 0 1 1 1 1 0 	1 0 1 1 0 1 0 0 
*	0 1 1 1 1 1 0 0 	0 1 0 1 1 1 1 1 
*	0 1 1 1 0 0 0 0 	1 1 1 1 1 0 1 1 
*	1 1 1 1 0 1 1 0 	0 0 0 1 0 1 1 1 
*	0 0 1 1 0 0 1 0 	0 0 1 0 0 1 1 1 
*	1 1 1 0 1 0 0 1 	1 0 1 0 0 0 0 0 
*	1 0 1 0 0 0 1 1 	0 1 1 0 0 0 0 1 
*
* S = BD BC EC B0 F8 57 31 D2
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_409 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[1];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	0 0 1 1 0 1 0 0 
	*	0 0 0 0 1 0 1 0 
	*	0 1 1 0 1 1 1 0 
	*	1 1 0 0 1 1 0 1 
	*	1 0 1 1 0 1 0 1 
	*	1 1 1 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[3] ^ g_out[1];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 410
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 1 1 0 1 0 
*	0 1 1 1 1 1 1 0 	0 1 1 0 1 1 0 0 
*	0 0 0 0 1 1 0 0 	1 1 1 1 1 0 1 0 
*	0 1 1 1 1 1 0 0 	1 0 1 0 0 1 1 0 
*	1 1 0 0 0 1 0 0 	0 0 1 1 1 1 1 0 
*	1 1 1 1 0 1 1 0 	0 0 0 1 1 1 1 0 
*	0 1 0 0 1 0 1 0 	0 1 0 1 0 0 0 0 
*	1 1 1 0 1 0 0 1 	1 1 0 1 0 0 1 1 
*
* S = 01 BD 5C EC AF F8 E3 31
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_410 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[7] ^ in[6] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[6] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	0 0 1 0 1 1 0 0 
	*	0 0 0 0 0 1 0 1 
	*	1 1 0 1 1 0 0 1 
	*	1 0 0 0 1 0 1 1 
	*	0 1 1 0 1 1 1 1 
	*	1 0 0 1 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 411
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 1 1 0 1 0 
*	1 1 0 1 1 1 1 0 	1 1 1 0 0 1 0 0 
*	0 0 0 0 1 1 0 0 	0 1 0 1 1 0 1 0 
*	0 1 1 1 0 0 0 0 	1 0 1 0 1 1 1 0 
*	1 1 0 0 0 1 0 0 	0 0 0 1 0 1 1 0 
*	0 0 1 1 0 0 1 0 	0 0 1 1 0 1 1 0 
*	0 1 0 0 1 0 1 0 	1 1 1 1 0 0 0 0 
*	1 0 1 0 0 0 1 1 	0 1 1 1 0 0 0 1 
*
* S = 01 BC 5C B0 AF 57 E3 D2
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_411 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[2];
	assign g_in[2] = in[5] ^ in[4] ^ in[1];
	assign g_in[1] = in[6] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[5] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	0 0 1 0 0 1 0 0 
	*	0 0 0 0 1 1 1 1 
	*	0 1 1 1 1 0 1 1 
	*	1 0 0 0 1 0 0 1 
	*	1 1 1 0 0 1 0 1 
	*	1 0 1 1 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[2] );
	assign out[4] = g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 412
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 0 1 0 0 1 1 
*	1 1 0 1 1 1 1 0 	0 1 1 1 0 1 0 0 
*	0 0 0 0 0 0 1 0 	0 0 0 1 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 0 1 1 0 1 1 1 
*	1 1 1 1 0 1 1 0 	0 1 0 1 1 0 1 1 
*	0 0 1 1 0 0 1 0 	1 0 1 0 1 0 1 1 
*	0 0 0 1 1 1 1 1 	0 0 1 0 0 0 0 0 
*	1 0 0 1 0 0 0 1 	1 1 1 0 0 1 0 1 
*
* S = BD BC 51 0C F8 57 C9 85
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_412 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[2] = in[5] ^ in[4] ^ in[1];
	assign g_in[1] = in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];
	assign g_in[0] = in[7] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	1 1 1 1 0 1 0 0 
	*	0 0 0 0 0 0 1 0 
	*	1 1 1 0 0 1 1 0 
	*	1 1 0 0 1 0 0 1 
	*	0 1 1 1 0 0 0 1 
	*	0 1 1 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[1];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 413
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 1 0 0 1 0 
*	0 1 1 1 1 1 1 0 	1 1 1 0 1 1 0 0 
*	1 0 1 0 1 1 0 0 	0 0 1 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	0 0 1 0 1 1 1 0 
*	1 1 0 0 0 1 0 0 	1 1 1 1 0 1 1 0 
*	1 1 1 1 0 1 1 0 	0 1 0 1 0 1 1 0 
*	1 0 0 0 1 1 1 0 	0 0 0 1 0 0 0 0 
*	0 0 0 1 1 1 1 1 	1 0 0 1 1 1 1 1 
*
* S = 01 BD 5D 51 AF F8 4C C9
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_413 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[2] ^ in[1];
	assign g_in[1] = in[7] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	1 0 1 0 1 1 0 0 
	*	0 0 0 0 0 0 0 1 
	*	1 0 0 1 1 1 0 1 
	*	1 0 0 0 0 1 1 1 
	*	1 1 1 0 0 0 1 1 
	*	1 1 0 1 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[0];
	assign out[3] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 414
*
* GF(2^8) Poly Basis: [L^8, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 1 0 0 1 0 
*	1 1 0 1 1 1 1 0 	0 1 1 0 0 1 0 0 
*	1 0 1 0 1 1 0 0 	0 0 0 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 0 1 0 0 1 1 0 
*	1 1 0 0 0 1 0 0 	0 1 0 1 1 1 1 0 
*	0 0 1 1 0 0 1 0 	1 1 1 1 1 1 1 0 
*	1 0 0 0 1 1 1 0 	0 0 1 1 0 0 0 0 
*	1 0 0 1 0 0 0 1 	1 0 1 1 0 1 0 1 
*
* S = 01 BC 5D 0C AF 57 4C 85
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_414 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[6] ^ in[2];
	assign g_in[2] = in[5] ^ in[4] ^ in[1];
	assign g_in[1] = in[7] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	1 0 1 0 0 1 0 0 
	*	0 0 0 0 0 0 1 1 
	*	1 0 1 1 0 1 1 1 
	*	1 0 0 0 1 1 0 1 
	*	0 1 1 0 0 0 0 1 
	*	0 1 1 1 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 415
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 1 1 0 0 	0 0 1 0 0 1 1 0 
*	0 0 0 0 1 1 1 0 	0 1 1 0 0 1 0 1 
*	1 0 1 0 0 0 1 0 	1 1 0 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 1 0 1 0 0 1 1 
*	1 1 1 1 0 0 0 1 	0 0 1 0 1 1 0 0 
*	0 1 0 1 1 0 1 1 	1 0 1 1 1 1 0 0 
*	0 1 1 1 1 0 0 1 	1 1 0 1 0 0 0 0 
*	1 0 1 1 0 1 1 1 	1 1 0 0 1 1 1 0 
*
* S = 50 B1 ED 0D 36 CC 73 27
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_415 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 0 1 0 1 0 
	*	0 1 1 1 0 0 0 0 
	*	1 1 0 0 0 1 0 1 
	*	1 1 0 1 1 1 0 1 
	*	1 0 1 0 1 0 0 0 
	*	1 1 1 0 0 0 0 1 
	*	1 0 0 0 1 0 1 1 
	*	0 0 0 0 1 0 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[3];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[3] );

endmodule





/*****************************************************
* S-Box # 416
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 0 0 1 1 1 0 1 
*	1 1 0 1 1 1 0 0 	1 1 0 1 1 1 1 1 
*	0 1 1 1 0 0 1 0 	1 0 1 1 1 1 0 1 
*	1 0 1 0 0 0 1 0 	1 1 1 1 0 0 1 0 
*	1 0 1 0 1 0 1 0 	0 0 0 1 1 0 0 0 
*	1 1 1 1 0 0 0 1 	0 1 1 0 1 0 0 0 
*	1 1 0 0 1 1 1 0 	1 0 1 1 0 0 0 0 
*	0 1 1 1 1 0 0 1 	1 0 0 0 1 0 0 1 
*
* S = E1 50 E0 ED FA 36 54 73
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_416 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[7] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 0 1 0 1 
	*	1 1 1 0 0 0 0 0 
	*	1 0 0 0 1 1 1 1 
	*	1 0 1 1 1 0 1 1 
	*	0 1 0 1 0 1 0 0 
	*	1 0 0 1 0 0 1 1 
	*	0 1 0 0 0 1 1 0 
	*	0 0 0 0 0 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[2] );

endmodule





/*****************************************************
* S-Box # 417
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Norm Basis: [alpha^4, alpha^1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 1 0 1 0 0 1 0 	0 0 1 1 0 1 1 1 
*	0 0 0 0 1 1 1 0 	0 1 1 1 0 1 0 1 
*	0 1 1 1 0 0 1 0 	1 0 0 1 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 1 0 1 0 0 1 0 
*	1 0 1 0 1 0 1 0 	0 0 1 1 1 0 0 0 
*	0 1 0 1 1 0 1 1 	1 1 1 0 1 0 0 0 
*	1 1 0 0 1 1 1 0 	1 0 0 1 0 0 0 0 
*	1 0 1 1 0 1 1 1 	1 0 0 0 1 0 1 1 
*
* S = E1 B1 E0 0D FA CC 54 27
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_417 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[6] = in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[2] = in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_1_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 1 1 1 1 
	*	0 1 1 0 0 0 0 0 
	*	1 0 0 0 0 1 0 1 
	*	1 0 0 1 1 0 0 1 
	*	1 1 1 1 1 1 0 0 
	*	1 0 1 1 0 0 0 1 
	*	1 1 0 0 1 1 1 0 
	*	0 0 0 0 1 1 0 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] );
	assign out[0] = ~( g_out[3] ^ g_out[2] );

endmodule





/*****************************************************
* S-Box # 418
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 0 0 	1 1 0 1 0 0 1 1 
*	0 1 1 1 0 0 0 0 	0 0 1 1 0 1 0 1 
*	0 0 0 0 0 0 1 0 	0 0 1 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 1 0 1 0 1 1 0 
*	1 0 0 1 0 1 0 1 	1 1 0 1 1 0 0 1 
*	1 1 0 1 0 0 1 1 	0 0 0 1 1 0 0 1 
*	0 0 0 1 1 1 0 1 	0 0 1 0 0 0 0 0 
*	0 0 1 1 1 1 1 1 	1 0 0 1 0 1 0 0 
*
* S = EC B0 51 0C DD 62 98 89
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_418 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[1] = in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_NormNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 0 1 0 
	*	1 0 0 0 0 0 0 0 
	*	1 0 0 1 0 1 0 1 
	*	0 0 1 0 0 0 1 0 
	*	1 0 1 0 0 1 1 1 
	*	0 1 0 0 1 0 1 1 
	*	0 1 1 1 0 0 0 1 
	*	0 0 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3] ^ g_out[1];
	assign out[6] = ~( g_out[7] );
	assign out[5] = ~( g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[5] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 419
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 0 1 1 0 0 1 0 
*	0 1 1 1 1 1 0 0 	0 0 1 0 1 1 1 1 
*	1 0 1 0 1 1 0 0 	0 0 0 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 1 1 1 1 1 0 1 
*	0 1 0 0 0 1 1 0 	1 0 1 1 0 1 1 1 
*	1 0 0 1 0 1 0 1 	0 0 1 1 0 1 1 1 
*	0 0 1 0 0 0 1 0 	0 0 0 1 0 0 0 0 
*	0 0 0 1 1 1 0 1 	0 1 1 1 1 1 0 0 
*
* S = 5C EC 5D 51 BF DD 11 98
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_419 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[1] = in[5] ^ in[1];
	assign g_in[0] = in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 0 0 1 0 1 
	*	0 1 0 0 0 0 0 0 
	*	0 1 1 1 1 1 1 1 
	*	0 0 0 1 0 0 0 1 
	*	0 1 0 1 1 1 1 0 
	*	1 1 0 0 0 1 1 0 
	*	1 1 1 0 0 0 1 1 
	*	0 0 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[6] = ~( g_out[6] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[4] = g_out[4] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 420
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Norm Basis: [alpha^8, alpha^2]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	0 0 0 0 1 1 0 0 	1 0 0 1 0 0 1 0 
*	0 1 1 1 0 0 0 0 	0 0 1 0 0 1 0 1 
*	1 0 1 0 1 1 0 0 	0 0 1 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 1 0 1 0 1 1 1 
*	0 1 0 0 0 1 1 0 	1 0 0 1 1 1 0 1 
*	1 1 0 1 0 0 1 1 	0 0 0 1 1 1 0 1 
*	0 0 1 0 0 0 1 0 	0 0 1 1 0 0 0 0 
*	0 0 1 1 1 1 1 1 	1 1 0 1 0 1 0 0 
*
* S = 5C B0 5D 0C BF 62 11 89
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_420 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[3] ^ in[2];
	assign g_in[6] = in[6] ^ in[5] ^ in[4];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[2] ^ in[1];
	assign g_in[2] = in[7] ^ in[6] ^ in[4] ^ in[1] ^ in[0];
	assign g_in[1] = in[5] ^ in[1];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_NormPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_NormPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_NormPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_NormPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_NormPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 0 1 1 1 1 
	*	1 1 0 0 0 0 0 0 
	*	1 1 0 1 0 1 0 1 
	*	0 0 1 1 0 0 1 1 
	*	1 1 1 1 0 1 1 0 
	*	0 1 0 0 1 1 1 0 
	*	0 1 1 0 0 0 0 1 
	*	0 0 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[6] = ~( g_out[7] ^ g_out[6] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 421
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 0 1 0 1 0 1 1 
*	1 1 0 1 1 1 1 0 	1 0 1 1 0 1 0 0 
*	1 1 0 1 1 1 0 0 	0 1 1 0 1 0 1 1 
*	0 0 0 0 1 1 1 0 	0 1 0 0 1 1 1 1 
*	1 0 0 0 1 0 0 0 	1 0 1 0 0 0 1 1 
*	1 1 1 0 1 1 0 0 	1 1 0 1 0 0 1 1 
*	1 1 1 1 0 0 0 1 	0 1 1 0 0 0 0 0 
*	0 1 0 1 1 0 1 1 	0 0 1 1 1 0 0 1 
*
* S = BD BC 50 B1 45 EB 36 CC
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_421 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[0];
	assign g_in[0] = in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 0 0 0 
	*	1 1 1 0 0 0 0 0 
	*	0 0 1 1 0 1 0 0 
	*	0 1 1 0 0 1 1 0 
	*	1 0 0 0 0 0 1 0 
	*	1 0 0 1 0 1 0 1 
	*	0 0 1 0 1 1 0 1 
	*	0 0 0 0 0 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[1] );

endmodule





/*****************************************************
* S-Box # 422
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 0 1 0 1 1 0 
*	0 1 1 1 1 1 1 0 	0 1 1 0 1 1 0 0 
*	1 1 0 1 0 0 1 0 	1 1 0 1 0 1 1 0 
*	1 1 0 1 1 1 0 0 	1 1 0 0 1 0 1 0 
*	0 1 1 0 0 1 0 0 	0 1 0 1 0 0 1 0 
*	1 0 0 0 1 0 0 0 	1 0 1 1 0 0 1 0 
*	1 0 1 0 1 0 1 0 	1 1 0 1 0 0 0 0 
*	1 1 1 1 0 0 0 1 	0 0 1 0 0 1 1 1 
*
* S = 01 BD E1 50 AE 45 FA 36
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_422 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[3];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 1 1 0 1 0 0 
	*	1 0 0 1 0 0 0 0 
	*	0 0 1 0 1 1 0 0 
	*	1 1 0 1 1 1 0 1 
	*	0 1 0 0 0 0 0 1 
	*	0 1 1 1 1 1 1 1 
	*	0 0 0 1 1 0 1 1 
	*	0 0 0 0 0 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[0] );

endmodule





/*****************************************************
* S-Box # 423
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^1, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 1 1 1 1 1 0 
*	1 1 0 1 1 1 1 0 	1 1 1 0 0 1 0 0 
*	1 1 0 1 0 0 1 0 	0 1 1 1 1 1 1 0 
*	0 0 0 0 1 1 1 0 	0 1 0 0 1 0 1 0 
*	0 1 1 0 0 1 0 0 	1 1 1 1 0 0 1 0 
*	1 1 1 0 1 1 0 0 	1 0 0 1 0 0 1 0 
*	1 0 1 0 1 0 1 0 	0 1 1 1 0 0 0 0 
*	0 1 0 1 1 0 1 1 	0 0 1 0 1 1 0 1 
*
* S = 01 BC E1 B1 AE EB FA CC
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_423 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[6] ^ in[4] ^ in[1];
	assign g_in[4] = in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[5] ^ in[3] ^ in[1];
	assign g_in[0] = in[6] ^ in[4] ^ in[3] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 1 0 0 
	*	1 0 1 1 0 0 0 0 
	*	0 0 1 0 0 1 0 0 
	*	0 1 1 1 0 1 1 1 
	*	1 1 0 0 0 0 1 1 
	*	1 1 0 1 0 1 0 1 
	*	0 0 1 1 1 0 0 1 
	*	0 0 0 0 0 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[5] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 424
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 0 1 0 0 1 1 1 
*	1 1 0 1 1 1 1 0 	0 1 1 1 0 1 0 0 
*	1 0 1 0 0 0 1 0 	1 1 1 0 0 1 1 1 
*	1 1 0 1 0 0 0 0 	0 1 0 0 0 0 1 1 
*	1 0 0 0 1 0 0 0 	0 0 1 0 1 1 1 1 
*	1 1 1 0 1 1 0 0 	1 0 0 1 1 1 1 1 
*	0 1 1 1 1 0 0 1 	1 1 1 0 0 0 0 0 
*	1 0 1 1 0 1 1 1 	1 1 1 1 1 1 0 1 
*
* S = BD BC ED 0D 45 EB 73 27
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_424 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[7] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 0 1 1 0 0 0 
	*	0 1 1 0 0 0 0 0 
	*	1 1 1 1 0 1 0 0 
	*	1 1 1 0 1 1 1 0 
	*	1 0 0 0 1 0 1 0 
	*	1 1 0 1 0 0 0 1 
	*	1 0 1 0 1 0 0 1 
	*	0 0 0 0 1 0 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[6] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[1];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[0] );
	assign out[0] = ~( g_out[3] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 425
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 0 1 1 1 1 0 
*	0 1 1 1 1 1 1 0 	1 1 1 0 1 1 0 0 
*	0 1 1 1 0 0 1 0 	1 0 0 1 1 1 1 0 
*	1 0 1 0 0 0 1 0 	1 1 0 0 0 0 1 0 
*	0 1 1 0 0 1 0 0 	0 0 0 1 1 0 1 0 
*	1 0 0 0 1 0 0 0 	0 1 1 1 1 0 1 0 
*	1 1 0 0 1 1 1 0 	1 0 0 1 0 0 0 0 
*	0 1 1 1 1 0 0 1 	1 0 1 0 1 0 1 1 
*
* S = 01 BD E0 ED AE 45 54 73
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_425 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[3];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 1 1 0 1 0 0 
	*	1 1 0 1 0 0 0 0 
	*	1 0 1 0 1 1 0 0 
	*	1 0 0 1 1 0 0 1 
	*	0 1 0 0 0 1 0 1 
	*	1 0 1 1 0 0 1 1 
	*	0 1 0 1 0 1 1 1 
	*	0 0 0 0 0 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 426
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^4, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 0 1 1 0 1 1 0 
*	1 1 0 1 1 1 1 0 	0 1 1 0 0 1 0 0 
*	0 1 1 1 0 0 1 0 	1 0 1 1 0 1 1 0 
*	1 1 0 1 0 0 0 0 	0 1 0 0 0 0 1 0 
*	0 1 1 0 0 1 0 0 	0 0 1 1 1 0 1 0 
*	1 1 1 0 1 1 0 0 	1 1 0 1 1 0 1 0 
*	1 1 0 0 1 1 1 0 	1 0 1 1 0 0 0 0 
*	1 0 1 1 0 1 1 1 	1 0 1 0 1 0 0 1 
*
* S = 01 BC E0 0D AE EB 54 27
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_426 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[1];
	assign g_in[4] = in[7] ^ in[6] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[6] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[5] ^ in[4] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N2_1_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 0 0 1 1 1 0 0 
	*	0 1 1 1 0 0 0 0 
	*	1 0 1 0 0 1 0 0 
	*	1 0 1 1 1 0 1 1 
	*	1 1 0 0 1 1 1 1 
	*	1 0 0 1 0 0 0 1 
	*	1 1 1 1 1 1 0 1 
	*	0 0 0 0 1 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[4] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 427
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	0 1 1 0 1 1 1 1 
*	1 1 0 1 1 1 1 0 	1 1 1 1 0 1 0 0 
*	0 1 1 1 1 1 0 0 	1 0 1 0 1 1 1 1 
*	0 1 1 1 0 0 0 0 	0 1 0 0 1 0 1 1 
*	1 0 0 0 1 0 0 0 	0 1 1 0 0 1 1 1 
*	1 1 1 0 1 1 0 0 	0 1 0 1 0 1 1 1 
*	1 0 0 1 0 1 0 1 	1 0 1 0 0 0 0 0 
*	1 1 0 1 0 0 1 1 	0 1 1 1 0 0 0 1 
*
* S = BD BC EC B0 45 EB DD 62
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_427 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[7] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[7] ^ in[4] ^ in[2] ^ in[0];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 0 0 0 
	*	0 0 1 0 0 0 0 0 
	*	0 1 1 1 0 1 0 0 
	*	1 0 1 0 1 0 1 0 
	*	1 0 0 0 1 1 1 0 
	*	0 0 0 1 1 1 0 1 
	*	1 1 1 0 0 1 0 1 
	*	0 0 0 0 1 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[5] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[5] ^ g_out[3] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[3] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[3] ^ g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 428
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 1 0 1 1 0 1 0 
*	0 1 1 1 1 1 1 0 	1 0 1 0 1 1 0 0 
*	0 0 0 0 1 1 0 0 	0 1 0 1 1 0 1 0 
*	0 1 1 1 1 1 0 0 	1 1 0 0 0 1 1 0 
*	0 1 1 0 0 1 0 0 	1 1 0 1 1 1 1 0 
*	1 0 0 0 1 0 0 0 	1 1 1 1 1 1 1 0 
*	0 1 0 0 0 1 1 0 	0 1 0 1 0 0 0 0 
*	1 0 0 1 0 1 0 1 	1 1 1 0 0 0 1 1 
*
* S = 01 BD 5C EC AE 45 BF DD
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_428 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[3];
	assign g_in[1] = in[6] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[4] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 1 1 0 1 0 0 
	*	0 0 0 1 0 0 0 0 
	*	1 1 1 0 1 1 0 0 
	*	0 1 0 1 0 1 0 1 
	*	0 1 0 0 1 0 0 1 
	*	0 0 1 1 1 0 1 1 
	*	1 0 0 1 1 1 1 1 
	*	0 0 0 0 1 0 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[6] ^ g_out[4] ^ g_out[2] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[3] ^ g_out[0];
	assign out[2] = g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[3] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 429
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^2, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	0 1 1 1 1 0 1 0 
*	1 1 0 1 1 1 1 0 	1 0 1 0 0 1 0 0 
*	0 0 0 0 1 1 0 0 	1 1 1 1 1 0 1 0 
*	0 1 1 1 0 0 0 0 	0 1 0 0 1 1 1 0 
*	0 1 1 0 0 1 0 0 	0 1 1 1 0 1 1 0 
*	1 1 1 0 1 1 0 0 	0 1 0 1 0 1 1 0 
*	0 1 0 0 0 1 1 0 	1 1 1 1 0 0 0 0 
*	1 1 0 1 0 0 1 1 	0 1 1 0 0 0 0 1 
*
* S = 01 BC 5C B0 AE EB BF 62
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_429 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[3] ^ in[2];
	assign g_in[4] = in[6] ^ in[5] ^ in[4];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[6] ^ in[2] ^ in[1];
	assign g_in[0] = in[7] ^ in[6] ^ in[4] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_N_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 0 0 1 1 1 0 0 
	*	0 0 1 1 0 0 0 0 
	*	0 1 1 0 0 1 0 0 
	*	1 1 1 1 1 1 1 1 
	*	1 1 0 0 1 0 1 1 
	*	0 0 0 1 1 0 0 1 
	*	1 0 1 1 0 1 0 1 
	*	0 0 0 0 1 0 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[3] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[0] );
	assign out[0] = ~( g_out[3] ^ g_out[1] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 430
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Norm Basis: [Omega^2, Omega^1]
*
* Mapping & Inverse Mapping:
*
*	0 1 1 1 1 1 1 0 	1 1 1 0 0 0 1 1 
*	1 1 0 1 1 1 1 0 	0 0 1 1 0 1 0 0 
*	0 0 0 0 0 0 1 0 	0 0 1 0 0 0 1 1 
*	1 0 1 0 1 1 1 0 	0 1 0 0 0 1 1 1 
*	1 0 0 0 1 0 0 0 	1 1 1 0 1 0 1 1 
*	1 1 1 0 1 1 0 0 	0 0 0 1 1 0 1 1 
*	0 0 0 1 1 1 0 1 	0 0 1 0 0 0 0 0 
*	0 0 1 1 1 1 1 1 	1 0 1 1 0 1 0 1 
*
* S = BD BC 51 0C 45 EB 98 89
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_430 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[1];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[7] ^ in[3];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[4] ^ in[3] ^ in[2] ^ in[0];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyNorm u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyNorm u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyNorm u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyNorm u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 0 0 0 
	*	1 0 1 0 0 0 0 0 
	*	1 0 1 1 0 1 0 0 
	*	0 0 1 0 0 0 1 0 
	*	1 0 0 0 0 1 1 0 
	*	0 1 0 1 1 0 0 1 
	*	0 1 1 0 0 0 0 1 
	*	0 0 0 0 0 1 1 0 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3];
	assign out[6] = ~( g_out[7] ^ g_out[5] );
	assign out[5] = ~( g_out[7] ^ g_out[5] ^ g_out[4] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[1];
	assign out[3] = g_out[7] ^ g_out[2] ^ g_out[1];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[0] );
	assign out[0] = ~( g_out[2] ^ g_out[1] );

endmodule





/*****************************************************
* S-Box # 431
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^1, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 0 1 0 0 1 0 
*	0 1 1 1 1 1 1 0 	0 0 1 0 1 1 0 0 
*	1 0 1 0 1 1 0 0 	0 0 0 1 0 0 1 0 
*	0 0 0 0 0 0 1 0 	1 1 0 0 1 1 1 0 
*	0 1 1 0 0 1 0 0 	1 0 0 1 0 1 1 0 
*	1 0 0 0 1 0 0 0 	0 0 1 1 0 1 1 0 
*	0 0 1 0 0 0 1 0 	0 0 0 1 0 0 0 0 
*	0 0 0 1 1 1 0 1 	0 1 1 0 1 1 1 1 
*
* S = 01 BD 5D 51 AE 45 11 98
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_431 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[3];
	assign g_in[1] = in[5] ^ in[1];
	assign g_in[0] = in[4] ^ in[3] ^ in[2] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw2_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw2_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw2_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw2_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	1 1 1 1 0 1 0 0 
	*	0 1 0 1 0 0 0 0 
	*	0 1 1 0 1 1 0 0 
	*	0 0 0 1 0 0 0 1 
	*	0 1 0 0 1 1 0 1 
	*	1 1 1 1 0 1 1 1 
	*	1 1 0 1 0 0 1 1 
	*	0 0 0 0 1 1 0 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2];
	assign out[6] = ~( g_out[6] ^ g_out[4] );
	assign out[5] = ~( g_out[6] ^ g_out[5] ^ g_out[3] ^ g_out[2] );
	assign out[4] = g_out[4] ^ g_out[0];
	assign out[3] = g_out[6] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[2] = g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[1] = ~( g_out[7] ^ g_out[6] ^ g_out[4] ^ g_out[1] ^ g_out[0] );
	assign out[0] = ~( g_out[3] ^ g_out[2] ^ g_out[0] );

endmodule





/*****************************************************
* S-Box # 432
*
* GF(2^8) Poly Basis: [L^128, 1]
* GF(2^4) Poly Basis: [alpha^8, 1]
* GF(2^2) Poly Basis: [Omega^2, 1]
*
* Mapping & Inverse Mapping:
*
*	1 0 1 0 0 0 0 0 	1 0 1 1 0 0 1 0 
*	1 1 0 1 1 1 1 0 	0 0 1 0 0 1 0 0 
*	1 0 1 0 1 1 0 0 	0 0 1 1 0 0 1 0 
*	1 0 1 0 1 1 1 0 	0 1 0 0 0 1 1 0 
*	0 1 1 0 0 1 0 0 	1 0 1 1 1 1 1 0 
*	1 1 1 0 1 1 0 0 	0 0 0 1 1 1 1 0 
*	0 0 1 0 0 0 1 0 	0 0 1 1 0 0 0 0 
*	0 0 1 1 1 1 1 1 	1 1 1 0 0 1 0 1 
*
* S = 01 BC 5D 0C AE EB 11 89
*****************************************************/

module AES_SBox_GF_2_2_2_PolyNormMixBasis_432 (out, in);

	input [7:0] in;
	output [7:0] out;

	wire [7:0] g_in, g_out;

	wire [3:0] t1, t2, t3, t4, t5, t6, t7;

	// Mapping from GF(2^8) to GF(((2^2)^2)^2)

	assign g_in[7] = in[7] ^ in[5];
	assign g_in[6] = in[7] ^ in[6] ^ in[4] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[5] = in[7] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[4] = in[7] ^ in[5] ^ in[3] ^ in[2] ^ in[1];
	assign g_in[3] = in[6] ^ in[5] ^ in[2];
	assign g_in[2] = in[7] ^ in[6] ^ in[5] ^ in[3] ^ in[2];
	assign g_in[1] = in[5] ^ in[1];
	assign g_in[0] = in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];

	// GF(((2^2)^2)^2) Inverter

	assign t1 = g_in[7:4] ^ g_in[3:0];
	GF_2_4_MUL_Nw_PolyPoly u_mul_1 (.q(t2), .a(t1), .b(g_in[3:0]));
	GF_2_4_SQR_SCL_N_0_Nw_PolyPoly u_sqr_scl (.q(t3), .a(g_in[7:4]));
	assign t4 = t2 ^ t3;
	GF_2_4_INV_Nw_PolyPoly u_inv (.q(t5), .a(t4));
	GF_2_4_MUL_Nw_PolyPoly u_mul_2 (.q(t6), .a(t5), .b(g_in[7:4]));
	GF_2_4_MUL_Nw_PolyPoly u_mul_3 (.q(t7), .a(t5), .b(t1));
	assign g_out = {t6, t7};

	/*****************************************************
	* Inverse Map + Affine Matrix:
	*
	*	0 1 0 1 1 1 0 0 
	*	1 1 1 1 0 0 0 0 
	*	1 1 1 0 0 1 0 0 
	*	0 0 1 1 0 0 1 1 
	*	1 1 0 0 0 1 1 1 
	*	0 1 0 1 1 1 0 1 
	*	0 1 1 1 0 0 0 1 
	*	0 0 0 0 0 1 1 1 
	*****************************************************/

	// Mapping from GF((2^4)^2) to GF(2^8) Combined with Affine Transformation

	assign out[7] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2];
	assign out[6] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[4] );
	assign out[5] = ~( g_out[7] ^ g_out[6] ^ g_out[5] ^ g_out[2] );
	assign out[4] = g_out[5] ^ g_out[4] ^ g_out[1] ^ g_out[0];
	assign out[3] = g_out[7] ^ g_out[6] ^ g_out[2] ^ g_out[1] ^ g_out[0];
	assign out[2] = g_out[6] ^ g_out[4] ^ g_out[3] ^ g_out[2] ^ g_out[0];
	assign out[1] = ~( g_out[6] ^ g_out[5] ^ g_out[4] ^ g_out[0] );
	assign out[0] = ~( g_out[2] ^ g_out[1] ^ g_out[0] );

endmodule





/************************************
*
* Wrapper for all 432 S-Boxes
*
************************************/

module AES_SBox_GF_2_4_AllPolyBases (
					out_1, out_2, out_3, 
					out_4, out_5, out_6, 
					out_7, out_8, out_9, 
					out_10, out_11, out_12, 
					out_13, out_14, out_15, 
					out_16, out_17, out_18, 
					out_19, out_20, out_21, 
					out_22, out_23, out_24, 
					out_25, out_26, out_27, 
					out_28, out_29, out_30, 
					out_31, out_32, out_33, 
					out_34, out_35, out_36, 
					out_37, out_38, out_39, 
					out_40, out_41, out_42, 
					out_43, out_44, out_45, 
					out_46, out_47, out_48, 
					out_49, out_50, out_51, 
					out_52, out_53, out_54, 
					out_55, out_56, out_57, 
					out_58, out_59, out_60, 
					out_61, out_62, out_63, 
					out_64, out_65, out_66, 
					out_67, out_68, out_69, 
					out_70, out_71, out_72, 
					out_73, out_74, out_75, 
					out_76, out_77, out_78, 
					out_79, out_80, out_81, 
					out_82, out_83, out_84, 
					out_85, out_86, out_87, 
					out_88, out_89, out_90, 
					out_91, out_92, out_93, 
					out_94, out_95, out_96, 
					out_97, out_98, out_99, 
					out_100, out_101, out_102, 
					out_103, out_104, out_105, 
					out_106, out_107, out_108, 
					out_109, out_110, out_111, 
					out_112, out_113, out_114, 
					out_115, out_116, out_117, 
					out_118, out_119, out_120, 
					out_121, out_122, out_123, 
					out_124, out_125, out_126, 
					out_127, out_128, out_129, 
					out_130, out_131, out_132, 
					out_133, out_134, out_135, 
					out_136, out_137, out_138, 
					out_139, out_140, out_141, 
					out_142, out_143, out_144, 
					out_145, out_146, out_147, 
					out_148, out_149, out_150, 
					out_151, out_152, out_153, 
					out_154, out_155, out_156, 
					out_157, out_158, out_159, 
					out_160, out_161, out_162, 
					out_163, out_164, out_165, 
					out_166, out_167, out_168, 
					out_169, out_170, out_171, 
					out_172, out_173, out_174, 
					out_175, out_176, out_177, 
					out_178, out_179, out_180, 
					out_181, out_182, out_183, 
					out_184, out_185, out_186, 
					out_187, out_188, out_189, 
					out_190, out_191, out_192, 
					out_193, out_194, out_195, 
					out_196, out_197, out_198, 
					out_199, out_200, out_201, 
					out_202, out_203, out_204, 
					out_205, out_206, out_207, 
					out_208, out_209, out_210, 
					out_211, out_212, out_213, 
					out_214, out_215, out_216, 
					out_217, out_218, out_219, 
					out_220, out_221, out_222, 
					out_223, out_224, out_225, 
					out_226, out_227, out_228, 
					out_229, out_230, out_231, 
					out_232, out_233, out_234, 
					out_235, out_236, out_237, 
					out_238, out_239, out_240, 
					out_241, out_242, out_243, 
					out_244, out_245, out_246, 
					out_247, out_248, out_249, 
					out_250, out_251, out_252, 
					out_253, out_254, out_255, 
					out_256, out_257, out_258, 
					out_259, out_260, out_261, 
					out_262, out_263, out_264, 
					out_265, out_266, out_267, 
					out_268, out_269, out_270, 
					out_271, out_272, out_273, 
					out_274, out_275, out_276, 
					out_277, out_278, out_279, 
					out_280, out_281, out_282, 
					out_283, out_284, out_285, 
					out_286, out_287, out_288, 
					out_289, out_290, out_291, 
					out_292, out_293, out_294, 
					out_295, out_296, out_297, 
					out_298, out_299, out_300, 
					out_301, out_302, out_303, 
					out_304, out_305, out_306, 
					out_307, out_308, out_309, 
					out_310, out_311, out_312, 
					out_313, out_314, out_315, 
					out_316, out_317, out_318, 
					out_319, out_320, out_321, 
					out_322, out_323, out_324, 
					out_325, out_326, out_327, 
					out_328, out_329, out_330, 
					out_331, out_332, out_333, 
					out_334, out_335, out_336, 
					out_337, out_338, out_339, 
					out_340, out_341, out_342, 
					out_343, out_344, out_345, 
					out_346, out_347, out_348, 
					out_349, out_350, out_351, 
					out_352, out_353, out_354, 
					out_355, out_356, out_357, 
					out_358, out_359, out_360, 
					out_361, out_362, out_363, 
					out_364, out_365, out_366, 
					out_367, out_368, out_369, 
					out_370, out_371, out_372, 
					out_373, out_374, out_375, 
					out_376, out_377, out_378, 
					out_379, out_380, out_381, 
					out_382, out_383, out_384, 
					out_385, out_386, out_387, 
					out_388, out_389, out_390, 
					out_391, out_392, out_393, 
					out_394, out_395, out_396, 
					out_397, out_398, out_399, 
					out_400, out_401, out_402, 
					out_403, out_404, out_405, 
					out_406, out_407, out_408, 
					out_409, out_410, out_411, 
					out_412, out_413, out_414, 
					out_415, out_416, out_417, 
					out_418, out_419, out_420, 
					out_421, out_422, out_423, 
					out_424, out_425, out_426, 
					out_427, out_428, out_429, 
					out_430, out_431, out_432, 
					in   );

	input [7:0] in;

	output [7:0] out_1;
	output [7:0] out_2;
	output [7:0] out_3;
	output [7:0] out_4;
	output [7:0] out_5;
	output [7:0] out_6;
	output [7:0] out_7;
	output [7:0] out_8;
	output [7:0] out_9;
	output [7:0] out_10;
	output [7:0] out_11;
	output [7:0] out_12;
	output [7:0] out_13;
	output [7:0] out_14;
	output [7:0] out_15;
	output [7:0] out_16;
	output [7:0] out_17;
	output [7:0] out_18;
	output [7:0] out_19;
	output [7:0] out_20;
	output [7:0] out_21;
	output [7:0] out_22;
	output [7:0] out_23;
	output [7:0] out_24;
	output [7:0] out_25;
	output [7:0] out_26;
	output [7:0] out_27;
	output [7:0] out_28;
	output [7:0] out_29;
	output [7:0] out_30;
	output [7:0] out_31;
	output [7:0] out_32;
	output [7:0] out_33;
	output [7:0] out_34;
	output [7:0] out_35;
	output [7:0] out_36;
	output [7:0] out_37;
	output [7:0] out_38;
	output [7:0] out_39;
	output [7:0] out_40;
	output [7:0] out_41;
	output [7:0] out_42;
	output [7:0] out_43;
	output [7:0] out_44;
	output [7:0] out_45;
	output [7:0] out_46;
	output [7:0] out_47;
	output [7:0] out_48;
	output [7:0] out_49;
	output [7:0] out_50;
	output [7:0] out_51;
	output [7:0] out_52;
	output [7:0] out_53;
	output [7:0] out_54;
	output [7:0] out_55;
	output [7:0] out_56;
	output [7:0] out_57;
	output [7:0] out_58;
	output [7:0] out_59;
	output [7:0] out_60;
	output [7:0] out_61;
	output [7:0] out_62;
	output [7:0] out_63;
	output [7:0] out_64;
	output [7:0] out_65;
	output [7:0] out_66;
	output [7:0] out_67;
	output [7:0] out_68;
	output [7:0] out_69;
	output [7:0] out_70;
	output [7:0] out_71;
	output [7:0] out_72;
	output [7:0] out_73;
	output [7:0] out_74;
	output [7:0] out_75;
	output [7:0] out_76;
	output [7:0] out_77;
	output [7:0] out_78;
	output [7:0] out_79;
	output [7:0] out_80;
	output [7:0] out_81;
	output [7:0] out_82;
	output [7:0] out_83;
	output [7:0] out_84;
	output [7:0] out_85;
	output [7:0] out_86;
	output [7:0] out_87;
	output [7:0] out_88;
	output [7:0] out_89;
	output [7:0] out_90;
	output [7:0] out_91;
	output [7:0] out_92;
	output [7:0] out_93;
	output [7:0] out_94;
	output [7:0] out_95;
	output [7:0] out_96;
	output [7:0] out_97;
	output [7:0] out_98;
	output [7:0] out_99;
	output [7:0] out_100;
	output [7:0] out_101;
	output [7:0] out_102;
	output [7:0] out_103;
	output [7:0] out_104;
	output [7:0] out_105;
	output [7:0] out_106;
	output [7:0] out_107;
	output [7:0] out_108;
	output [7:0] out_109;
	output [7:0] out_110;
	output [7:0] out_111;
	output [7:0] out_112;
	output [7:0] out_113;
	output [7:0] out_114;
	output [7:0] out_115;
	output [7:0] out_116;
	output [7:0] out_117;
	output [7:0] out_118;
	output [7:0] out_119;
	output [7:0] out_120;
	output [7:0] out_121;
	output [7:0] out_122;
	output [7:0] out_123;
	output [7:0] out_124;
	output [7:0] out_125;
	output [7:0] out_126;
	output [7:0] out_127;
	output [7:0] out_128;
	output [7:0] out_129;
	output [7:0] out_130;
	output [7:0] out_131;
	output [7:0] out_132;
	output [7:0] out_133;
	output [7:0] out_134;
	output [7:0] out_135;
	output [7:0] out_136;
	output [7:0] out_137;
	output [7:0] out_138;
	output [7:0] out_139;
	output [7:0] out_140;
	output [7:0] out_141;
	output [7:0] out_142;
	output [7:0] out_143;
	output [7:0] out_144;
	output [7:0] out_145;
	output [7:0] out_146;
	output [7:0] out_147;
	output [7:0] out_148;
	output [7:0] out_149;
	output [7:0] out_150;
	output [7:0] out_151;
	output [7:0] out_152;
	output [7:0] out_153;
	output [7:0] out_154;
	output [7:0] out_155;
	output [7:0] out_156;
	output [7:0] out_157;
	output [7:0] out_158;
	output [7:0] out_159;
	output [7:0] out_160;
	output [7:0] out_161;
	output [7:0] out_162;
	output [7:0] out_163;
	output [7:0] out_164;
	output [7:0] out_165;
	output [7:0] out_166;
	output [7:0] out_167;
	output [7:0] out_168;
	output [7:0] out_169;
	output [7:0] out_170;
	output [7:0] out_171;
	output [7:0] out_172;
	output [7:0] out_173;
	output [7:0] out_174;
	output [7:0] out_175;
	output [7:0] out_176;
	output [7:0] out_177;
	output [7:0] out_178;
	output [7:0] out_179;
	output [7:0] out_180;
	output [7:0] out_181;
	output [7:0] out_182;
	output [7:0] out_183;
	output [7:0] out_184;
	output [7:0] out_185;
	output [7:0] out_186;
	output [7:0] out_187;
	output [7:0] out_188;
	output [7:0] out_189;
	output [7:0] out_190;
	output [7:0] out_191;
	output [7:0] out_192;
	output [7:0] out_193;
	output [7:0] out_194;
	output [7:0] out_195;
	output [7:0] out_196;
	output [7:0] out_197;
	output [7:0] out_198;
	output [7:0] out_199;
	output [7:0] out_200;
	output [7:0] out_201;
	output [7:0] out_202;
	output [7:0] out_203;
	output [7:0] out_204;
	output [7:0] out_205;
	output [7:0] out_206;
	output [7:0] out_207;
	output [7:0] out_208;
	output [7:0] out_209;
	output [7:0] out_210;
	output [7:0] out_211;
	output [7:0] out_212;
	output [7:0] out_213;
	output [7:0] out_214;
	output [7:0] out_215;
	output [7:0] out_216;
	output [7:0] out_217;
	output [7:0] out_218;
	output [7:0] out_219;
	output [7:0] out_220;
	output [7:0] out_221;
	output [7:0] out_222;
	output [7:0] out_223;
	output [7:0] out_224;
	output [7:0] out_225;
	output [7:0] out_226;
	output [7:0] out_227;
	output [7:0] out_228;
	output [7:0] out_229;
	output [7:0] out_230;
	output [7:0] out_231;
	output [7:0] out_232;
	output [7:0] out_233;
	output [7:0] out_234;
	output [7:0] out_235;
	output [7:0] out_236;
	output [7:0] out_237;
	output [7:0] out_238;
	output [7:0] out_239;
	output [7:0] out_240;
	output [7:0] out_241;
	output [7:0] out_242;
	output [7:0] out_243;
	output [7:0] out_244;
	output [7:0] out_245;
	output [7:0] out_246;
	output [7:0] out_247;
	output [7:0] out_248;
	output [7:0] out_249;
	output [7:0] out_250;
	output [7:0] out_251;
	output [7:0] out_252;
	output [7:0] out_253;
	output [7:0] out_254;
	output [7:0] out_255;
	output [7:0] out_256;
	output [7:0] out_257;
	output [7:0] out_258;
	output [7:0] out_259;
	output [7:0] out_260;
	output [7:0] out_261;
	output [7:0] out_262;
	output [7:0] out_263;
	output [7:0] out_264;
	output [7:0] out_265;
	output [7:0] out_266;
	output [7:0] out_267;
	output [7:0] out_268;
	output [7:0] out_269;
	output [7:0] out_270;
	output [7:0] out_271;
	output [7:0] out_272;
	output [7:0] out_273;
	output [7:0] out_274;
	output [7:0] out_275;
	output [7:0] out_276;
	output [7:0] out_277;
	output [7:0] out_278;
	output [7:0] out_279;
	output [7:0] out_280;
	output [7:0] out_281;
	output [7:0] out_282;
	output [7:0] out_283;
	output [7:0] out_284;
	output [7:0] out_285;
	output [7:0] out_286;
	output [7:0] out_287;
	output [7:0] out_288;
	output [7:0] out_289;
	output [7:0] out_290;
	output [7:0] out_291;
	output [7:0] out_292;
	output [7:0] out_293;
	output [7:0] out_294;
	output [7:0] out_295;
	output [7:0] out_296;
	output [7:0] out_297;
	output [7:0] out_298;
	output [7:0] out_299;
	output [7:0] out_300;
	output [7:0] out_301;
	output [7:0] out_302;
	output [7:0] out_303;
	output [7:0] out_304;
	output [7:0] out_305;
	output [7:0] out_306;
	output [7:0] out_307;
	output [7:0] out_308;
	output [7:0] out_309;
	output [7:0] out_310;
	output [7:0] out_311;
	output [7:0] out_312;
	output [7:0] out_313;
	output [7:0] out_314;
	output [7:0] out_315;
	output [7:0] out_316;
	output [7:0] out_317;
	output [7:0] out_318;
	output [7:0] out_319;
	output [7:0] out_320;
	output [7:0] out_321;
	output [7:0] out_322;
	output [7:0] out_323;
	output [7:0] out_324;
	output [7:0] out_325;
	output [7:0] out_326;
	output [7:0] out_327;
	output [7:0] out_328;
	output [7:0] out_329;
	output [7:0] out_330;
	output [7:0] out_331;
	output [7:0] out_332;
	output [7:0] out_333;
	output [7:0] out_334;
	output [7:0] out_335;
	output [7:0] out_336;
	output [7:0] out_337;
	output [7:0] out_338;
	output [7:0] out_339;
	output [7:0] out_340;
	output [7:0] out_341;
	output [7:0] out_342;
	output [7:0] out_343;
	output [7:0] out_344;
	output [7:0] out_345;
	output [7:0] out_346;
	output [7:0] out_347;
	output [7:0] out_348;
	output [7:0] out_349;
	output [7:0] out_350;
	output [7:0] out_351;
	output [7:0] out_352;
	output [7:0] out_353;
	output [7:0] out_354;
	output [7:0] out_355;
	output [7:0] out_356;
	output [7:0] out_357;
	output [7:0] out_358;
	output [7:0] out_359;
	output [7:0] out_360;
	output [7:0] out_361;
	output [7:0] out_362;
	output [7:0] out_363;
	output [7:0] out_364;
	output [7:0] out_365;
	output [7:0] out_366;
	output [7:0] out_367;
	output [7:0] out_368;
	output [7:0] out_369;
	output [7:0] out_370;
	output [7:0] out_371;
	output [7:0] out_372;
	output [7:0] out_373;
	output [7:0] out_374;
	output [7:0] out_375;
	output [7:0] out_376;
	output [7:0] out_377;
	output [7:0] out_378;
	output [7:0] out_379;
	output [7:0] out_380;
	output [7:0] out_381;
	output [7:0] out_382;
	output [7:0] out_383;
	output [7:0] out_384;
	output [7:0] out_385;
	output [7:0] out_386;
	output [7:0] out_387;
	output [7:0] out_388;
	output [7:0] out_389;
	output [7:0] out_390;
	output [7:0] out_391;
	output [7:0] out_392;
	output [7:0] out_393;
	output [7:0] out_394;
	output [7:0] out_395;
	output [7:0] out_396;
	output [7:0] out_397;
	output [7:0] out_398;
	output [7:0] out_399;
	output [7:0] out_400;
	output [7:0] out_401;
	output [7:0] out_402;
	output [7:0] out_403;
	output [7:0] out_404;
	output [7:0] out_405;
	output [7:0] out_406;
	output [7:0] out_407;
	output [7:0] out_408;
	output [7:0] out_409;
	output [7:0] out_410;
	output [7:0] out_411;
	output [7:0] out_412;
	output [7:0] out_413;
	output [7:0] out_414;
	output [7:0] out_415;
	output [7:0] out_416;
	output [7:0] out_417;
	output [7:0] out_418;
	output [7:0] out_419;
	output [7:0] out_420;
	output [7:0] out_421;
	output [7:0] out_422;
	output [7:0] out_423;
	output [7:0] out_424;
	output [7:0] out_425;
	output [7:0] out_426;
	output [7:0] out_427;
	output [7:0] out_428;
	output [7:0] out_429;
	output [7:0] out_430;
	output [7:0] out_431;
	output [7:0] out_432;

	AES_SBox_GF_2_2_2_PolyNormMixBasis_1 u_sbox_1 (.out(out_1), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_2 u_sbox_2 (.out(out_2), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_3 u_sbox_3 (.out(out_3), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_4 u_sbox_4 (.out(out_4), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_5 u_sbox_5 (.out(out_5), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_6 u_sbox_6 (.out(out_6), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_7 u_sbox_7 (.out(out_7), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_8 u_sbox_8 (.out(out_8), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_9 u_sbox_9 (.out(out_9), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_10 u_sbox_10 (.out(out_10), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_11 u_sbox_11 (.out(out_11), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_12 u_sbox_12 (.out(out_12), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_13 u_sbox_13 (.out(out_13), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_14 u_sbox_14 (.out(out_14), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_15 u_sbox_15 (.out(out_15), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_16 u_sbox_16 (.out(out_16), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_17 u_sbox_17 (.out(out_17), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_18 u_sbox_18 (.out(out_18), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_19 u_sbox_19 (.out(out_19), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_20 u_sbox_20 (.out(out_20), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_21 u_sbox_21 (.out(out_21), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_22 u_sbox_22 (.out(out_22), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_23 u_sbox_23 (.out(out_23), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_24 u_sbox_24 (.out(out_24), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_25 u_sbox_25 (.out(out_25), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_26 u_sbox_26 (.out(out_26), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_27 u_sbox_27 (.out(out_27), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_28 u_sbox_28 (.out(out_28), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_29 u_sbox_29 (.out(out_29), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_30 u_sbox_30 (.out(out_30), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_31 u_sbox_31 (.out(out_31), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_32 u_sbox_32 (.out(out_32), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_33 u_sbox_33 (.out(out_33), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_34 u_sbox_34 (.out(out_34), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_35 u_sbox_35 (.out(out_35), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_36 u_sbox_36 (.out(out_36), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_37 u_sbox_37 (.out(out_37), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_38 u_sbox_38 (.out(out_38), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_39 u_sbox_39 (.out(out_39), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_40 u_sbox_40 (.out(out_40), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_41 u_sbox_41 (.out(out_41), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_42 u_sbox_42 (.out(out_42), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_43 u_sbox_43 (.out(out_43), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_44 u_sbox_44 (.out(out_44), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_45 u_sbox_45 (.out(out_45), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_46 u_sbox_46 (.out(out_46), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_47 u_sbox_47 (.out(out_47), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_48 u_sbox_48 (.out(out_48), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_49 u_sbox_49 (.out(out_49), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_50 u_sbox_50 (.out(out_50), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_51 u_sbox_51 (.out(out_51), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_52 u_sbox_52 (.out(out_52), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_53 u_sbox_53 (.out(out_53), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_54 u_sbox_54 (.out(out_54), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_55 u_sbox_55 (.out(out_55), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_56 u_sbox_56 (.out(out_56), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_57 u_sbox_57 (.out(out_57), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_58 u_sbox_58 (.out(out_58), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_59 u_sbox_59 (.out(out_59), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_60 u_sbox_60 (.out(out_60), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_61 u_sbox_61 (.out(out_61), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_62 u_sbox_62 (.out(out_62), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_63 u_sbox_63 (.out(out_63), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_64 u_sbox_64 (.out(out_64), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_65 u_sbox_65 (.out(out_65), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_66 u_sbox_66 (.out(out_66), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_67 u_sbox_67 (.out(out_67), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_68 u_sbox_68 (.out(out_68), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_69 u_sbox_69 (.out(out_69), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_70 u_sbox_70 (.out(out_70), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_71 u_sbox_71 (.out(out_71), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_72 u_sbox_72 (.out(out_72), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_73 u_sbox_73 (.out(out_73), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_74 u_sbox_74 (.out(out_74), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_75 u_sbox_75 (.out(out_75), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_76 u_sbox_76 (.out(out_76), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_77 u_sbox_77 (.out(out_77), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_78 u_sbox_78 (.out(out_78), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_79 u_sbox_79 (.out(out_79), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_80 u_sbox_80 (.out(out_80), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_81 u_sbox_81 (.out(out_81), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_82 u_sbox_82 (.out(out_82), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_83 u_sbox_83 (.out(out_83), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_84 u_sbox_84 (.out(out_84), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_85 u_sbox_85 (.out(out_85), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_86 u_sbox_86 (.out(out_86), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_87 u_sbox_87 (.out(out_87), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_88 u_sbox_88 (.out(out_88), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_89 u_sbox_89 (.out(out_89), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_90 u_sbox_90 (.out(out_90), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_91 u_sbox_91 (.out(out_91), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_92 u_sbox_92 (.out(out_92), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_93 u_sbox_93 (.out(out_93), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_94 u_sbox_94 (.out(out_94), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_95 u_sbox_95 (.out(out_95), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_96 u_sbox_96 (.out(out_96), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_97 u_sbox_97 (.out(out_97), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_98 u_sbox_98 (.out(out_98), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_99 u_sbox_99 (.out(out_99), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_100 u_sbox_100 (.out(out_100), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_101 u_sbox_101 (.out(out_101), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_102 u_sbox_102 (.out(out_102), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_103 u_sbox_103 (.out(out_103), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_104 u_sbox_104 (.out(out_104), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_105 u_sbox_105 (.out(out_105), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_106 u_sbox_106 (.out(out_106), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_107 u_sbox_107 (.out(out_107), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_108 u_sbox_108 (.out(out_108), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_109 u_sbox_109 (.out(out_109), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_110 u_sbox_110 (.out(out_110), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_111 u_sbox_111 (.out(out_111), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_112 u_sbox_112 (.out(out_112), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_113 u_sbox_113 (.out(out_113), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_114 u_sbox_114 (.out(out_114), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_115 u_sbox_115 (.out(out_115), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_116 u_sbox_116 (.out(out_116), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_117 u_sbox_117 (.out(out_117), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_118 u_sbox_118 (.out(out_118), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_119 u_sbox_119 (.out(out_119), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_120 u_sbox_120 (.out(out_120), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_121 u_sbox_121 (.out(out_121), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_122 u_sbox_122 (.out(out_122), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_123 u_sbox_123 (.out(out_123), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_124 u_sbox_124 (.out(out_124), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_125 u_sbox_125 (.out(out_125), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_126 u_sbox_126 (.out(out_126), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_127 u_sbox_127 (.out(out_127), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_128 u_sbox_128 (.out(out_128), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_129 u_sbox_129 (.out(out_129), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_130 u_sbox_130 (.out(out_130), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_131 u_sbox_131 (.out(out_131), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_132 u_sbox_132 (.out(out_132), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_133 u_sbox_133 (.out(out_133), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_134 u_sbox_134 (.out(out_134), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_135 u_sbox_135 (.out(out_135), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_136 u_sbox_136 (.out(out_136), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_137 u_sbox_137 (.out(out_137), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_138 u_sbox_138 (.out(out_138), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_139 u_sbox_139 (.out(out_139), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_140 u_sbox_140 (.out(out_140), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_141 u_sbox_141 (.out(out_141), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_142 u_sbox_142 (.out(out_142), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_143 u_sbox_143 (.out(out_143), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_144 u_sbox_144 (.out(out_144), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_145 u_sbox_145 (.out(out_145), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_146 u_sbox_146 (.out(out_146), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_147 u_sbox_147 (.out(out_147), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_148 u_sbox_148 (.out(out_148), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_149 u_sbox_149 (.out(out_149), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_150 u_sbox_150 (.out(out_150), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_151 u_sbox_151 (.out(out_151), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_152 u_sbox_152 (.out(out_152), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_153 u_sbox_153 (.out(out_153), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_154 u_sbox_154 (.out(out_154), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_155 u_sbox_155 (.out(out_155), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_156 u_sbox_156 (.out(out_156), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_157 u_sbox_157 (.out(out_157), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_158 u_sbox_158 (.out(out_158), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_159 u_sbox_159 (.out(out_159), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_160 u_sbox_160 (.out(out_160), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_161 u_sbox_161 (.out(out_161), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_162 u_sbox_162 (.out(out_162), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_163 u_sbox_163 (.out(out_163), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_164 u_sbox_164 (.out(out_164), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_165 u_sbox_165 (.out(out_165), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_166 u_sbox_166 (.out(out_166), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_167 u_sbox_167 (.out(out_167), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_168 u_sbox_168 (.out(out_168), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_169 u_sbox_169 (.out(out_169), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_170 u_sbox_170 (.out(out_170), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_171 u_sbox_171 (.out(out_171), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_172 u_sbox_172 (.out(out_172), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_173 u_sbox_173 (.out(out_173), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_174 u_sbox_174 (.out(out_174), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_175 u_sbox_175 (.out(out_175), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_176 u_sbox_176 (.out(out_176), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_177 u_sbox_177 (.out(out_177), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_178 u_sbox_178 (.out(out_178), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_179 u_sbox_179 (.out(out_179), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_180 u_sbox_180 (.out(out_180), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_181 u_sbox_181 (.out(out_181), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_182 u_sbox_182 (.out(out_182), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_183 u_sbox_183 (.out(out_183), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_184 u_sbox_184 (.out(out_184), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_185 u_sbox_185 (.out(out_185), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_186 u_sbox_186 (.out(out_186), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_187 u_sbox_187 (.out(out_187), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_188 u_sbox_188 (.out(out_188), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_189 u_sbox_189 (.out(out_189), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_190 u_sbox_190 (.out(out_190), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_191 u_sbox_191 (.out(out_191), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_192 u_sbox_192 (.out(out_192), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_193 u_sbox_193 (.out(out_193), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_194 u_sbox_194 (.out(out_194), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_195 u_sbox_195 (.out(out_195), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_196 u_sbox_196 (.out(out_196), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_197 u_sbox_197 (.out(out_197), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_198 u_sbox_198 (.out(out_198), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_199 u_sbox_199 (.out(out_199), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_200 u_sbox_200 (.out(out_200), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_201 u_sbox_201 (.out(out_201), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_202 u_sbox_202 (.out(out_202), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_203 u_sbox_203 (.out(out_203), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_204 u_sbox_204 (.out(out_204), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_205 u_sbox_205 (.out(out_205), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_206 u_sbox_206 (.out(out_206), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_207 u_sbox_207 (.out(out_207), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_208 u_sbox_208 (.out(out_208), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_209 u_sbox_209 (.out(out_209), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_210 u_sbox_210 (.out(out_210), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_211 u_sbox_211 (.out(out_211), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_212 u_sbox_212 (.out(out_212), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_213 u_sbox_213 (.out(out_213), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_214 u_sbox_214 (.out(out_214), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_215 u_sbox_215 (.out(out_215), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_216 u_sbox_216 (.out(out_216), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_217 u_sbox_217 (.out(out_217), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_218 u_sbox_218 (.out(out_218), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_219 u_sbox_219 (.out(out_219), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_220 u_sbox_220 (.out(out_220), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_221 u_sbox_221 (.out(out_221), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_222 u_sbox_222 (.out(out_222), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_223 u_sbox_223 (.out(out_223), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_224 u_sbox_224 (.out(out_224), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_225 u_sbox_225 (.out(out_225), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_226 u_sbox_226 (.out(out_226), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_227 u_sbox_227 (.out(out_227), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_228 u_sbox_228 (.out(out_228), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_229 u_sbox_229 (.out(out_229), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_230 u_sbox_230 (.out(out_230), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_231 u_sbox_231 (.out(out_231), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_232 u_sbox_232 (.out(out_232), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_233 u_sbox_233 (.out(out_233), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_234 u_sbox_234 (.out(out_234), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_235 u_sbox_235 (.out(out_235), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_236 u_sbox_236 (.out(out_236), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_237 u_sbox_237 (.out(out_237), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_238 u_sbox_238 (.out(out_238), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_239 u_sbox_239 (.out(out_239), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_240 u_sbox_240 (.out(out_240), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_241 u_sbox_241 (.out(out_241), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_242 u_sbox_242 (.out(out_242), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_243 u_sbox_243 (.out(out_243), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_244 u_sbox_244 (.out(out_244), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_245 u_sbox_245 (.out(out_245), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_246 u_sbox_246 (.out(out_246), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_247 u_sbox_247 (.out(out_247), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_248 u_sbox_248 (.out(out_248), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_249 u_sbox_249 (.out(out_249), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_250 u_sbox_250 (.out(out_250), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_251 u_sbox_251 (.out(out_251), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_252 u_sbox_252 (.out(out_252), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_253 u_sbox_253 (.out(out_253), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_254 u_sbox_254 (.out(out_254), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_255 u_sbox_255 (.out(out_255), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_256 u_sbox_256 (.out(out_256), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_257 u_sbox_257 (.out(out_257), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_258 u_sbox_258 (.out(out_258), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_259 u_sbox_259 (.out(out_259), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_260 u_sbox_260 (.out(out_260), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_261 u_sbox_261 (.out(out_261), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_262 u_sbox_262 (.out(out_262), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_263 u_sbox_263 (.out(out_263), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_264 u_sbox_264 (.out(out_264), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_265 u_sbox_265 (.out(out_265), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_266 u_sbox_266 (.out(out_266), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_267 u_sbox_267 (.out(out_267), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_268 u_sbox_268 (.out(out_268), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_269 u_sbox_269 (.out(out_269), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_270 u_sbox_270 (.out(out_270), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_271 u_sbox_271 (.out(out_271), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_272 u_sbox_272 (.out(out_272), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_273 u_sbox_273 (.out(out_273), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_274 u_sbox_274 (.out(out_274), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_275 u_sbox_275 (.out(out_275), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_276 u_sbox_276 (.out(out_276), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_277 u_sbox_277 (.out(out_277), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_278 u_sbox_278 (.out(out_278), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_279 u_sbox_279 (.out(out_279), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_280 u_sbox_280 (.out(out_280), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_281 u_sbox_281 (.out(out_281), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_282 u_sbox_282 (.out(out_282), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_283 u_sbox_283 (.out(out_283), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_284 u_sbox_284 (.out(out_284), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_285 u_sbox_285 (.out(out_285), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_286 u_sbox_286 (.out(out_286), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_287 u_sbox_287 (.out(out_287), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_288 u_sbox_288 (.out(out_288), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_289 u_sbox_289 (.out(out_289), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_290 u_sbox_290 (.out(out_290), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_291 u_sbox_291 (.out(out_291), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_292 u_sbox_292 (.out(out_292), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_293 u_sbox_293 (.out(out_293), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_294 u_sbox_294 (.out(out_294), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_295 u_sbox_295 (.out(out_295), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_296 u_sbox_296 (.out(out_296), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_297 u_sbox_297 (.out(out_297), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_298 u_sbox_298 (.out(out_298), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_299 u_sbox_299 (.out(out_299), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_300 u_sbox_300 (.out(out_300), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_301 u_sbox_301 (.out(out_301), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_302 u_sbox_302 (.out(out_302), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_303 u_sbox_303 (.out(out_303), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_304 u_sbox_304 (.out(out_304), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_305 u_sbox_305 (.out(out_305), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_306 u_sbox_306 (.out(out_306), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_307 u_sbox_307 (.out(out_307), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_308 u_sbox_308 (.out(out_308), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_309 u_sbox_309 (.out(out_309), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_310 u_sbox_310 (.out(out_310), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_311 u_sbox_311 (.out(out_311), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_312 u_sbox_312 (.out(out_312), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_313 u_sbox_313 (.out(out_313), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_314 u_sbox_314 (.out(out_314), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_315 u_sbox_315 (.out(out_315), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_316 u_sbox_316 (.out(out_316), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_317 u_sbox_317 (.out(out_317), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_318 u_sbox_318 (.out(out_318), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_319 u_sbox_319 (.out(out_319), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_320 u_sbox_320 (.out(out_320), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_321 u_sbox_321 (.out(out_321), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_322 u_sbox_322 (.out(out_322), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_323 u_sbox_323 (.out(out_323), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_324 u_sbox_324 (.out(out_324), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_325 u_sbox_325 (.out(out_325), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_326 u_sbox_326 (.out(out_326), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_327 u_sbox_327 (.out(out_327), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_328 u_sbox_328 (.out(out_328), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_329 u_sbox_329 (.out(out_329), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_330 u_sbox_330 (.out(out_330), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_331 u_sbox_331 (.out(out_331), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_332 u_sbox_332 (.out(out_332), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_333 u_sbox_333 (.out(out_333), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_334 u_sbox_334 (.out(out_334), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_335 u_sbox_335 (.out(out_335), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_336 u_sbox_336 (.out(out_336), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_337 u_sbox_337 (.out(out_337), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_338 u_sbox_338 (.out(out_338), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_339 u_sbox_339 (.out(out_339), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_340 u_sbox_340 (.out(out_340), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_341 u_sbox_341 (.out(out_341), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_342 u_sbox_342 (.out(out_342), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_343 u_sbox_343 (.out(out_343), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_344 u_sbox_344 (.out(out_344), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_345 u_sbox_345 (.out(out_345), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_346 u_sbox_346 (.out(out_346), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_347 u_sbox_347 (.out(out_347), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_348 u_sbox_348 (.out(out_348), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_349 u_sbox_349 (.out(out_349), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_350 u_sbox_350 (.out(out_350), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_351 u_sbox_351 (.out(out_351), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_352 u_sbox_352 (.out(out_352), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_353 u_sbox_353 (.out(out_353), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_354 u_sbox_354 (.out(out_354), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_355 u_sbox_355 (.out(out_355), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_356 u_sbox_356 (.out(out_356), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_357 u_sbox_357 (.out(out_357), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_358 u_sbox_358 (.out(out_358), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_359 u_sbox_359 (.out(out_359), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_360 u_sbox_360 (.out(out_360), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_361 u_sbox_361 (.out(out_361), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_362 u_sbox_362 (.out(out_362), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_363 u_sbox_363 (.out(out_363), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_364 u_sbox_364 (.out(out_364), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_365 u_sbox_365 (.out(out_365), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_366 u_sbox_366 (.out(out_366), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_367 u_sbox_367 (.out(out_367), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_368 u_sbox_368 (.out(out_368), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_369 u_sbox_369 (.out(out_369), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_370 u_sbox_370 (.out(out_370), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_371 u_sbox_371 (.out(out_371), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_372 u_sbox_372 (.out(out_372), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_373 u_sbox_373 (.out(out_373), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_374 u_sbox_374 (.out(out_374), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_375 u_sbox_375 (.out(out_375), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_376 u_sbox_376 (.out(out_376), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_377 u_sbox_377 (.out(out_377), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_378 u_sbox_378 (.out(out_378), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_379 u_sbox_379 (.out(out_379), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_380 u_sbox_380 (.out(out_380), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_381 u_sbox_381 (.out(out_381), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_382 u_sbox_382 (.out(out_382), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_383 u_sbox_383 (.out(out_383), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_384 u_sbox_384 (.out(out_384), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_385 u_sbox_385 (.out(out_385), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_386 u_sbox_386 (.out(out_386), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_387 u_sbox_387 (.out(out_387), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_388 u_sbox_388 (.out(out_388), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_389 u_sbox_389 (.out(out_389), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_390 u_sbox_390 (.out(out_390), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_391 u_sbox_391 (.out(out_391), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_392 u_sbox_392 (.out(out_392), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_393 u_sbox_393 (.out(out_393), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_394 u_sbox_394 (.out(out_394), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_395 u_sbox_395 (.out(out_395), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_396 u_sbox_396 (.out(out_396), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_397 u_sbox_397 (.out(out_397), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_398 u_sbox_398 (.out(out_398), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_399 u_sbox_399 (.out(out_399), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_400 u_sbox_400 (.out(out_400), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_401 u_sbox_401 (.out(out_401), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_402 u_sbox_402 (.out(out_402), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_403 u_sbox_403 (.out(out_403), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_404 u_sbox_404 (.out(out_404), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_405 u_sbox_405 (.out(out_405), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_406 u_sbox_406 (.out(out_406), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_407 u_sbox_407 (.out(out_407), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_408 u_sbox_408 (.out(out_408), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_409 u_sbox_409 (.out(out_409), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_410 u_sbox_410 (.out(out_410), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_411 u_sbox_411 (.out(out_411), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_412 u_sbox_412 (.out(out_412), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_413 u_sbox_413 (.out(out_413), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_414 u_sbox_414 (.out(out_414), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_415 u_sbox_415 (.out(out_415), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_416 u_sbox_416 (.out(out_416), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_417 u_sbox_417 (.out(out_417), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_418 u_sbox_418 (.out(out_418), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_419 u_sbox_419 (.out(out_419), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_420 u_sbox_420 (.out(out_420), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_421 u_sbox_421 (.out(out_421), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_422 u_sbox_422 (.out(out_422), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_423 u_sbox_423 (.out(out_423), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_424 u_sbox_424 (.out(out_424), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_425 u_sbox_425 (.out(out_425), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_426 u_sbox_426 (.out(out_426), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_427 u_sbox_427 (.out(out_427), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_428 u_sbox_428 (.out(out_428), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_429 u_sbox_429 (.out(out_429), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_430 u_sbox_430 (.out(out_430), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_431 u_sbox_431 (.out(out_431), .in(in));
	AES_SBox_GF_2_2_2_PolyNormMixBasis_432 u_sbox_432 (.out(out_432), .in(in));

endmodule




/************************************
* END OF FILE
************************************/


